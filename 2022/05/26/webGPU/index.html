<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="译：WebGPU — All of the cores, none of the canvas, 生命不息 折腾不止">
    <meta name="description" content="
原文地址：WebGPU — All of the cores, none of the canvas

WebGPU 是一个即将推出的 Web API，让你可以使用低层的、通用的方法访问 GPU。  
我在图形方面的经验不多。我通过阅读关">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <title>译：WebGPU — All of the cores, none of the canvas | 生命不息 折腾不止</title>
    <link href="https://konata.tech/atom.xml" rel="alternate" type="application/atom+xml">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png"/>
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#7312ff">
    <meta name="msapplication-TileColor" content="#8a46cc">
    <meta name="theme-color" content="#ffffff">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/animate.css@3.5.1/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/css/bundle.css">
    
    <link rel="preload" href="/js/bundle.js" as="script">
    <script async type="application/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.0/lazysizes.min.js"></script>
    <!--    <script async defer data-website-id="4873cf0d-ee04-4c6c-85e1-5c2f72f5b538" src="https://umami.konata.tech/umami.js"></script>-->
    <!--百度统计-->
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?9ddaf48fd2830c5e3ef6e7c09c5a914c";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>
    <style type="text/css">
        
    </style>
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
<div id="waifu">
    <div id="waifu-message"></div>
    <div class="waifu-tool">
        <span class="icon-next"></span>
        <span class="icon-home"></span>
        <span class="icon-message"></span>
        <span class="icon-camera"></span>
        <span class="icon-volumeup"></span>
        <span class="icon-volumedown"></span>
        <span class="icon-about"></span>
        <span class="icon-cross"></span>
    </div>
    <canvas id="live2d2"></canvas>
    <canvas id="live2d4"></canvas>
</div>
<script src="/live2d/live2d_bundle.js"></script>
<div class="mute">
    <img id="audioOff" src="" class="controller__audio--off" style="display: block;">
    <img id="audioOn" src="" class="controller__audio--on" style="display: none;">
</div>
<header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
<!--                <a href="/" class="waves-effect waves-light">-->
<!--                    -->
<!--                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">-->
<!--                    -->
<!--                    <span class="logo-span">生命不息 折腾不止</span>-->
<!--                </a>-->
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-bars"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img data-src="/medias/logo.png" class="logo-img circle responsive-img lazyload">
        
        <div class="logo-name">生命不息 折腾不止</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle"></i>
                
                关于
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/Konata09" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        bottom: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #221f23;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/Konata09" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>
</header>





<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/05.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        译：WebGPU — All of the cores, none of the canvas
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #0396FF;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #0396FF;
    }

    #toc-content .is-active-link::before {
        background-color: #0396FF;
    }

</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/JavaScript/" target="_blank">
                                <span class="chip bg-color">JavaScript</span>
                            </a>
                        
                            <a href="/tags/WebGPU/" target="_blank">
                                <span class="chip bg-color">WebGPU</span>
                            </a>
                        
                            <a href="/tags/WGSL/" target="_blank">
                                <span class="chip bg-color">WGSL</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Browser/" class="post-category" target="_blank">
                                Browser
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-alt fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-05-26
                </div>

                
                    
                    <div class="info-break-policy">
                        <i class="fa fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                        10.7k
                    </div>
                    

                    
                    <div class="info-break-policy">
                        <i class="fa fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                        39 分
                    </div>
                    
                
				
				
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <blockquote>
<p>原文地址：<a target="_blank" rel="noopener" href="https://surma.dev/things/webgpu/">WebGPU — All of the cores, none of the canvas</a></p>
</blockquote>
<p>WebGPU 是一个即将推出的 Web API，让你可以使用低层的、通用的方法访问 GPU。  </p>
<p>我在图形方面的经验不多。我通过阅读关于如何用 OpenGL 构建游戏引擎的教程来学习 WebGL 的零碎知识，并通过观看 <a target="_blank" rel="noopener" href="https://twitter.com/iquilezles">Inigo Quilez</a> 在 <a target="_blank" rel="noopener" href="https://shadertoy.com/">ShaderToy</a> 上只使用着色器而不使用任何 3D 网格或模型来学习着色器。这让我足以完成像 <a target="_blank" rel="noopener" href="https://proxx.app/">PROXX</a> 中的背景动画这样的工作，但我觉得 WebGL 一直不够<em>舒适</em>，很快我就会解释原因。  </p>
<p>当 WebGPU 出现在我的视野中时，我想投身到其中，但许多人警告我，WebGPU 比 WebGL 更加样板。我并不气馁，但预计到最坏的情况，我把我能找到的所有教程和规范收集在一起，由于 WebGPU 还处于早期阶段，所以并没有很多。我试了试，我并没有发现 WebGPU 比 WebGL 明显地更像样板化，而实际上是一个我更喜欢的 API。  </p>
<p>所以，我们来了。我想与大家分享我在接触 GPU 和 WebGPU 时学到的东西。这篇博文的目标是使 WebGPU 对 Web 开发者来说是可接受的。但这里要提前提醒一下。我不会使用 WebGPU 来生成图形。相反，我将使用 WebGPU 来访问 GPU 提供的原始计算能力。也许我会写一篇后续博文，介绍如何使用 WebGPU 渲染到你的屏幕上，但现在已经有 <a target="_blank" rel="noopener" href="https://austin-eng.com/webgpu-samples">不少内容</a> 了。我将尽可能深入地了解 WebGPU 的意义，并希望你能<em>有效</em>地使用它——但不一定是<em>高效</em>的。我不能让你成为 GPU 性能专家，主要是因为我自己也不是专家。  </p>
<p>我写了一个很长的声明，下面正式开始！  </p>
<h2 id="WebGL"><a href="#WebGL" class="headerlink" title="WebGL"></a>WebGL</h2><p><a target="_blank" rel="noopener" href="https://www.khronos.org/registry/webgl/specs/latest/1.0/">WebGL</a> 出现在 2011 年，到目前为止，它是唯一可以从 Web 上访问 GPU 的底层的 API。WebGL 的 API 实际上只是 OpenGL ES 2.0，加上一些简单的封装和 helper，使其与 Web 兼容。WebGL 和 OpenGL 都是由 <a target="_blank" rel="noopener" href="https://www.khronos.org/">Khronos 组织</a> 标准化的，该集团基本上是 3D 图形界的 W3C。  </p>
<p>OpenGL 的 API 本身甚至可以追溯到更早以前，以今天的标准来看，它不是一个很好的 API。该设计以内部的全局状态对象为中心。因为它最大限度地减少了在任何调用中需要传入和传出到 GPU 的数据量，从这个角度来看，这种设计是有道理的。然而，它也带来了很多理解上的困难。  </p>
<p><img src="/images/1653570377302.png" alt="一个 WebGL 的内部可视化，全局状态对象。来自：[WebGL Fundamentals](https://webglfundamentals.org/webgl/lessons/resources/webgl-state-diagram.html)"></p>
<p>内部状态对象基本上是一个指针的集合。你的 API 调用可以影响状态对象所指向的对象，但也可以影响状态对象本身。因此，API 调用的顺序是非常重要的，我总觉得这使得抽象和构建库变得很困难。你必须非常细致地理清所有可能干扰你进行 API 调用的指针和状态项，同时还要将指针和值恢复到之前的值，这样你的抽象才能正确生成。我经常发现自己盯着一块黑色的画布（因为几乎所有 WebGL 中的报错都会导致这样），并对哪个指针目前没有正确指向进行粗略的判断。老实说，我不知道 <a target="_blank" rel="noopener" href="https://threejs.org/">ThreeJS</a> 是如何做到如此健壮的，但它确实做到了。我想这是大多数人使用 ThreeJS 而不是直接使用 WebGL 的主要原因之一。  </p>
<blockquote>
<p><strong>这不是你的问题，而是我的问题</strong>：说白了，我不能消化 WebGL 可能是我的问题。比我聪明的人都能用 WebGL（以及 Web 之外的 OpenGL）构建出<em>惊人</em>的东西，但对我来说，它不适合我。  </p>
</blockquote>
<p>随着 ML、神经网络和加密货币的出现，GPU 已经显示出它们不仅可以在屏幕上绘制三角形，还有更大的作用。使用 GPU 进行任何形式的计算通常被称为通用 GPU（General-Purpose GPU，GPGPU），而 WebGL 1 在这方面并不出色。如果你想在 GPU 上处理任意数据，你必须将其编码为纹理，在着色器中解码，进行计算，然后将结果重新编码为纹理。WebGL 2 通过 <a target="_blank" rel="noopener" href="https://webgl2fundamentals.org/webgl/lessons/webgl-gpgpu.html">Transform Feedback</a> 使这个问题变得简单多了，但是 WebGL2 直到 2021 年 9 月才被 Safari 支持（而其他大多数浏览器从 2017 年 1 月开始支持 WebGL2），所以它并不是一个好的选择。即便如此，WebGL2 的某些限制仍然让人感觉有些笨拙。  </p>
<h2 id="WebGPU"><a href="#WebGPU" class="headerlink" title="WebGPU"></a>WebGPU</h2><p>在 Web 之外，新一代的图形 API 已经建立起来，它为显卡提供了一个更低级的接口。这些新的 API 适应了设计 OpenGL 时不存在的新用例和约束。一方面，GPU 现在几乎无处不在。甚至移动设备也内置了功能强大的 GPU。因此，现代图形编程（3D 渲染和光线追踪）和 GPGPU 的使用<em>都</em>越来越普遍。另一方面，大多数设备都有多核处理器，因此能够从多个线程与 GPU 进行交互可能是一个重要的优化因素。当 WebGPU 的人在做这件事的时候，他们也重新审视了以前的一些设计决策，并将 GPU 必须做的很多验证工作前置，使开发者能够从 GPU 中榨取更多的性能。  </p>
<p>下一代 GPU API 中最受欢迎的是 Khronos 集团的 <a target="_blank" rel="noopener" href="https://www.vulkan.org/">Vulkan</a>、苹果的 <a target="_blank" rel="noopener" href="https://developer.apple.com/metal/">Metal</a> 和微软的 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/direct3d12/direct3d-12-graphics">DirectX 12</a>。为了给网络带来这些新功能，WebGPU 诞生了。虽然 WebGL 只是 OpenGL 的一个简单的封装，但 WebGPU 选择了不同的道路。它引入了自己的抽象，并不直接映射原生 API。部分原因是没有一个 API 可以在所有系统上使用，同时也是因为许多概念（比如极低级别的内存管理）对于面向 Web 的 API 来说并不习惯。相反，WebGPU 的设计既让人感觉『webby』，又能舒适地位于任何原生图形 API 之上，同时抽象出它们的特性。它在 W3C 中被标准化，所有主要的浏览器厂商都有一个席位。由于其相对低级的性质及其强大的功能，WebGPU 有一点学习曲线，并且在设置上相对繁重，但我将尽可能地分解它。  </p>
<h3 id="适配器（Adapters）与设备（Devices）"><a href="#适配器（Adapters）与设备（Devices）" class="headerlink" title="适配器（Adapters）与设备（Devices）"></a>适配器（Adapters）与设备（Devices）</h3><p>你首先接触到的 WebGPU 抽象是适配器（adapters） 和（逻辑）<em>设备</em>。  </p>
<p><img src="/images/1653570460438.svg" alt="抽象层，从物理 GPU 到逻辑设备"></p>
<p><em>物理</em>设备是指 GPU 本身，通常区分为内置 GPU 和独立 GPU。通常情况下，大部分设备都有一个 GPU，但也有可能有两个或更多的 GPU。例如，微软的 Surface Book 有一个低功率的集成 GPU 和一个高性能的独立 GPU，操作系统会根据需要在两者之间进行切换。  </p>
<p><em>驱动程序</em>——由 GPU 制造商提供——将以操作系统理解和期望的方式向操作系统展示 GPU 的能力。操作系统反过来可以使用操作系统提供的图形 API（如 Vulkan 或 Metal）将其暴露给应用程序。<br>GPU 是一种共享资源。它不仅被许多应用程序同时使用，而且还控制你在屏幕上看到的内容。需要有一种东西能让多个进程同时使用 GPU，这样每个应用程序就能把自己的用户界面放在屏幕上，而不干扰其他应用程序，甚至恶意读取其他应用程序的数据。对每个进程来说，它们看起来像是对物理 GPU 拥有唯一的控制权，但这显然不是真正的情况。这种多路复用主要是由驱动程序和操作系统完成的。  </p>
<p>适配器则是操作系统的原生图形 API 与 WebGPU 之间的转换层。由于浏览器是一个单一的操作系统级应用，它可以运行多个 Web 应用，因此又需要进行多路复用，使每个 Web 应用感觉到它对 GPU 有唯一的控制权。这在 WebGPU 中用逻辑设备的概念来模拟。<br>为了获得对一个适配器的访问，你可以调用 <code>navigator.gpu.requestAdapter()</code> 。在写这篇文章的时候，<a target="_blank" rel="noopener" href="https://gpuweb.github.io/gpuweb/#gpu-interface">requestAdapter()</a> 只有很少的选项。这些选项允许你请求一个高性能或低能耗的适配器。  </p>
<blockquote>
<p><strong>软件渲染</strong>：一些实现为没有 GPU 或 GPU 能力不足的系统提供了一个 “后备适配器”。后备适配器实际上是一个纯粹的软件实现，它不会很快，但可以保证你应用程序的功能。  </p>
</blockquote>
<p>如果成功了，即返回的适配器不是空的，你可以检查适配器的能力，并使用 <a target="_blank" rel="noopener" href="https://gpuweb.github.io/gpuweb/#gpuadapter">adapter.requestDevice()</a> 向适配器请求一个逻辑设备。  </p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>navigator<span class="token punctuation">.</span>gpu<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token string">"WebGPU not supported."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> adapter <span class="token operator">=</span> <span class="token keyword">await</span> navigator<span class="token punctuation">.</span>gpu<span class="token punctuation">.</span><span class="token function">requestAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>adapter<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token string">"Couldn’t request WebGPU adapter."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> device <span class="token operator">=</span> <span class="token keyword">await</span> adapter<span class="token punctuation">.</span><span class="token function">requestDevice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>device<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token string">"Couldn’t request WebGPU logical device."</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>如果没有提供任何参数， <code>requestDevice()</code> 将返回一个<em>不一定</em>符合物理设备能力的设备，而是 WebGPU 团队认为合理的、所有 GPU 的最低共同标准。<a target="_blank" rel="noopener" href="https://gpuweb.github.io/gpuweb/#limit">细节</a> 在 WebGPU 标准中规定。例如，即使我的 GPU 能够轻松地处理高达 4GiB 的数据缓冲区，但返回的 <code>device</code> 只允许最多 1GiB 的数据缓冲区，并将拒绝任何更大的数据缓冲区。这看起来可能有些限制，但实际上非常有用：如果你的 WebGPU 应用能使用默认设备运行，那么它将在大多数设备上运行。如果有必要，你可以通过 <code>adapter.limit</code> 检查物理 GPU 的实际限制，并通过向 <code>requestDevice()</code> 传递一个 options 对象来请求一个具有更高限制的 <code>decice</code> 。  </p>
<h3 id="着色器（Shaders）"><a href="#着色器（Shaders）" class="headerlink" title="着色器（Shaders）"></a>着色器（Shaders）</h3><p>如果你使用过 WebGL，你可能对顶点着色器和像素着色器（也译作片元着色器或片段着色器）很熟悉。在不做过多深入研究的情况下，传统的准备工作是这样的：你向你的 GPU 上传一个数据缓冲区，并告诉它如何将这些数据解释为一系列的三角形。每个顶点都占据了数据缓冲区的一个块，描述该顶点在三维空间中的位置，但也可能包括颜色、纹理 ID、法线和其他数据。列表中的每个顶点都由 GPU 在<em>顶点阶段</em>处理，在每个顶点运行<em>顶点着色器</em>，它将实现平移、旋转或透视变形等操作。  </p>
<blockquote>
<p><strong>着色器</strong>：『着色器』这个术语曾经让我感到困惑，因为你可以做的事情远不止是着色。但在过去的日子里（20 世纪 80 年代末），这个词是合适的：它是在 GPU 上运行的一小段代码，决定每个像素应该是什么颜色，这样你就可以对被渲染的物体进行着色，实现照明和阴影。如今，着色器泛指任何在 GPU 上运行的程序。  </p>
</blockquote>
<p>现在 GPU 对三角形进行光栅化处理，这意味着 GPU 会计算出每个三角形在屏幕上覆盖的像素。然后，每个像素由<em>像素着色器</em>处理，它可以访问像素坐标，也可以访问辅助数据来决定该像素应该是哪种颜色。如果使用得当，这个过程可以创造出令人惊叹的 3D 图形。  </p>
<p>这种将数据传给顶点着色器，然后传给像素着色器，再直接输出到屏幕上的系统被称为<em>管线</em>，在 WebGPU 中，你必须明确地定义你的管线。  </p>
<h3 id="管线（Pipeline）"><a href="#管线（Pipeline）" class="headerlink" title="管线（Pipeline）"></a>管线（Pipeline）</h3><p>目前，WebGPU 允许你创建两种类型的管线。渲染管线和计算管线。顾名思义，渲染管线是指创建一个 2D 图像。该图像不需要在屏幕上，但可以直接渲染到内存中（这被称为帧缓冲区）。计算管道更通用，它返回一个缓冲区，其中可以包含任何类型的数据。在这篇博文的其余部分，我将专注于计算管线，因为我喜欢把渲染管线看作是计算管线的一种特殊优化版本。现在，这既是历史上的倒退，因为计算管线是作为专用的渲染管线的泛化而构建的，也低估了这些管线在 GPU 中是不同的物理电路。然而，就 API 而言，我发现这种心理模型非常有帮助。在未来，似乎更多类型的管道——也许是光线追踪管道——将被添加到 WebGPU 中。  </p>
<p>在 WebGPU 中，管道由一个（或多个）可编程阶段组成，每个阶段由一个着色器和一个入口点定义。一个计算管线有一个 <code>compute</code> 阶段，而一个渲染管线有一个 <code>vertex</code> 和一个 <code>fragment</code> 阶段：  </p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> module <span class="token operator">=</span> device<span class="token punctuation">.</span><span class="token function">createShaderModule</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
    code<span class="token punctuation">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
    @stage(compute) @workgroup_size(64)
    fn main() &#123;
      // Pointless!
    &#125;
  </span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> pipeline <span class="token operator">=</span> device<span class="token punctuation">.</span><span class="token function">createComputePipeline</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
    compute<span class="token punctuation">:</span> <span class="token punctuation">&#123;</span>
        module<span class="token punctuation">,</span>
        entryPoint<span class="token punctuation">:</span> <span class="token string">"main"</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>这是 WebGPU 着色语言 <a target="_blank" rel="noopener" href="https://gpuweb.github.io/gpuweb/wgsl">WGSL</a>（发音为 “wig-sal”）的首次亮相。WGSL 给我的感觉是 Rust 和 GLSL 的混合。它有很多 Rust-y 语法和 GLSL 的全局函数（如 <code>dot()</code> , <code>norm()</code> , <code>len()</code> , …）、类型（如 <code>vec2</code> , <code>mat4x4</code> , …）和 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Swizzling_(computer_graphics)">符号混写（swizzling notation）</a>（如 <code>some_vec.xxy</code> , …）。浏览器将把你的 WGSL 编译成底层系统期望的东西。这可能是 DirectX 12 的 HLSL，Metal 的 MSL 和 Vulkan 的 <a target="_blank" rel="noopener" href="https://www.khronos.org/spir/">SPIR-V</a>。  </p>
<blockquote>
<p><strong>SPIR-V</strong>：<a target="_blank" rel="noopener" href="https://www.khronos.org/spir/">SPIR-V</a> 很有趣，因为它是一种开放的、二进制的、由 Khronos 集团标准化的中间格式。你可以把 SPIR-V 看作是并行编程语言编译器的 LLVM，并且支持将许多语言编译成 SPIR-V，以及将 SPIR-V 编译成许多其他语言。  </p>
</blockquote>
<p>在上面的着色器模块中，我们只是创建了一个名为 main 的函数，并通过使用 <code>@stage(compute)</code> 属性将其标记为计算阶段的入口点。你可以在一个着色器模块中把多个函数标记为入口点，因为你可以在多个管道中重复使用同一个着色器模块，并通过 <code>entryPoint</code> 选项选择不同的函数来调用。但那个 <code>@workgroup_size(64)</code> 属性是什么？  </p>
<h3 id="并行化（Parallelism）"><a href="#并行化（Parallelism）" class="headerlink" title="并行化（Parallelism）"></a>并行化（Parallelism）</h3><p>GPU 是以延迟为代价来优化吞吐量的。为了理解这一点，我们必须看一下 GPU 的架构。我不想（说实话，也不能）完整地解释它。我会在觉得有必要的情况下深入研究。如果你想了解更多，<a target="_blank" rel="noopener" href="https://twitter.com/rygorous">Fabian Giesen</a> 的这个由 <a target="_blank" rel="noopener" href="https://fgiesen.wordpress.com/2011/07/09/a-trip-through-the-graphics-pipeline-2011-index/">13 部分组成的系列博文</a> 很不错。  </p>
<p>一些众所周知的事实是，GPU 有大量的内核，可以进行大规模的并行工作。然而，这些核心并不像你为多核 CPU 编程时那样独立。首先，GPU 的核心是分层分组的。层次结构中不同层的术语在不同制造商和 API 之间并不一致。Intel 有一份很好的 <a target="_blank" rel="noopener" href="https://www.intel.com/content/www/us/en/develop/documentation/oneapi-gpu-optimization-guide/top/intel-processors-with-intel-uhd-graphics.html">文档</a>，对其架构进行了高层次的概述，尽管 GPU 的确切架构是受 NDA 保护的秘密，但可以简单地假设其他 GPU 也是类似的架构。  </p>
<p>就英特尔而言，层次结构中的最低一级是 “执行单元”（EU，Execution Unit），它有多个（在这里是七个）<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Single_instruction,_multiple_threads">SIMT</a> 核心。这意味着它有七个核心，它们以锁步方式运行，并始终执行相同的指令。然而，每个内核都有自己的一组寄存器和堆栈指针。因此，虽然它们<em>必须</em>执行相同的操作，但它们可以在不同的数据上执行。这也是 GPU 性能专家避免分支（如 <code>if/else</code> 或循环）的原因。如果 EU 遇到一个 <code>if/else</code> ，所有的核心都必须执行这<em>两个</em>分支，除非所有的核心碰巧都进入相同的分支。每个核心可以被告知忽略输入的指令，但这显然浪费了本可以用于计算的宝贵周期。这一点同样适用于循环！如果一个核心提前结束了循环，它将不得不继续执行循环体，直到<em>所有</em>核心都完成了循环。  </p>
<p>尽管内核的频率很高，但从内存中获取数据（或从纹理中获取像素）仍然需要相对较长的时间——Fabian 说这需要几百个时钟周期。这几百个周期本可以用在计算上。为了利用这些原本闲置的周期，每个 EU 都有大量的超额工作。每当一个 EU 闲置时（例如等待内存中的一个值），它就会切换到另一个工作项目，只有当新的工作项目需要等待时才会切换回来。这是 GPU 如何以延迟为代价优化吞吐量的关键技巧：单个工作将花费更长的时间，因为切换到另一个工作可能会使停止执行的时间超过原本需要等待的时间，但整体利用率和吞吐量更高。GPU 努力使工作总是排在队列中，以使 EU 始终保持工作。  </p>
<p><img src="/images/1653570570094.png" alt="Intel Xe 显卡芯片架构，每个 EU 有 7 个 SIMT 核心，每个子切片（SubSlice）有 8 个 EU，8 个子切片组成一个切片（Slice）"></p>
<p>不过，EU 只是层次结构中的最低级别。多个 EU 被分组为英特尔所谓的『SubSlice（子切片）』。一个 SubSlice 中的所有 EU 都可以访问少量的共享本地内存（SLM，Shared Local Memory），在 Intel 的 Xe 中大约是 64KiB。如果要运行的程序有任何同步命令，它必须在同一个 SubSlice 内执行，因为只有它们有共享内存用于同步。<br>在最后一层，多个 SubSlices 被组合成一个 Slice，形成 GPU。对于集成的 Intel GPU，总共会有 170-700 个核心。独立的 GPU 可以拥有 1500 个甚至更多的核心。同样，这里的命名来自英特尔，其他厂商可能使用不同的名称，但每个 GPU 的大体架构是类似的。  </p>
<p>为了充分利用这种体系结构的优点，需要专门为此体系结构设置程序，以便纯程序化的 GPU 调度器可以最大限度地提高利用率。因此，图形 API 暴露了一个 <a target="_blank" rel="noopener" href="https://github.com/googlefonts/compute-shader-101/blob/main/docs/glossary.md">线程模型</a>，自然允许以这种方式分解工作。在 WebGPU 中，这里的重要基元是『工作组（workgroup）』。  </p>
<h3 id="工作组（Workgroups）"><a href="#工作组（Workgroups）" class="headerlink" title="工作组（Workgroups）"></a>工作组（Workgroups）</h3><p>在传统的设置中，顶点着色器被每个顶点调用一次，而像素着色器被每个像素被调用一次（我知道这里忽略了一些细节）。在 GPGPU 设置中，你的计算着色器将被你安排的每个工作项调用一次。至于什么是工作项，则由你来定义。  </p>
<p>所有工作项的集合（我称之为『工作负载（workload）』）被分解成若干个工作组（workgroups）。一个工作组中的所有工作项被安排在一起运行。在 WebGPU 中，工作负载被建模为一个 3 维网格，每个『立方体』是一个工作项，工作项组成更大的立方体以形成一个工作组。  </p>
<p><img src="/images/1653570591246.png" alt="这是一个工作负载（workload），白色边框的立方体是工作项（work item），红色边框的立方体是工作组（workgroup）"></p>
<p>终于，我们有足够的知识来讨论 <code>@workgroup_size(x, y, z)</code> 属性，它甚至可以说是不言自明的：该属性允许你告诉 GPU 这个着色器的工作组应该是什么大小。或者用上图的语言来说， <code>@workgroup_size</code> 属性定义了红色边框立方体的大小。 <code>x * y * z</code> 是每个工作组的工作项数量。任何跳过的参数都被假定为 1，所以 <code>@workgroup_size(64)</code> 相当于 <code>@workgroup_size(64, 1, 1)</code> 。  </p>
<p>当然，芯片上的实际 EU 并没有被安排的三维网格中。在三维网格中建立模型的目的是为了提高定位性。假设相邻的工作组可能会访问内存中的类似区域，因此当顺序运行相邻的工作组时，缓存命中的可能性会更高，从而不必从内存中获取值，从而节省几百个周期。然而，大多数硬件似乎只是以串行顺序运行工作组，因为运行 <code>@workgroup_size(64)</code> 和 <code>@workgroup_size(8, 8)</code> 的着色器之间的差异可以忽略不计。所以这个概念可能有点过时。  </p>
<p>然而，工作组在多个方面受到限制： <code>device.limit</code> 有一堆属性，值得了解一下：  </p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// device.limits</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// ...</span>
    maxComputeInvocationsPerWorkgroup<span class="token punctuation">:</span> <span class="token number">256</span><span class="token punctuation">,</span>
    maxComputeWorkgroupSizeX<span class="token punctuation">:</span> <span class="token number">256</span><span class="token punctuation">,</span>
    maxComputeWorkgroupSizeY<span class="token punctuation">:</span> <span class="token number">256</span><span class="token punctuation">,</span>
    maxComputeWorkgroupSizeZ<span class="token punctuation">:</span> <span class="token number">64</span><span class="token punctuation">,</span>
    maxComputeWorkgroupsPerDimension<span class="token punctuation">:</span> <span class="token number">65535</span><span class="token punctuation">,</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>工作组规模的每个维度的大小都有限制，但即使 x、y 和 z 单独在限制范围内，它们的乘积（ <code>=x * y * z</code> ）可能不在限制范围内，因为它有自己的限制。最后，每个维度最多只能有这些个工作组。  </p>
<blockquote>
<p><strong>Pro tip</strong>：不要生成最大数量的线程。尽管 GPU 是由操作系统和底层调度器管理的，但你可能会因为 <a target="_blank" rel="noopener" href="https://twitter.com/DasSurma/status/1495096911333842946">长时间运行的某个 GPU 程序而使整个系统停止响应</a>。  </p>
</blockquote>
<p>那么，什么是正确的工作组大小？这真的取决于你分配给工作项坐标的语义。我知道这并不是一个真正有用的答案，所以我想给你 <a target="_blank" rel="noopener" href="https://twitter.com/dakangz">Corentin</a> 给我的同样的建议。『使用 64（工作组大小），除非你知道客户端是什么 GPU 或者你的工作负载比较与众不同。』这似乎是一个安全的数字，在许多 GPU 上表现良好，并允许 GPU 调度器保持尽可能多的 EU 忙碌。  </p>
<h3 id="命令（Commands）"><a href="#命令（Commands）" class="headerlink" title="命令（Commands）"></a>命令（Commands）</h3><p>我们已经编写了着色器并建立了流水线。剩下要做的就是实际调用 GPU 来执行。由于 GPU 可以是一个完全独立的显卡，有自己的内存芯片，你可以通过所谓的命令缓冲区或命令队列来控制它。命令队列是一大块内存，其中包含供 GPU 执行的已编码的命令。编码方式与 GPU 高度相关，所以这将由驱动程序来处理。WebGPU 暴露了一个 <code>CommandEncoder</code> ，来使用该功能。  </p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> commandEncoder <span class="token operator">=</span> device<span class="token punctuation">.</span><span class="token function">createCommandEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> passEncoder <span class="token operator">=</span> commandEncoder<span class="token punctuation">.</span><span class="token function">beginComputePass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
passEncoder<span class="token punctuation">.</span><span class="token function">setPipeline</span><span class="token punctuation">(</span>pipeline<span class="token punctuation">)</span><span class="token punctuation">;</span>
passEncoder<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
passEncoder<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> commands <span class="token operator">=</span> commandEncoder<span class="token punctuation">.</span><span class="token function">finish</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
device<span class="token punctuation">.</span>queue<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">[</span>commands<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><code>commandEncoder</code> 有多个方法，允许你将数据从一个 GPU 缓冲区复制到另一个缓冲区和操作纹理。它还允许你创建 <code>PassEncoder</code> 对管道的设置和调用进行编码。在这个例子中，我们有一个计算管线，所以我们必须创建一个计算通道，将其设置为使用我们预先声明的管道，最后调用 <code>dispatch(w_x, w_y, w_z)</code> 来告诉 GPU 沿着每个维度创建多少个工作组。换句话说，我们的计算着色器被调用的次数等于 <code>wx * wy * wz * x * y * z</code> 。顺便说一下，PassEncoder 是 WebGPU 的抽象，用来避免我在这篇博文开始时讨论的内部全局状态对象。所有运行 GPU 流水线所需的数据和状态都明确地通过 PassEncoder 传递。  </p>
<blockquote>
<p><strong>抽象</strong>：命令缓冲区也是驱动程序或操作系统的钩子，让多个应用程序使用 GPU 而不互相干扰。当你的命令排队时，下面的抽象层会向队列中注入额外的命令，以保存前一个程序的状态并恢复你的程序的状态，这样就好像没有其它程序在使用 GPU。  </p>
</blockquote>
<p>运行这段代码，我们实际上是在 GPU 上生成了 64 个线程，它们<em>不做任何事情</em>。但它是有效的，所以这很酷。让我们来谈谈我们如何给 GPU 一些数据来工作。  </p>
<h2 id="交换数据"><a href="#交换数据" class="headerlink" title="交换数据"></a>交换数据</h2><p>正如我承诺的那样，我不会直接使用 WebGPU 进行图形处理，因此我认为在 GPU 上运行物理模拟并使用 Canvas2D 将其可视化会很有趣。也许我称其为『物理模拟』是自欺欺人——我所做的是生成一大堆圆圈，让它们在一个平面上以随机的方向移动，并让它们发生碰撞。  </p>
<p>为了使其发挥作用，我们需要将一些模拟参数和初始状态推送到 GPU 上，在 GPU 上运行模拟，并从 GPU 上读取模拟结果。这可以说是 WebGPU 最棘手的部分，因为有一堆数据杂技（不是说看似毫无意义的复制），但这是使 WebGPU 成为以最高性能运行的设备无关 API 的原因。  </p>
<h3 id="绑定组布局"><a href="#绑定组布局" class="headerlink" title="绑定组布局"></a>绑定组布局</h3><p>为了与 GPU 交换数据，我们需要用一个绑定组的布局来扩展我们的流水线定义。绑定组是 GPU 实体（内存缓冲区、纹理、采样器等）的集合，在流水线的执行过程中可以访问。绑定组布局预先定义了这些 GPU 实体的类型、目的和用途，这使得 GPU 能够提前弄清楚如何最有效地运行管线。在这个初始步骤中简单一些，让我们的流水线访问一个单一的内存缓冲区：  </p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> bindGroupLayout <span class="token operator">=</span>
    device<span class="token punctuation">.</span><span class="token function">createBindGroupLayout</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
        entries<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span>
            binding<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
            visibility<span class="token punctuation">:</span> GPUShaderStage<span class="token punctuation">.</span><span class="token constant">COMPUTE</span><span class="token punctuation">,</span>
            buffer<span class="token punctuation">:</span> <span class="token punctuation">&#123;</span>
                type<span class="token punctuation">:</span> <span class="token string">"storage"</span><span class="token punctuation">,</span>
            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> pipeline <span class="token operator">=</span> device<span class="token punctuation">.</span><span class="token function">createComputePipeline</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
    layout<span class="token punctuation">:</span> device<span class="token punctuation">.</span><span class="token function">createPipelineLayout</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
        bindGroupLayouts<span class="token punctuation">:</span> <span class="token punctuation">[</span>bindGroupLayout<span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    compute<span class="token punctuation">:</span> <span class="token punctuation">&#123;</span>
        module<span class="token punctuation">,</span>
        entryPoint<span class="token punctuation">:</span> <span class="token string">"main"</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><code>binding</code> 数字可以自由选择，用于将我们的 WGSL 代码中的变量与绑定组布局的这个槽中的缓冲区的内容联系起来。我们的 <code>bindGroupLayout</code> 还定义了每个缓冲区的用途，在这里是 <code>storage</code> 。另一个选项是 <code>read-only-storage</code> ，它是只读的（废话！），并允许 GPU 在永远不会被写入的基础上做进一步优化，例如不需要同步。缓冲区类型的最后一个可能的值是 <code>uniform</code> ，在计算管线的背景下，它在功能上主要等同于一个存储缓冲区。  </p>
<p>绑定组布局已经到位了。现在我们可以创建绑定组本身，包含绑定组布局所期望的 GPU 实体的实例。一旦绑定组和内部的缓冲区到位，计算着色器就可以将数据填入其中，我们就可以从 GPU 上读取数据。但是还有一个障碍：暂存缓冲区（Staging Buffers）。  </p>
<h3 id="暂存缓冲区（Staging-Buffers）"><a href="#暂存缓冲区（Staging-Buffers）" class="headerlink" title="暂存缓冲区（Staging Buffers）"></a>暂存缓冲区（Staging Buffers）</h3><p>我再说一遍：GPU 在很大程度上是以延迟为代价来优化吞吐量的。GPU 需要惊人的高速度将数据输送到核心，以维持该吞吐量。Fabian 在他 2011 年的博文系列中做了一些 <a target="_blank" rel="noopener" href="https://fgiesen.wordpress.com/2011/07/04/a-trip-through-the-graphics-pipeline-2011-part-4/#:~:text=that%E2%80%99s%203.3%20GB/s%20just%20for%20texture%20request%20payloads.%20Lower%20bound%2C">反推计算</a>，得出的结论是，1280x720 分辨率的着色器下，<em>仅纹理样本</em> GPU 就需要 3.3GB/s 的带宽。为了适应今天的图形需求，GPU 需要以更快的速度处理数据。只有当 GPU 的内存与核心非常紧密地结合在一起时，这才有可能实现。这种紧密的集成使其很难将相同的内存暴露给主机进行读写。  </p>
<p>不过，GPU 有主机和 GPU 都可以访问的额外内存区块，但集成不是很紧密，读写速度也不是很快。暂存缓冲区就是在这个中间内存区分配的缓冲区，它可以 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">映射</a> 到主机系统中进行读写。为了从 GPU 读取数据，我们将数据从内部的高性能缓冲区复制到一个暂存缓冲区，然后将暂存缓冲区映射到主机，这样我们就可以将数据读回主内存。对于写入，过程也是一样的，但顺序相反。  </p>
<p>回到我们的代码：我们将创建一个可写的缓冲区，并将其添加到绑定组，这样它就可以被计算着色器写入。我们还将创建第二个同样大小的缓冲区作为暂存缓冲区。每个缓冲区的创建都有一个 <code>usage</code> 位掩码，你可以用它声明你打算如何使用这个缓冲区。然后，GPU 会得出满足使用情况的缓冲区的位置，如果无法实现满足标志组合的位置，则会出现错误。  </p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> <span class="token constant">BUFFER_SIZE</span> <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> output <span class="token operator">=</span> device<span class="token punctuation">.</span><span class="token function">createBuffer</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
    size<span class="token punctuation">:</span> <span class="token constant">BUFFER_SIZE</span><span class="token punctuation">,</span>
    usage<span class="token punctuation">:</span> GPUBufferUsage<span class="token punctuation">.</span><span class="token constant">STORAGE</span> <span class="token operator">|</span> GPUBufferUsage<span class="token punctuation">.</span><span class="token constant">COPY_SRC</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> stagingBuffer <span class="token operator">=</span> device<span class="token punctuation">.</span><span class="token function">createBuffer</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
    size<span class="token punctuation">:</span> <span class="token constant">BUFFER_SIZE</span><span class="token punctuation">,</span>
    usage<span class="token punctuation">:</span> GPUBufferUsage<span class="token punctuation">.</span><span class="token constant">MAP_READ</span> <span class="token operator">|</span> GPUBufferUsage<span class="token punctuation">.</span><span class="token constant">COPY_DST</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> bindGroup <span class="token operator">=</span> device<span class="token punctuation">.</span><span class="token function">createBindGroup</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
    layout<span class="token punctuation">:</span> bindGroupLayout<span class="token punctuation">,</span>
    entries<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span>
        binding<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
        resource<span class="token punctuation">:</span> <span class="token punctuation">&#123;</span>
            buffer<span class="token punctuation">:</span> output<span class="token punctuation">,</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>注意 <code>createBuffer()</code> 返回一个 <code>GPUBuffer</code> , 不是 <code>ArrayBuffer</code> ，它们现在还不能读写。为此，需要将它们映射，这是另一个 API 调用，这个 API 只有在缓冲区有 <code>GPUBufferUsage.MAP_READ</code> 或 <code>GPUBufferUsage.MAP_WRITE</code> 时才会成功。  </p>
<blockquote>
<p><strong>TypeScript</strong>: 我发现 TypeScript 在探索新 API 时非常有帮助。幸运的是，Chrome 的 WebGPU 团队维护着 <a target="_blank" rel="noopener" href="https://npm.im/@webgpu/types">@webgpu/types</a> ，所以你可以享受准确的自动补全。  </p>
</blockquote>
<p>现在我们不仅有了绑定组的布局，甚至还有了实际的绑定组本身，我们需要更新我们的调度代码来利用这个绑定组。之后映射暂存缓冲区，将结果读回 JavaScript。  </p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> commandEncoder <span class="token operator">=</span> device<span class="token punctuation">.</span><span class="token function">createCommandEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> passEncoder <span class="token operator">=</span> commandEncoder<span class="token punctuation">.</span><span class="token function">beginComputePass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
passEncoder<span class="token punctuation">.</span><span class="token function">setPipeline</span><span class="token punctuation">(</span>pipeline<span class="token punctuation">)</span><span class="token punctuation">;</span>
passEncoder<span class="token punctuation">.</span><span class="token function">setBindGroup</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> bindGroup<span class="token punctuation">)</span><span class="token punctuation">;</span>
passEncoder<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
passEncoder<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">ceil</span><span class="token punctuation">(</span><span class="token constant">BUFFER_SIZE</span> <span class="token operator">/</span> <span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
passEncoder<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
commandEncoder<span class="token punctuation">.</span><span class="token function">copyBufferToBuffer</span><span class="token punctuation">(</span>
    output<span class="token punctuation">,</span>
    <span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment">// Source offset</span>
    stagingBuffer<span class="token punctuation">,</span>
    <span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment">// Destination offset</span>
    <span class="token constant">BUFFER_SIZE</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> commands <span class="token operator">=</span> commandEncoder<span class="token punctuation">.</span><span class="token function">finish</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
device<span class="token punctuation">.</span>queue<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">[</span>commands<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">await</span> stagingBuffer<span class="token punctuation">.</span><span class="token function">mapAsync</span><span class="token punctuation">(</span>
    GPUMapMode<span class="token punctuation">.</span><span class="token constant">READ</span><span class="token punctuation">,</span>
    <span class="token number">0</span><span class="token punctuation">,</span> <span class="token comment">// Offset</span>
    <span class="token constant">BUFFER_SIZE</span> <span class="token comment">// Length</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> copyArrayBuffer <span class="token operator">=</span>
    stagingBuffer<span class="token punctuation">.</span><span class="token function">getMappedRange</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">BUFFER_SIZE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> data <span class="token operator">=</span> copyArrayBuffer<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
stagingBuffer<span class="token punctuation">.</span><span class="token function">unmap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Float32Array</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>由于我们在管线中添加了一个绑定组的布局，现在没有提供绑定组的调用都会失败。在我们定义了『Pass』之后，我们通过命令编码器添加一个额外的命令，将数据从输出缓冲区复制到暂存缓冲区，并将命令缓冲区提交到队列中。GPU 将开始通过命令队列工作。我们不知道 GPU 到底什么时候会完成，但我们已经可以提交映射 <code>stagingBuffer</code> 的请求了。这个函数需要等待命令队列被完全处理，所以它是异步的。 <code>stagingBuffer.getMappedRange()</code> 让我们请求将一个区块（或整个缓冲区）作为一个 <code>ArrayBuffer</code> 暴露给 JavaScript。这是实际的、映射的 GPU 内存，这意味着当 <code>stagingBuffer</code> 被解除映射时，数据将消失（ <code>ArrayBuffer</code> 将被『分离』），所以我使用 <code>slice()</code> 来创建它在 JavaScript 的副本。  </p>
<p><img src="/images/1653570616308.png" alt="虽然不是很令人兴奋，但我们从 GPU 内存中复制了这些 0"></p>
<p>零以外的东西可能会更有说服力。在我们开始在 GPU 上进行任何高级计算之前，让我们把一些手工挑选的数据放入缓冲区，以证明我们的管道<em>确实</em>在按计划工作。这是我们新的计算着色器代码，为了清晰起见，增加了间距。  </p>
<pre class="language-wgsl" data-language="wgsl"><code class="language-wgsl">@group(0) @binding(1)
var&lt;storage, write&gt; output: array&lt;f32&gt;;

@stage(compute) @workgroup_size(64)
fn main(

  @builtin(global_invocation_id)
  global_id : vec3&lt;u32&gt;,

  @builtin(local_invocation_id)
  local_id : vec3&lt;u32&gt;,

) &#123;
  output[global_id.x] &#x3D;
    f32(global_id.x) * 1000. + f32(local_id.x);
&#125;</code></pre>
<p>前两行声明了一个模块范围的变量 <code>output</code> ，它是动态大小的 <code>f32</code> 数组。属性声明了数据的来源：来自我们第一个（0th）绑定组的缓冲区， <code>binding</code> 值为 1 的条目。数组的长度将自动反映底层缓冲区的长度（向下取整）。  </p>
<blockquote>
<p><strong>变量</strong>：WGSL 与 Rust 不同的是，用 <code>let</code> 声明的变量是不可变的。如果你想让一个变量是可变的，要使用关键字 <code>var</code> 。</p>
</blockquote>
<p><code>main()</code> 函数的签名中增加了两个参数： <code>global_id</code> 和 <code>local_id</code> 。我可以选择任何名字——它们的值由相关的属性决定： <code>global_invocation_id</code> 是一个内置值，对应该着色器调用在工作<em>负载</em>中的全局 <code>x/y/z</code> 坐标。 <code>local_invocation_id</code> 是这个着色器在工作组中的 <code>x/y/z</code> 坐标。  </p>
<p><img src="/images/1653570634052.png" alt="工作负载中标记的三个工作项 a、b 和 c 的示例"></p>
<p>这张图片展示了 <code>@workgroup_size(4, 4, 4)</code> 工作负载坐标系统的一种可能情况。这取决于你为实际使用情况定义什么坐标系。如果我们接受上图中的坐标轴，则 <code>main()</code> 中的 a、b、c 参数如下：  </p>
<ul>
<li>a:<ul>
<li><code>local_id=(x=0, y=0, z=0)</code></li>
<li><code>global_id=(x=0, y=0, z=0)</code></li>
</ul>
</li>
<li>b:<ul>
<li><code>local_id=(x=0, y=0, z=0)</code></li>
<li><code>global_id=(x=4, y=0, z=0)</code></li>
</ul>
</li>
<li>c:<ul>
<li><code>local_id=(x=1, y=1, z=0)</code></li>
<li><code>global_id=(x=5, y=5, z=0)</code><br>在着色器中，我们有 <code>@workgroup_size(64, 1, 1)</code> ，所以 <code>local_id.x</code> 会在 0~63 之间。为了能够检查这两个值，我将它们『编码』成一个数字。请注意，WGSL 是严格类型的： <code>local_id</code> 和 <code>global_id</code> 都是 <code>vec3&lt;u32&gt;</code> ，所以我们必须明确地将它们转换成 <code>f32</code> ，以便分配给 <code>f32</code> 的输出缓冲区。  </li>
</ul>
</li>
</ul>
<p><img src="/images/1653570665130.png" alt="由 GPU 实际填充的值。注意本地调用的 ID 在 63 后重置，而全局调用的 ID 则继续计数"></p>
<p>这证明了我们的计算着色器确实是为输出内存中的每一个值调用的，并为其填充了一个唯一的值。我们不会知道这些数据是以何种顺序填入的，这是故意未指定的，并留给 GPU 的调度器决定。  </p>
<h3 id="过度调用（Overdispatching）"><a href="#过度调用（Overdispatching）" class="headerlink" title="过度调用（Overdispatching）"></a>过度调用（Overdispatching）</h3><p>聪明的读者可能已经注意到，着色器调用的总数（ <code>Math.ceil(BUFFER_SIZE / 64) * 64</code> ）将导致 <code>global_id.x</code> 大于数组的长度，因为每个 <code>f32</code> 占用 4 字节。幸运的是，对数组的访问有一个隐式的保护，所以每一次写过数组的末端都会写入数组的最后一个元素。这就避免了内存访问错误，但仍可能产生无法使用的数据。事实上，如果你检查返回的缓冲区的最后 3 个元素，你会发现数字 247055、248056 和 608032。这就需要我们在着色器代码中提前退出来防止这种情况发生：  </p>
<pre class="language-js" data-language="js"><code class="language-js">fn <span class="token function">main</span><span class="token punctuation">(</span> <span class="token comment">/* ... */</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>global_id<span class="token punctuation">.</span>x <span class="token operator">>=</span> <span class="token function">arrayLength</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span> output<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    output<span class="token punctuation">[</span>global_id<span class="token punctuation">.</span>x<span class="token punctuation">]</span> <span class="token operator">=</span>
        <span class="token function">f32</span><span class="token punctuation">(</span>global_id<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100.</span> <span class="token operator">+</span> <span class="token function">f32</span><span class="token punctuation">(</span>local_id<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>你可以运行这个 <a target="_blank" rel="noopener" href="https://surma.dev/things/webgpu/step1/index.html">demo</a> 来查看完整的源代码。  </p>
<h3 id="一个疯狂的结构体"><a href="#一个疯狂的结构体" class="headerlink" title="一个疯狂的结构体"></a>一个疯狂的结构体</h3><p>现在我们的目标是让一大堆球在二维空间中移动，并进行快乐的小碰撞。为此，每个球需要有一个半径、一个位置和一个速度向量。我们可以继续使用 <code>array&lt;f32&gt;</code> ，并确定第一个浮点数是第一个球的 x 位置，第二个浮点数是第一个球的 y 位置，以此类推。这并不是我所说的符合人体工程学的做法。幸运的是，WGSL 允许我们自定义结构体，可以将多条数据放在一个整洁的袋子里。  </p>
<blockquote>
<p><strong>冷知识</strong>：如果你知道什么是内存对齐，你可以跳过这一节（尽管要看一下代码示例）。如果你不知道这是什么，我不会解释原因，但会告诉你这将导致什么，以及如何解决它。  </p>
</blockquote>
<p>所以，使用这些组件定义一个 <code>struct Ball</code> ，将 <code>array&lt;f32&gt;</code> 变成 <code>array&lt;Ball&gt;</code> 是有意义的。但这一切的坏处是：我们必须谈谈 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Data_structure_alignment">对齐问题</a>。  </p>
<pre class="language-js" data-language="js"><code class="language-js">struct Ball <span class="token punctuation">&#123;</span>
    radius<span class="token punctuation">:</span> f32<span class="token punctuation">;</span>
    position<span class="token punctuation">:</span> vec2 <span class="token operator">&lt;</span> f32 <span class="token operator">></span> <span class="token punctuation">;</span>
    velocity<span class="token punctuation">:</span> vec2 <span class="token operator">&lt;</span> f32 <span class="token operator">></span> <span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

@<span class="token function">group</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> @<span class="token function">binding</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> <span class="token operator">&lt;</span> storage<span class="token punctuation">,</span> write <span class="token operator">></span> output<span class="token punctuation">:</span> array <span class="token operator">&lt;</span> f32 <span class="token operator">></span> <span class="token punctuation">;</span>
<span class="token keyword">var</span> <span class="token operator">&lt;</span> storage<span class="token punctuation">,</span> write <span class="token operator">></span> output<span class="token punctuation">:</span> array <span class="token operator">&lt;</span> Ball <span class="token operator">></span> <span class="token punctuation">;</span>

@<span class="token function">stage</span><span class="token punctuation">(</span>compute<span class="token punctuation">)</span> @<span class="token function">workgroup_size</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span>
fn <span class="token function">main</span><span class="token punctuation">(</span>
    <span class="token parameter">@<span class="token function">builtin</span><span class="token punctuation">(</span>global_invocation_id<span class="token punctuation">)</span> global_id<span class="token punctuation">:</span> vec3 <span class="token operator">&lt;</span> u32 <span class="token operator">></span> <span class="token punctuation">,</span>
    @<span class="token function">builtin</span><span class="token punctuation">(</span>local_invocation_id<span class="token punctuation">)</span> local_id<span class="token punctuation">:</span> vec3 <span class="token operator">&lt;</span> u32 <span class="token operator">></span> <span class="token punctuation">,</span></span>
<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> num_balls <span class="token operator">=</span> <span class="token function">arrayLength</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span> output<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>global_id<span class="token punctuation">.</span>x <span class="token operator">>=</span> num_balls<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    output<span class="token punctuation">[</span>global_id<span class="token punctuation">.</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>radius <span class="token operator">=</span> <span class="token number">999.</span><span class="token punctuation">;</span>
    output<span class="token punctuation">[</span>global_id<span class="token punctuation">.</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>position <span class="token operator">=</span> vec2 <span class="token operator">&lt;</span> f32 <span class="token operator">></span> <span class="token punctuation">(</span>global_id<span class="token punctuation">.</span>xy<span class="token punctuation">)</span><span class="token punctuation">;</span>
    output<span class="token punctuation">[</span>global_id<span class="token punctuation">.</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span>velocity <span class="token operator">=</span> vec2 <span class="token operator">&lt;</span> f32 <span class="token operator">></span> <span class="token punctuation">(</span>local_id<span class="token punctuation">.</span>xy<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<p>如果你运行这个 demo，你会在控制台看见这个：  </p>
<p><img src="/images/1653570680829.png" alt="由于对齐限制，该结构体的内存布局中有一个洞（padding）"></p>
<p>我把 <code>999</code> 作为结构体的第一个字段，以方便查看结构体在缓冲区中的起始位置。在下一个 999 之前总共有 6 个数字，这有点令人惊讶，因为该结构体实际上只存储 5 个数字： <code>radius</code> 、 <code>position.x</code> 、 <code>position.y</code> 、 <code>velocity.x</code> 和 <code>velocity.y</code> 。这是因为对齐的问题。  </p>
<p>每个 WGSL 数据类型都有明确的 <a target="_blank" rel="noopener" href="https://gpuweb.github.io/gpuweb/wgsl/#alignment-and-size">对齐要求</a>。如果一个数据类型的对齐方式为* N<em>，这意味着该数据类型的值只能存储在</em> N *的倍数的内存地址上。 <code>f32</code> 的对齐是 4, 而 <code>vec2&lt;f32&gt;</code> 的对齐是 8。如果我们假设结构体从地址 0 开始，那么 <code>radius</code> 可以存储在地址 0，因为 0 是 4 的倍数。结构体的下一个字段是 <code>vec2&lt;f32&gt;</code> ，它的对齐是 8。 然而， <code>radius</code> 之后的第一个空闲地址是 4，这不是 8 的倍数。 为了解决这个问题，编译器添加了 4 个字节的 padding，来让下一个地址是 8 的倍数。 这解释了为什么我们在 DevTools 控制台看到了一个值为 0 的未使用字段。  </p>
<p><img src="/images/1653570724299.png" alt="WGSL 规范中的（缩短的）[对齐表](https://gpuweb.github.io/gpuweb/wgsl/#alignment-and-size)"></p>
<p>现在我们知道了结构体在内存中是如何布局的，我们可以从 JavaScript 中填充它，以生成球的初始状态，也可以读回并使其可视化。  </p>
<h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h3><p>我们已经成功地从 GPU 中读取数据，将其带到 JavaScript 中并『解码』。现在是时候解决另一个问题了。我们需要在 JavaScript 中生成所有球的初始状态，并将其交给 GPU，以便能够在上面运行计算着色器。生成初始状态相当简单：  </p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> inputBalls <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Float32Array</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayBuffer</span><span class="token punctuation">(</span><span class="token constant">BUFFER_SIZE</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token constant">NUM_BALLS</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    inputBalls<span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token number">6</span> <span class="token operator">+</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">randomBetween</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// radius</span>
    inputBalls<span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token number">6</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// padding</span>
    inputBalls<span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token number">6</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">randomBetween</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> ctx<span class="token punctuation">.</span>canvas<span class="token punctuation">.</span>width<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// position.x</span>
    inputBalls<span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token number">6</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">randomBetween</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> ctx<span class="token punctuation">.</span>canvas<span class="token punctuation">.</span>height<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// position.y</span>
    inputBalls<span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token number">6</span> <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">randomBetween</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// velocity.x</span>
    inputBalls<span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token number">6</span> <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">randomBetween</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// velocity.y</span>
<span class="token punctuation">&#125;</span></code></pre>
<blockquote>
<p><strong>Buffer-backed-object</strong>：对于更复杂的数据结构，在 JavaScript 中操作数据可能会变得相当乏味。虽然最初是为 Web Workers 写的，但我的库 <a target="_blank" rel="noopener" href="https://github.com/GoogleChromeLabs/buffer-backed-object">buffer-backed-object</a> 在这里也能派上用场。  </p>
</blockquote>
<p>我们已经知道如何将缓冲区暴露给我们的着色器。我们只需要调整流水线绑定组的布局来加入另一个缓冲区：  </p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> bindGroupLayout <span class="token operator">=</span> device<span class="token punctuation">.</span><span class="token function">createBindGroupLayout</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
    entries<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span>
            binding<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
            visibility<span class="token punctuation">:</span> GPUShaderStage<span class="token punctuation">.</span><span class="token constant">COMPUTE</span><span class="token punctuation">,</span>
            buffer<span class="token punctuation">:</span> <span class="token punctuation">&#123;</span>
                type<span class="token punctuation">:</span> <span class="token string">"read-only-storage"</span><span class="token punctuation">,</span>
            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        <span class="token punctuation">&#123;</span>
            binding<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
            visibility<span class="token punctuation">:</span> GPUShaderStage<span class="token punctuation">.</span><span class="token constant">COMPUTE</span><span class="token punctuation">,</span>
            buffer<span class="token punctuation">:</span> <span class="token punctuation">&#123;</span>
                type<span class="token punctuation">:</span> <span class="token string">"storage"</span><span class="token punctuation">,</span>
            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>… 然后创建一个让我们可以绑定的绑定组的 GPU 缓冲区：  </p>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> input <span class="token operator">=</span> device<span class="token punctuation">.</span><span class="token function">createBuffer</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
    size<span class="token punctuation">:</span> <span class="token constant">BUFFER_SIZE</span><span class="token punctuation">,</span>
    usage<span class="token punctuation">:</span> GPUBufferUsage<span class="token punctuation">.</span><span class="token constant">STORAGE</span> <span class="token operator">|</span> GPUBufferUsage<span class="token punctuation">.</span><span class="token constant">COPY_DST</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> bindGroup <span class="token operator">=</span> device<span class="token punctuation">.</span><span class="token function">createBindGroup</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>
    layout<span class="token punctuation">:</span> bindGroupLayout<span class="token punctuation">,</span>
    entries<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">&#123;</span>
            binding<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
            resource<span class="token punctuation">:</span> <span class="token punctuation">&#123;</span>
                buffer<span class="token punctuation">:</span> input<span class="token punctuation">,</span>
            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        <span class="token punctuation">&#123;</span>
            binding<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
            resource<span class="token punctuation">:</span> <span class="token punctuation">&#123;</span>
                buffer<span class="token punctuation">:</span> output<span class="token punctuation">,</span>
            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>新的部分：发送数据到 GPU。就像读取数据一样，从技术上讲我们必须创建一个可以映射的暂存缓冲区，将数据复制到暂存缓冲区，然后发出命令将数据从暂存缓冲区复制到存储缓冲区。然而，WebGPU 提供了一个便利的功能，让我们高效的将数据送入存储缓冲区，尽管这实时创建了一个临时的暂存缓冲区：  </p>
<pre class="language-js" data-language="js"><code class="language-js">device<span class="token punctuation">.</span>queue<span class="token punctuation">.</span><span class="token function">writeBuffer</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> inputBalls<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>就这样？就这样！我们甚至不需要命令编码器。我们可以将这个命令直接加入命令队列。 <code>device.queue</code> 也为纹理提供了一些其他类似的便利功能。<br>现在我们需要把这个新的缓冲区绑定到 WGSL 的一个变量上，并对它做一些处理：  </p>
<pre class="language-wgsl" data-language="wgsl"><code class="language-wgsl">struct Ball &#123;
  radius: f32;
  position: vec2&lt;f32&gt;;
  velocity: vec2&lt;f32&gt;;
&#125;

@group(0) @binding(0)
var&lt;storage, read&gt; input: array&lt;Ball&gt;;

@group(0) @binding(1)
var&lt;storage, write&gt; output: array&lt;Ball&gt;;

let TIME_STEP: f32 &#x3D; 0.016;

@stage(compute) @workgroup_size(64)
fn main(
  @builtin(global_invocation_id)
  global_id : vec3&lt;u32&gt;,
) &#123;
  let num_balls &#x3D; arrayLength(&amp;output);
  if(global_id.x &gt;&#x3D; num_balls) &#123;
    return;
  &#125;
  output[global_id.x].position &#x3D;
    input[global_id.x].position +
    input[global_id.x].velocity * TIME_STEP;
&#125;</code></pre>
<p>我希望现在这个着色器的绝大部分代码没有让你惊讶。  </p>
<p><video autoplay loop><source src="/media/webgpu1.webm" type="video/webm"><br></video></p>
<p><img src="" alt="每一帧都被 WebGPU 用来更新球的位置，并使用 Canvas2D 将它们绘制到屏幕上"></p>
<p>最后，我们需要做的是将 <code>output</code> 缓冲区读回 JavaScript，编写一些 Canvas2D 代码来可视化缓冲区的内容，并将其全部放入 <code>requestAnimationFrame()</code> 循环。你可以在这个 <a target="_blank" rel="noopener" href="https://surma.dev/things/webgpu/step3/index.html">demo</a> 中看到效果。  </p>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>前面的 demo 只是沿着每个球的速度向量移动，并不惊艳或具有很复杂的计算。在看这个作品的性能特性之前，让我在着色器中加入一些适当的物理计算。我不会在这里解释——这篇博文已经够长了——但我想说我采取了最朴素的方法：每个球都检查与<em>其他所有球</em>的碰撞情况。如果你感到好奇，你可以看一下 <a target="_blank" rel="noopener" href="https://surma.dev/things/webgpu/step4/index.html">最终 demo</a> 的源代码，其中还包含我用来编写物理部分的资源链接。  </p>
<p><video autoplay loop><source src="/media/webgpu2.webm" type="video/webm"><br></video></p>
<p><img src="" alt="... 现在有了弹性墙和弹性球！"></p>
<p>我不想对这个实验进行精确的测量，因为我还没有优化物理算法和 WebGPU 的使用。然而，即使是这种朴素的实现也表现得非常好（在我的 M1 MacBook Air 上），这一点让我印象深刻。维持 60fps 时，大约可以处理 2500 个球。但看一下跟踪，在有 2500 个球时，很明显瓶颈是 Canvas2D 绘制场景，而不是 WebGPU 的计算。  </p>
<p><img src="/images/1653570917206.png" alt="有 14000 个球时，在 M1 MBA 上 GPU 的纯计算时间大约 16ms"></p>
<p>为了看看到底多快，我禁用了渲染，使用 <code>performance.measure()</code> 来看看在耗尽每帧 16ms 的时间之前我可以模拟多少个球。在我的机器上，这是 14000 个球左右。这种未经优化的东西运行得如此之快，真让我醉心于 WebGPU 给我提供的强大计算能力。  </p>
<h2 id="稳定性和可用性"><a href="#稳定性和可用性" class="headerlink" title="稳定性和可用性"></a>稳定性和可用性</h2><p>WebGPU 标准的制定已经有了一段时间，我认为标准小组尽快宣布该 API 是稳定的。也就是说，这个 API 只在 Chrome 和 Firefox 加入相应的 flag 后才可用。我对 Safari 支持这个 API 持乐观态度，但在写这篇文章的时候，还没有在 Safari TP 中看到。  </p>
<p>在稳定性方面，甚至在我为这篇文章做研究的时候就有一些变化落地了。例如，属性的语法从 <code>[[stage(compute), workgroup_size(64)]]</code> 改为了 <code>@stage(compute) @workgroup_size(64)</code> 。在写这篇文章的时候，Firefox 还在使用旧的语法。 <code>passEncoder.end()</code> 曾经是 <code>passEncoder.endPass()</code> 。规范中还有一些东西还没有在任何浏览器中实现，比如 <a target="_blank" rel="noopener" href="https://gpuweb.github.io/gpuweb/#dom-gpuprogrammablestage-constants">着色器常量</a> 或在移动设备上使用 API。  </p>
<p>我要说的基本上是：当浏览器和标准制定者在这个 API 走向✨稳定✨的过程中，预计还会有更多的重大变化。  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 Web 上拥有一个现代的 API 来与 GPU 交互将是非常有趣的。在投入时间克服最初的学习曲线后，我真的感到有能力在 GPU 上使用 JavaScript 运行大规模的并行工作负载。还有 <a target="_blank" rel="noopener" href="https://github.com/gfx-rs/wgpu">wgpu</a>，它在 Rust 中实现了 WebGPU 的 API，允许你在浏览器外使用 API。wgpu 也支持 WebAssembly 作为编译目标，所以你可以在原生在浏览器外或通过 WebAssembl 在浏览器内运行 WebGPU 程序。有趣的是：<a target="_blank" rel="noopener" href="https://deno.land/">Deno</a> 是第一个支持 WebGPU 的运行时（多亏了 wgpu）。  </p>
<p>如果你有问题或遇到问题，这里有一个 <a target="_blank" rel="noopener" href="https://matrix.to/#/#WebGPU:matrix.org">Matrix channel</a>，里面有许多 WebGPU 的用户、浏览器工程师和标准人员，他们对我有很大的帮助。尝试一下吧，这非常令人激动。  </p>
<p><em>感谢 <a target="_blank" rel="noopener" href="https://twitter.com/tojiro">Brandon Jones</a> 对本文的校对，感谢 <a target="_blank" rel="noopener" href="https://matrix.to/#/#WebGPU:matrix.org">WebGPU Matrix channel</a> 对我所有问题的回答。</em>  </p>

            </div>
            <hr/>

            

            

            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-circle"></i>
            <span>转载规则</span>
        </p>
        
            <div class="reprintDetail">
                <div>
                <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" property="dct:title"
                      rel="dct:type">《译：WebGPU — All of the cores, none of the canvas》</span> 由
                    <a xmlns:cc="http://creativecommons.org/ns#" href="/2022/05/26/webGPU/" property="cc:attributionName"
                       rel="cc:attributionURL">Konata</a>
                    采用
                    <a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/deed.zh">
                        知识共享署名-非商业性使用 4.0 国际许可协议
                    </a>
                    进行许可。
                </div>
                <div class="reprintImg">
                    <a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by-nc/4.0/deed.zh">
                        <svg xmlns="http://www.w3.org/2000/svg" width="120" height="42">
                            <g transform="matrix(.993781 0 0 .993693 -177.69414 -148.87729)">
                                <path d="M182.235 150.264l114.064.203c1.594 0 3.018-.236 3.018 3.18l-.14 37.567h-119.82v-37.706c0-1.685.163-3.244 2.878-3.244z"
                                      fill="#aab2ab"/>
                                <path d="M213.544 169.484c.005 7.577-6.135 13.724-13.712 13.729s-13.724-6.135-13.729-13.712c-.004-7.594 6.135-13.741 13.712-13.745s13.724 6.135 13.729 13.712z"
                                      fill="#fff"/>
                                <path d="M210.977 158.309c3.042 3.042 4.564 6.768 4.564 11.175s-1.495 8.094-4.485 11.058c-3.173 3.122-6.924 4.682-11.251 4.682-4.275 0-7.961-1.547-11.056-4.644s-4.643-6.794-4.643-11.097 1.547-8.027 4.643-11.175c3.016-3.044 6.702-4.565 11.056-4.565 4.407 0 8.13 1.521 11.173 4.565zm-20.18 2.046c-2.572 2.598-3.858 5.642-3.858 9.133s1.273 6.508 3.818 9.053 5.577 3.818 9.093 3.818 6.573-1.285 9.171-3.857c2.467-2.388 3.701-5.392 3.701-9.014 0-3.595-1.254-6.646-3.76-9.152s-5.543-3.759-9.112-3.759-6.587 1.26-9.054 3.778zm6.769 7.598c-.393-.857-.981-1.286-1.766-1.286-1.387 0-2.081.934-2.081 2.801s.693 2.801 2.081 2.801c.916 0 1.57-.455 1.963-1.366l1.923 1.024c-.917 1.628-2.291 2.443-4.125 2.443-1.414 0-2.547-.434-3.397-1.3s-1.277-2.063-1.277-3.586c0-1.497.438-2.686 1.316-3.566s1.97-1.32 3.28-1.32c1.938 0 3.326.763 4.165 2.289l-2.081 1.066zm9.046 0c-.394-.857-.97-1.286-1.73-1.286-1.415 0-2.123.934-2.123 2.801s.708 2.801 2.123 2.801c.917 0 1.56-.455 1.927-1.366l1.966 1.024c-.915 1.628-2.288 2.443-4.118 2.443-1.412 0-2.543-.434-3.393-1.3s-1.274-2.063-1.274-3.586c0-1.497.432-2.686 1.294-3.566s1.96-1.32 3.294-1.32c1.935 0 3.32.763 4.156 2.289l-2.122 1.066zm90.684-18.131H181.067c-1.247 0-2.261 1.014-2.261 2.26v39.496a.51.51 0 0 0 .511.51h119.729a.51.51 0 0 0 .511-.51v-39.496c0-1.247-1.014-2.26-2.261-2.26zm-116.229 1.02h116.229a1.24 1.24 0 0 1 1.239 1.24v27.381h-83.074c-3.045 5.506-8.911 9.244-15.644 9.244s-12.6-3.735-15.644-9.244h-4.347v-27.381a1.24 1.24 0 0 1 1.24-1.24z"/>
                                <path d="M239.178 182.777a4.16 4.16 0 0 1 .869.084 1.88 1.88 0 0 1 .674.275 1.28 1.28 0 0 1 .435.508c.103.212.154.473.154.784 0 .336-.076.615-.229.839s-.379.407-.678.551c.412.118.72.325.923.621s.305.652.305 1.069c0 .336-.065.627-.196.873a1.71 1.71 0 0 1-.528.602c-.222.156-.475.271-.758.346a3.4 3.4 0 0 1-.875.112h-3.236v-6.664h3.142zm-.187 2.695c.261 0 .477-.062.645-.187s.252-.325.252-.604c0-.155-.028-.283-.084-.382a.63.63 0 0 0-.225-.233c-.093-.056-.201-.095-.322-.116a2.17 2.17 0 0 0-.378-.032h-1.374v1.555h1.486zm.085 2.828a1.97 1.97 0 0 0 .412-.042 1.04 1.04 0 0 0 .346-.14.71.71 0 0 0 .238-.267c.06-.111.089-.255.089-.429 0-.342-.097-.586-.29-.732s-.449-.219-.767-.219h-1.6v1.828h1.571zm2.813-5.523h1.644l1.561 2.632 1.551-2.632h1.634l-2.474 4.106v2.558h-1.469v-2.595l-2.446-4.069zm23.892 0l2.784 4.471h.016v-4.471h1.375v6.664h-1.466l-2.773-4.462h-.019v4.462h-1.375v-6.664h1.458zm9.738 1.776c-.087-.141-.196-.264-.327-.369a1.5 1.5 0 0 0-.443-.247c-.165-.06-.338-.089-.518-.089-.33 0-.61.063-.841.191a1.57 1.57 0 0 0-.56.513 2.23 2.23 0 0 0-.313.732 3.66 3.66 0 0 0-.098.849 3.38 3.38 0 0 0 .098.816c.065.265.17.503.313.714s.329.381.56.509.511.191.841.191c.447 0 .798-.137 1.05-.411s.406-.635.462-1.083h1.419a3.39 3.39 0 0 1-.289 1.13 2.71 2.71 0 0 1-.616.86c-.255.237-.554.418-.896.543a3.27 3.27 0 0 1-1.129.188c-.511 0-.97-.089-1.378-.267a2.96 2.96 0 0 1-1.032-.732c-.281-.312-.496-.678-.646-1.098a4.03 4.03 0 0 1-.225-1.359c0-.498.075-.96.225-1.387s.364-.799.646-1.116.625-.566 1.032-.747.867-.271 1.378-.271c.367 0 .714.053 1.041.159a2.8 2.8 0 0 1 .877.463 2.49 2.49 0 0 1 .64.752c.168.299.273.642.317 1.027h-1.419a1.19 1.19 0 0 0-.168-.462zm5.642-19.655c.004 5.536-4.479 10.025-10.016 10.03s-10.025-4.48-10.029-10.015c-.004-5.551 4.479-10.041 10.015-10.045s10.026 4.48 10.03 10.015z"
                                      fill="#fff"/>
                                <path d="M271.124 153.229c3.271 0 6.036 1.128 8.295 3.383s3.389 5.019 3.389 8.286-1.11 5.999-3.33 8.198c-2.356 2.314-5.141 3.471-8.354 3.471-3.175 0-5.91-1.147-8.208-3.442s-3.446-5.037-3.446-8.226 1.148-5.952 3.446-8.286c2.239-2.255 4.976-3.383 8.208-3.383zm-9.029 8.534a9.35 9.35 0 0 0-.521 3.135c0 2.586.943 4.822 2.832 6.709s4.138 2.83 6.748 2.83 4.877-.953 6.805-2.859c.646-.623 1.178-1.304 1.595-2.041l-4.399-1.958c-.298 1.48-1.616 2.479-3.211 2.597v1.799h-1.34v-1.799c-1.31-.015-2.575-.55-3.542-1.397l1.606-1.621c.774.728 1.549 1.056 2.605 1.056.685 0 1.443-.268 1.443-1.16a.87.87 0 0 0-.315-.701l-1.112-.496-9.193-4.093zm9.059-6.434c-2.648 0-4.888.933-6.718 2.801-.499.503-.932 1.028-1.301 1.576l4.462 1.986c.402-1.238 1.578-1.989 3.006-2.072v-1.799h1.34v1.799c.923.044 1.935.297 2.932 1.07l-1.533 1.576c-.565-.401-1.279-.684-1.994-.684-.58 0-1.398.178-1.398.906 0 .112.036.21.105.296l10.354 4.61c.198-.783.297-1.616.297-2.498 0-2.666-.935-4.92-2.804-6.768-1.851-1.868-4.1-2.801-6.747-2.801z"/>
                                <circle cx="242.562" cy="165.136" r="10.806" fill="#fff"/>
                                <path d="M245.69 162.009c0-.416-.338-.754-.754-.754h-4.772c-.416 0-.754.337-.754.754v4.773h1.331v5.652h3.617v-5.652h1.332v-4.773z"/>
                                <circle cx="242.55" cy="158.995" r="1.632"/>
                                <path d="M242.535 153.229c-3.231 0-5.968 1.127-8.208 3.384-2.298 2.333-3.446 5.096-3.446 8.285s1.148 5.932 3.446 8.227 5.034 3.442 8.208 3.442c3.213 0 5.998-1.156 8.354-3.471 2.221-2.197 3.33-4.93 3.33-8.197s-1.129-6.029-3.388-8.285-5.024-3.384-8.296-3.384zm.029 2.1c2.648 0 4.897.934 6.747 2.801 1.87 1.848 2.805 4.104 2.805 6.768 0 2.684-.915 4.911-2.746 6.68-1.928 1.906-4.196 2.859-6.806 2.859s-4.858-.943-6.747-2.83-2.833-4.123-2.833-6.709.954-4.843 2.862-6.768c1.831-1.867 4.07-2.801 6.718-2.801z"
                                      fill-rule="evenodd"/>
                            </g>
                        </svg>
                    </a>
                </div>
            </div>
        
    </div>
    


        </div>
    </div>

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
            <div class="article col s12 m6">
                <div class="article-badge left-badge text-color">
                    <i class="fa fa-dot-circle-o"></i>&nbsp;本篇
                </div>
                <div class="card">
                    <a href="/2022/05/26/webGPU/">
                        <div class="card-image">
                            
                                
                                <div class="lazy-image-wrapper">
                                    <img data-src="/medias/featureimages/05.jpg" class="responsive-img lazyload"
                                         alt="译：WebGPU — All of the cores, none of the canvas">
                                </div>
                            
                            <span class="card-title">译：WebGPU — All of the cores, none of the canvas</span>
                        </div>
                    </a>
                    <div class="card-content article-content">
                        <div class="summary block-with-text">
                            
                            <center>
                                译：WebGPU — All of the cores, none of the canvas
                                
                            </center>
                        </div>
                        <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2022-05-26
                            </span>
                            <span class="publish-author">
                                
                                    <i class="fa fa-bookmark fa-fw icon-category"></i>
                                    
                                        <a href="/categories/Browser/" class="post-category" target="_blank">
                                    Browser
                                </a>
                                    
                                
                            </span>
                        </div>
                    </div>

                    
                        <div class="card-action article-tags">
                            
                                <a href="/tags/JavaScript/" target="_blank">
                                    <span class="chip bg-color">JavaScript</span>
                                </a>
                            
                                <a href="/tags/WebGPU/" target="_blank">
                                    <span class="chip bg-color">WebGPU</span>
                                </a>
                            
                                <a href="/tags/WGSL/" target="_blank">
                                    <span class="chip bg-color">WGSL</span>
                                </a>
                            
                        </div>
                    
                </div>
            </div>
        
        
            <div class="article col s12 m6">
                <div class="article-badge right-badge text-color">
                    下一篇&nbsp;<i class="fa fa-chevron-right"></i>
                </div>
                <div class="card">
                    <a href="/2021/11/13/disableMitigations/">
                        <div class="card-image">
                            
                                
                                <div class="lazy-image-wrapper">
                                    <img data-src="/medias/featureimages/04.jpg" class="responsive-img lazyload"
                                         alt="关闭 Spectre 和 Meltdown 漏洞补丁来提升系统性能">
                                </div>
                            
                            <span class="card-title">关闭 Spectre 和 Meltdown 漏洞补丁来提升系统性能</span>
                        </div>
                    </a>
                    <div class="card-content article-content">
                        <div class="summary block-with-text">
                            
                            <center>
                                关闭 Spectre 和 Meltdown 漏洞补丁来提升系统性能
                                
                            </center>
                        </div>
                        <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2021-11-13
                            </span>
                            <span class="publish-author">
                                
                                    <i class="fa fa-bookmark fa-fw icon-category"></i>
                                    
                                        <a href="/categories/Ops/" class="post-category" target="_blank">
                                    Ops
                                </a>
                                    
                                
                            </span>
                        </div>
                    </div>
                    
                </div>
            </div>
        
    </div>
</article>
</div>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-ul"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

    <div id="floating-toc-btn">
        <a class="btn-floating btn-large bg-color">
            <i class="fa fa-list-ul"></i>
        </a>
    </div>
    <script>
        document.getElementById('floating-toc-btn').style.display = 'block';
    </script>


<script src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js"></script>
<script>
    document.addEventListener("DOMContentLoaded", () => {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -(window.innerHeight * 0.4 - 45),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        const tocWidget = document.querySelector('.toc-widget');

        const tocFixed = () =>{
            const tocHeight = document.querySelector('.bg-cover.pd-header.post-cover').scrollHeight - 64; // title image height - TOC top
            const scroll = window.scrollY;
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                tocWidget.classList.add('toc-fixed');
            } else {
                tocWidget.classList.remove('toc-fixed');
            }
        }
        tocFixed();
        window.addEventListener("scroll", () => tocFixed());
        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = document.getElementById(srcId);
            if (!srcDiv) {
                return;
            }
            let w = srcDiv.style.width;
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            document.getElementById(targetId).style.width = w;
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let tocAside = document.getElementById('toc-aside');
        let mainContent = document.getElementById('main-content');
        document.querySelectorAll('#floating-toc-btn .btn-floating')[0].addEventListener('click', () => {
            if (tocAside.classList.contains(expandedClass)) {
                tocAside.classList.remove(expandedClass);
                tocAside.hidden = true;
                mainContent.classList.remove('l9');
            } else {
                tocAside.hidden = false;
                tocAside.classList.add(expandedClass);
                mainContent.classList.add('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        })
        
    });
</script>
    

</main>


<footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right" style="width: -moz-available;width: -webkit-fill-available">
            &copy;2019-2021 Konata<br>Proudly published with Hexo<br>Theme - <a target="_blank" rel="noopener" href="https://github.com/blinkfox/hexo-theme-matery">matery</a>
            
            
            
                <br>
                
                    <span id="busuanzi_container_site_pv">
                    <i class="fa fa-heart"></i>
                    本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
                </span>
                
                
                    <span id="busuanzi_container_site_uv">
                    次&nbsp;&nbsp;<i class="fa fa-user-friends"></i> 访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
                </span>
                
            
        </div>
        <!--        <div class="col s12 m4 l4 social-link social-statis">


    <a href="mailto:konata#aliyun.com" class="tooltipped" target="_blank" data-tooltip="E-mail" data-position="top" data-delay="50">
        <i class="fa fa-hover fa-envelope"></i>
    </a>





    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS" data-position="top" data-delay="50">
        <i class="fa fa-hover fa-rss"></i>
    </a>
</div>-->
    </div>

</footer>

<!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>
<!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll-btn">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>
<div id="show-live2d" class="show-live2d-btn btnHide">
    <a class="btn-floating btn-large waves-effect waves-light" href="##">
        <svg viewBox="-75 -55 350 500"
             xmlns="http://www.w3.org/2000/svg"
             xmlns:xlink="http://www.w3.org/1999/xlink">
            <path fill-rule="evenodd" fill="rgb(255,255,255)"
                  d="M124.000,-0.000 L195.000,45.000 L195.000,196.000 L125.000,252.000 C125.000,252.000 124.333,252.000 124.000,252.000 C124.000,168.008 124.000,-0.000 124.000,-0.000 ZM36.000,31.000 L77.000,47.000 L77.000,196.000 L36.000,221.000 L36.000,31.000 ZM-0.000,67.000 C-0.000,67.000 16.001,71.000 24.000,73.000 C24.000,104.663 24.000,168.000 24.000,168.000 C24.000,168.000 7.999,176.667 -0.000,181.000 C-0.000,143.004 -0.000,67.000 -0.000,67.000 ZM124.000,-0.000 L195.000,45.000 L195.000,196.000 L125.000,252.000 C125.000,252.000 124.333,252.000 124.000,252.000 C124.000,168.008 124.000,-0.000 124.000,-0.000 ZM36.000,31.000 L77.000,47.000 L77.000,196.000 L36.000,221.000 L36.000,31.000 ZM-0.000,67.000 C-0.000,67.000 16.001,71.000 24.000,73.000 C24.000,104.663 24.000,168.000 24.000,168.000 C24.000,168.000 7.999,176.667 -0.000,181.000 C-0.000,143.004 -0.000,67.000 -0.000,67.000 ZM124.000,-0.000 L195.000,45.000 L195.000,196.000 L125.000,252.000 C125.000,252.000 124.333,252.000 124.000,252.000 C124.000,168.008 124.000,-0.000 124.000,-0.000 ZM36.000,31.000 L77.000,47.000 L77.000,196.000 L36.000,221.000 L36.000,31.000 ZM-0.000,67.000 C-0.000,67.000 16.001,71.000 24.000,73.000 C24.000,104.663 24.000,168.000 24.000,168.000 C24.000,168.000 7.999,176.667 -0.000,181.000 C-0.000,143.004 -0.000,67.000 -0.000,67.000 Z"/>
        </svg>
    </a>
</div>
<script src="https://cdn.jsdelivr.net/npm/materialize-css@1.0.0/dist/js/materialize.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/desandro/masonry@4.0.0/dist/masonry.pkgd.min.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->



<script src="/js/bundle.js"></script>
<!--<script type="module">-->
<!--    const getWidth = () => {-->
<!--        let width = window.innerWidth-->
<!--        if (width >= 1040) {-->
<!--            import('/js/bundle.js');-->
<!--        } else {-->
<!--            import('/js/bundle.js');-->
<!--        }-->
<!--    }-->
<!--    getWidth();-->
<!--</script>-->
<script type="application/javascript" src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>
<script>
    NProgress.configure({trickle: true, trickleSpeed: 300, speed: 500});
    NProgress.start();
    NProgress.set(0.2);
    document.addEventListener("DOMContentLoaded", () => {
        NProgress.set(0.4);
    });
</script>
</body>
</html>