<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux 编程</title>
      <link href="2021/01/01/LinuxProgramming/"/>
      <url>2021/01/01/LinuxProgramming/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux-进程存储管理"><a href="#Linux-进程存储管理" class="headerlink" title="Linux 进程存储管理"></a>Linux 进程存储管理</h2><h3 id="存储类型比较"><a href="#存储类型比较" class="headerlink" title="存储类型比较"></a>存储类型比较</h3><table><thead><tr><th>类型</th><th>作用域</th><th>生存域</th><th>存储位置</th></tr></thead><tbody><tr><td><code>auto</code> 变量</td><td>一对 <code>&#123;&#125;</code> 内</td><td>当前函数</td><td>变量默认存储类型，存储在栈区</td></tr><tr><td><code>extern</code> 函数</td><td>整个程序</td><td>整个程序运行期</td><td>函数默认存储类型，代码段</td></tr><tr><td><code>extern</code> 变量</td><td>整个程序</td><td>整个程序运行期</td><td>初始化在 data 段，未初始化在 BSS 段</td></tr><tr><td><code>static</code> 函数</td><td>当前文件</td><td>整个程序运行期</td><td>代码段</td></tr><tr><td><code>static</code> 全局变量</td><td>当前文件</td><td>整个程序运行期</td><td>初始化在 data 段，未初始化在 BSS 段</td></tr><tr><td><code>static</code> 局部变量</td><td>一对 <code>&#123;&#125;</code> 内</td><td>整个程序运行期</td><td>初始化在 data 段，未初始化在 BSS 段</td></tr><tr><td><code>register</code> 变量</td><td>一对 <code>&#123;&#125;</code> 内</td><td>当前函数</td><td>运行时存储在 CPU 寄存器中</td></tr><tr><td>字符串常量</td><td>当前文件</td><td>整个程序运行期</td><td>代码段</td></tr></tbody></table><h3 id="栈和堆的区别"><a href="#栈和堆的区别" class="headerlink" title="栈和堆的区别"></a>栈和堆的区别</h3><table><thead><tr><th>项目</th><th>栈</th><th>堆</th></tr></thead><tbody><tr><td>管理方式</td><td>系统自动管理</td><td>手动管理</td></tr><tr><td>空间大小</td><td>小，向低地址扩展，连续的内存区域</td><td>大，向高地址扩展，不连续的区域，系统使用链表存储空闲内存地址</td></tr><tr><td>产生碎片</td><td>无</td><td>多</td></tr><tr><td>增长方向</td><td>向下，地址减小的方向</td><td>向上，地址增加的方向</td></tr><tr><td>分配方式</td><td>操作系统自动完成，也可以使用 <code>alloca()</code> 手动申请</td><td>使用 <code>malloc()</code> 申请， <code>free()</code> 释放</td></tr><tr><td>分配效率</td><td>高</td><td>低</td></tr></tbody></table><h3 id="内存空间申请释放相关函数"><a href="#内存空间申请释放相关函数" class="headerlink" title="内存空间申请释放相关函数"></a>内存空间申请释放相关函数</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span> malloc <span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span></code></pre><ul><li><code>size</code>: 申请的字节数</li><li>return: 指向所分配的空间首地址的指针。分配失败时返回 NULL。</li></ul><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> free <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span></code></pre><ul><li><code>ptr</code>: 要释放的空间首地址</li></ul><blockquote><p>推荐释放后将指针置为空 <code>ptr = NULL</code></p></blockquote><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span> realloc <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> size_t newsize<span class="token punctuation">)</span></code></pre><ul><li><code>ptr</code>: 试图更改大小的堆空间位置</li><li><code>newsize</code>: 新的内存大小</li><li>return: 新的内存指针，如果申请失败将返回 NULL，但原来的地址可以继续使用</li></ul><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span> calloc <span class="token punctuation">(</span>size_t count<span class="token punctuation">,</span> size_t eltsize<span class="token punctuation">)</span></code></pre><p>类似 <code>malloc</code> ，会把动态分配的内存初始化为 0</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">alloca</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在栈中分配空间，函数返回时会自动释放</p><h3 id="内存数据管理函数"><a href="#内存数据管理函数" class="headerlink" title="内存数据管理函数"></a>内存数据管理函数</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span> memcpy <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>restrict to<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>restrict from<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span></code></pre><ul><li>复制后内存首地址</li><li>数据源地址</li><li>return: 目的地址</li></ul><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span> memmove <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>to<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>from<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span></code></pre><p>与 <code>memcpy</code> 相比，会检查源地址和目的地址是否重叠。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span> memset <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>block<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span></code></pre><p>初始化指定内存单元</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">memchr</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">,</span> size_t n<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在一段内存空间中查找某个字符第一次出现的位置</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">memcmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>s1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>s2<span class="token punctuation">,</span> size_t n<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>与 <code>strncmp</code> 相同，比较内存单元 s1 和 s2 起始位置的前 n 个字节是否相等，相等返回 0；s1&lt;s2，返回 -1；s1&gt;s2，返回 1</p><h3 id="进程与命令行相关函数"><a href="#进程与命令行相关函数" class="headerlink" title="进程与命令行相关函数"></a>进程与命令行相关函数</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">getopt</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>optstring<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>参数个数</li><li>指向参数的数组</li><li>所有可能的参数字符串  </li></ul><p><code>getopt</code> 函数的第 3 个参数 <code>optstring</code> 可以是下列元素：</p><ul><li>单个字符，这种表示选项。</li><li>单个字符后接一个冒号：表示该选项后必须跟一个参数。参数紧跟在选项后或者以空格隔开。该参数的指针赋给 <code>optarg</code>（一个全局变量）。</li><li>单个字符后跟两个冒号，表示该选项后可以跟一个参数。参数必须紧跟在选项后不能以空格隔开。该参数的指针赋给 <code>optarg</code>。</li></ul><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> getopt_long <span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> <span class="token operator">*</span>argv<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>shortopts<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">option</span> <span class="token operator">*</span>longopts<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>indexptr<span class="token punctuation">)</span></code></pre><p>第 1 个参数为当前传递进来的参数个数<br>第 2 个参数为当前传递进来的参数列表<br>第 3 个参数为当前进程所有可支持短参数的字符串<br>第 4 个参数为 struct <code>option</code> ，标识所有长参数的对应关系。<br>返回情况：</p><ul><li>在使用此函数处理一个参数时，全局变量 <code>optarg</code> 指向下一个要处理的变量，并返回 struct <code>option</code> 的第 4 个成员变量。一般情况下，如果 struct <code>option</code> 的第 3 个参数设置为 <code>NULL</code>，第 4 个参数一般设置为该长选项对应的短选项字符值，即返回相应的短选项字符。</li><li>如果解析完最后一个成员将返回<code>-1</code>。</li><li>如果 <code>getopt_long</code> 遇到一个无效的选项字符，它会打印一个错误消息并且返回<code>?</code>。</li><li>当 <code>getopt_long</code> 解析到一个长选项并且发现后面没有参数则返回<code>:</code>，表示缺乏参数。</li></ul><h3 id="环境变量相关函数"><a href="#环境变量相关函数" class="headerlink" title="环境变量相关函数"></a>环境变量相关函数</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span> getenv <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span></code></pre><p>如果执行成功，此函数返回指定环境变量的值，否则返回 <code>NULL</code> 。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> putenv <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>string<span class="token punctuation">)</span></code></pre><p>如果执行成功，将指定字符串信息添加到环境变量，该字符串格式为”NAME=VALUE”，如果没有后面的等号，则删除此环境变量。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> setenv <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>value<span class="token punctuation">,</span> <span class="token keyword">int</span> replace<span class="token punctuation">)</span></code></pre><p>第 1 个参数为欲设置的环境变量名<br>第 2 个参数为欲设置的值<br>第 3 个参数如果为非 0 且第 1 个指定的环境变量有一个存在值，将覆盖原来的值；如果第 3 个参数为 0 且第 1 个指定的环境变量有一个存在值，将保留原来值，并不返回错误</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> unsetenv <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span></code></pre><p>删除某个环境变量的值</p><h3 id="时间相关函数"><a href="#时间相关函数" class="headerlink" title="时间相关函数"></a>时间相关函数</h3><pre class="language-c" data-language="c"><code class="language-c">clock_t clock <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span></code></pre><p>返回当前时刻程序运行的时间（user time + system time），其结果为时钟计数器值，将其转换为秒的公式为： <code>result / CLOCKS_PER_SEC</code></p><pre class="language-c" data-language="c"><code class="language-c">time_t <span class="token function">time</span><span class="token punctuation">(</span>time_t <span class="token operator">*</span>tloc<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>其时间是自 1970-1-1 0:0:0 以来经历的秒数。如果其参数设置为空，将返回时间秒数，如果参数不为空，将存储于该参数中。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span> ctime <span class="token punctuation">(</span><span class="token keyword">const</span> time_t <span class="token operator">*</span>time<span class="token punctuation">)</span></code></pre><p>返回当前时间字符串： <code>Tue May 21 13:46:22 1991</code></p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">tm</span> <span class="token operator">*</span> gmtime <span class="token punctuation">(</span><span class="token keyword">const</span> time_t <span class="token operator">*</span>time<span class="token punctuation">)</span></code></pre><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">tm</span> <span class="token operator">*</span> localtime <span class="token punctuation">(</span><span class="token keyword">const</span> time_t <span class="token operator">*</span>time<span class="token punctuation">)</span></code></pre><p>以上两个函数将返回 struct <code>tm</code> 结构体存储时间</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span> asctime <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">tm</span> <span class="token operator">*</span>brokentime<span class="token punctuation">)</span></code></pre><p>此函数将 struct <code>tm</code> 结构体转换为标准时间字符串： <code>Tue May 21 13:46:22 1991</code></p><pre class="language-c" data-language="c"><code class="language-c">size_t strftime <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> size_t size<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>template<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">tm</span> <span class="token operator">*</span>brokentime<span class="token punctuation">)</span></code></pre><p>从 struct <code>tm</code> 中提取某一项。<br>第 1 个参数为存储某项的空间<br>第 2 个参数为该空间大小<br>第 3 个参数为欲提取的项<br>第 4 个参数为从哪个 struct <code>tm</code> 中提取<br>其中，第 3 个参数可提取项可为以下任意项：  </p><table><thead><tr><th>占位符</th><th>替换</th><th>示例</th></tr></thead><tbody><tr><td><code>%a</code></td><td>缩写的星期几名称</td><td>Sun</td></tr><tr><td><code>%A</code></td><td>完整的星期几名称</td><td>Sunday</td></tr><tr><td><code>%b</code></td><td>缩写的月份名称</td><td>Mar</td></tr><tr><td><code>%B</code></td><td>完整的月份名称</td><td>March</td></tr><tr><td><code>%c</code></td><td>日期和时间表示法</td><td>Sun Aug 19 02:56:02 2012</td></tr><tr><td><code>%d</code></td><td>一月中的第几天（01-31）</td><td>19</td></tr><tr><td><code>%H</code></td><td>24 小时格式的小时（00-23）</td><td>14</td></tr><tr><td><code>%I</code></td><td>12 小时格式的小时（01-12）</td><td>05</td></tr><tr><td><code>%j</code></td><td>一年中的第几天（001-366）</td><td>231</td></tr><tr><td><code>%m</code></td><td>十进制数表示的月份（01-12）</td><td>08</td></tr><tr><td><code>%M</code></td><td>分（00-59）</td><td>55</td></tr><tr><td><code>%p</code></td><td>AM 或 PM 名称</td><td>PM</td></tr><tr><td><code>%S</code></td><td>秒（00-61）</td><td>02</td></tr><tr><td><code>%U</code></td><td>一年中的第几周，以第一个星期日作为第一周的第一天（00-53）</td><td>33</td></tr><tr><td><code>%w</code></td><td>十进制数表示的星期几，星期日表示为 0（0-6）</td><td>4</td></tr><tr><td><code>%W</code></td><td>一年中的第几周，以第一个星期一作为第一周的第一天（00-53）</td><td>34</td></tr><tr><td><code>%x</code></td><td>日期表示法</td><td>08/19/12</td></tr><tr><td><code>%X</code></td><td>时间表示法</td><td>02:50:06</td></tr><tr><td><code>%y</code></td><td>年份，最后两个数字（00-99）</td><td>01</td></tr><tr><td><code>%Y</code></td><td>年份</td><td>2012</td></tr><tr><td><code>%Z</code></td><td>时区的名称或缩写</td><td>CDT</td></tr><tr><td><code>%%</code></td><td>一个 % 符号</td><td>%</td></tr></tbody></table><h2 id="ANSI-C-文件管理"><a href="#ANSI-C-文件管理" class="headerlink" title="ANSI C 文件管理"></a>ANSI C 文件管理</h2><h3 id="指定流缓冲区"><a href="#指定流缓冲区" class="headerlink" title="指定流缓冲区"></a>指定流缓冲区</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> setbuf <span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span></code></pre><p>第 1 个参数为要操作的流对象<br>第 2 个参数 <code>buf</code> 必须指向一个长度为 <code>BUFSIZ</code> 的缓冲区。如果将 <code>buf</code> 设置为 <code>NULL</code> ，则关闭缓冲区。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> setvbuf <span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token keyword">int</span> mode<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span></code></pre><p>第 1 个参数为要操作的流对象<br>第 2 个参数 <code>buf</code> 指向一个长度为第 4 个参数指示大小的缓冲区<br>第 3 个参数为缓冲区类型： <code>_IOFBF</code> 、 <code>_IOLBF</code> 、 <code>_IONBF</code></p><h3 id="文件-I-O-操作"><a href="#文件-I-O-操作" class="headerlink" title="文件 I/O 操作"></a>文件 I/O 操作</h3><pre class="language-c" data-language="c"><code class="language-c">FILE <span class="token operator">*</span><span class="token function">fopen</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>mode<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>第 1 个参数指向欲打开的文件名字符串的指针 ( <code>/ect/services</code> )，可以使用绝对路径或相对路径来指定<br>第 2 个参数为打开模式：  </p><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td><code>r</code></td><td>打开一个用于读取的文件。该文件必须存在。</td></tr><tr><td><code>w</code></td><td>创建一个用于写入的空文件。如果文件名称与已存在的文件相同，则会删除已有文件的内容，文件被视为一个新的空文件。</td></tr><tr><td><code>a</code></td><td>追加到一个文件。写操作向文件末尾追加数据。如果文件不存在，则创建文件。使用 <code>fseek</code> 修改无效</td></tr><tr><td><code>r+</code></td><td>打开一个用于更新的文件，可读取也可写入。该文件必须存在。</td></tr><tr><td><code>w+</code></td><td>创建一个用于读写的空文件。</td></tr><tr><td><code>a+</code></td><td>打开一个用于读取和追加的文件。读位于文件头，写位于文件尾，使用 <code>fseek</code> 修改无效</td></tr></tbody></table><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> fclose <span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span></code></pre><p>关闭该流对象</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> fcloseall <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span></code></pre><p>关闭打开的所有流对象</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> fflush <span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span></code></pre><p>更新缓冲区内容</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> getc <span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span></code></pre><p>若调用成功则返回读到的内容，如果失败或者读到文件结束则返回 <code>EOF</code> (-1)</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> getchar <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span></code></pre><p>相当于 <code>getc(stdin)</code></p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">putc</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">,</span> FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>调用成功则返回内容，如果失败则返回-1</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">putchar</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>相当于 <code>putc(c, stdout)</code></p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span> fgets <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">,</span> FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span><span class="token keyword">char</span> <span class="token operator">*</span> gets <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">)</span></code></pre><p>从将字符从 <code>stream</code> 读入 <code>s</code> 所指向的内存单元，直到读取 n-1 字符、换行符（传输到 <code>s</code> ）或遇到文件结束标志 <code>EOF</code> 为止，并将最后一个空间置为 <code>\0</code> 。<br><code>gets()</code> 不传输换行符。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">fputs</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">puts</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>puts() 将 s 指向的以空字符结尾的字符串（后接换行符）写入标准输出流 stdout。<br>fputs() 将 s 指向的以空字符结尾的字符串写入指定输出 <code>stream</code> ，但不追加换行符。</p><pre class="language-c" data-language="c"><code class="language-c">size_t fread <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">,</span> size_t size<span class="token punctuation">,</span> size_t count<span class="token punctuation">,</span> FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span></code></pre><p>从流中读取 <code>count</code> 个大小为 <code>size</code> 的对象存放于第一个参数 <code>ptr</code> 所指向的内存空间。<br>第一个参数为读取的对象的存放位置<br>第二个参数为读取对象的大小，例如读出一个结构体 <code>buf</code> ，此参数可以设置为 <code>sizeof(struct buf)</code></p><p>第三个参数为读取对象的个数<br>第四个参数为读取的流<br>返回实际读取到的对象个数（不是读写的字节大小）</p><pre class="language-c" data-language="c"><code class="language-c">size_t fwrite <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">,</span> size_t size<span class="token punctuation">,</span> size_t count<span class="token punctuation">,</span> FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span></code></pre><p>向流中写入 <code>count</code> 个大小为 <code>size</code> 的对象存储于 <code>ptr</code> 所指示的空间中。<br>第一个参数为指向欲写入的对象的数据空间指针，即写入的对象的存放位置<br>第二个参数为写入对象的大小，例如写入一个结构体 <code>buf</code> ，此参数可以设置为 <code>sizeof(struct buf)</code></p><p>第三个参数为写入的个数<br>第四个参数为写入的数据流<br>执行成功返回实际写入的对象个数，否则返回 <code>-1</code></p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> feof <span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span></code></pre><p>用于二进制文件流，如果读到文件结束，返回 <code>1</code> ，否则返回 <code>0</code> 。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> ferror <span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span></code></pre><p>判断给定的流是否出现了错误，如果没有出现错误，返回 <code>0</code> ，否则表示出错</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> clearerr <span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span></code></pre><p>清除错误标识位</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">long</span> <span class="token keyword">int</span> ftell <span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span></code></pre><p>返回流的当前读写位置距离文件开始的字节数</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> fseek <span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">int</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> whence<span class="token punctuation">)</span></code></pre><p>第一个参数为操作的流对象<br>第二个参数为针对第三个参数（修改基准）的偏移量<br>第三个参数为修改位置的基准： <code>SEEK_SET</code> 文件开头， <code>SEEK_CUR</code> 当前位置， <code>SEEK_END</code> 文件结尾</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> rewind <span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span></code></pre><p>将读写指针重置到文件开始位置</p><h3 id="格式化输入输出"><a href="#格式化输入输出" class="headerlink" title="格式化输入输出"></a>格式化输入输出</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> printf <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>template<span class="token punctuation">,</span> …<span class="token punctuation">)</span><span class="token keyword">int</span> scanf <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>template<span class="token punctuation">,</span> …<span class="token punctuation">)</span><span class="token keyword">int</span> fprintf <span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>template<span class="token punctuation">,</span> …<span class="token punctuation">)</span><span class="token keyword">int</span> scanf <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>template<span class="token punctuation">,</span> …<span class="token punctuation">)</span></code></pre><p><code>printf()</code>  <code>scanf()</code> 函数专门针对标准输入输出流<br><code>fprintf()</code>  <code>fscanf()</code> 可用于任意流</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> sprintf <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>template<span class="token punctuation">,</span> …<span class="token punctuation">)</span></code></pre><p><code>sprintf</code> 是将列出的数据或者变量（第 3 个及后面多个参数）以 <code>template</code> 格式输出到以 <code>s</code> 为起始位置的内存空间中。<br>返回本次函数调用最终打印到字符缓冲区中的字符数目</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> sscanf <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>template<span class="token punctuation">,</span> …<span class="token punctuation">)</span></code></pre><p>与 <code>scanf</code> 类似，但以固定字符串为输入源</p><h2 id="POSIX-文件与目录管理"><a href="#POSIX-文件与目录管理" class="headerlink" title="POSIX 文件与目录管理"></a>POSIX 文件与目录管理</h2><h3 id="文件流与文件描述符转换"><a href="#文件流与文件描述符转换" class="headerlink" title="文件流与文件描述符转换"></a>文件流与文件描述符转换</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> fileno <span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span></code></pre><p>以某个流对象为参数，返回该流的文件描述符值。</p><pre class="language-c" data-language="c"><code class="language-c">FILE <span class="token operator">*</span> fdopen <span class="token punctuation">(</span><span class="token keyword">int</span> filedes<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>opentype<span class="token punctuation">)</span></code></pre><p>将某个流与一个文件描述符相接。<br>第 1 个参数为一个文件描述符<br>第 2 个参数为封装该流的权限 ( <code>r(+)</code> , <code>w(+)</code> , <code>a(+)</code> )<br>成功返回一个流对象，失败返回 <code>NULL</code></p><h3 id="POSIX-标准下文件-I-O-管理"><a href="#POSIX-标准下文件-I-O-管理" class="headerlink" title="POSIX 标准下文件 I/O 管理"></a>POSIX 标准下文件 I/O 管理</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> mode_t mode<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>返回所打开的文件的文件描述符（int 类型）。<br>第 1 个参数是欲打开文件的文件路径<br>第 2 个参数打开文件的方式<br>如果欲打开的文件不存在，则可以使用 <code>open</code> 函数自动创建该文件，即 <code>O_CREAT</code> 打开方式，此时需要用到第 3 个参数，它约定了文件的权限，具体的计算方法为 <code>mode&amp;~umask</code></p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>关闭文件，参数为调用 <code>open</code> 函数打开文件时返回的文件描述符</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">creat</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> mode_t mode<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>创建文件，相当于 <code>int open(const char *pathname, (O_CREAT|O_WRONLY|O_TRUNC), mode_t mode);</code></p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> fcntl <span class="token punctuation">(</span><span class="token keyword">int</span> filedes<span class="token punctuation">,</span> <span class="token keyword">int</span> command<span class="token punctuation">,</span> …<span class="token punctuation">)</span></code></pre><p>用于修改某个文件描述符的特殊属性<br>第 1 个参数 <code>filedes</code> 为欲修改属性的文件描述符<br>第 2 个参数 <code>command</code> 为相应操作  </p><pre class="language-c" data-language="c"><code class="language-c">ssize_t read <span class="token punctuation">(</span><span class="token keyword">int</span> filedes<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buffer<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span></code></pre><p>从参数 <code>filedes</code> 所指的文件中读取 <code>size</code> 数据到 <code>buffer</code> 指针所指的内存中，此函数返回值为实际读取到的字数。如果返回 <code>0</code> ，表示已到达文件尾部或无数据可读。</p><pre class="language-c" data-language="c"><code class="language-c">ssize_t write <span class="token punctuation">(</span><span class="token keyword">int</span> filedes<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buffer<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span></code></pre><p>尝试将以 <code>buffer</code> 为起始地址的缓冲区前 <code>size</code> 个字节写入与打开文件描述符 <code>filedes</code> 关联的文件内。如果执行成功，将返回真正写入数据的大小，如果失败，将返回 <code>-1</code> ，并置错误信息。</p><pre class="language-c" data-language="c"><code class="language-c">off_t lseek <span class="token punctuation">(</span><span class="token keyword">int</span> filedes<span class="token punctuation">,</span> off_t offset<span class="token punctuation">,</span> <span class="token keyword">int</span> whence<span class="token punctuation">)</span></code></pre><p>第 1 个参数 <code>filedes</code> 为已经打开的文件<br>第 2 个参数 <code>offset</code> 为根据参考位置来移动读写位置的偏移数<br>第 3 个参数 <code>whence</code> 参考位置： <code>SEEK_SET</code> 文件开头， <code>SEEK_CUR</code> 当前位置， <code>SEEK_END</code> 文件结尾<br>返回当前读写位置距离文件头的字节数</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sync</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">fsync</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">fdatasync</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>更新缓冲区。<br><code>sync</code> 始终成功，但 <code>sync</code> 只是将所有修改过的块的缓存排入写队列，然后返回，不等待实际 I/O 操作结束。<br><code>fsync</code> 等待 I/O 结束，然后返回<br><code>fdatasync</code> 只更新内容，如果没有必要，并不更新元数据<br>成功时返回 <code>0</code></p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">mmap</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> size_t length<span class="token punctuation">,</span> <span class="token keyword">int</span> prot<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> off_t offset<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">munmap</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> size_t length<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>将某个文件的指定内容映射到内存空间中。  </p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">flock</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> operation<span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre><p>对文件的锁定和解锁操作，其锁定针对相应的文件表项（struct <code>file</code> ），因此，复制的新文件描述符仍然受其影响。<br>第 1 个参数为欲操作的文件描述符<br>第 2 个参数为操作命令：  </p><ul><li><code>LOCK_SH</code>：建立共享锁定。多个进程可同时对同一文件作共享读操作，但不能排它写锁定。</li><li><code>LOCK_EX</code>：建立文件互斥锁定。任意两进程不能同时操作文件。</li><li><code>LOCK_UN</code>：解除文件的锁定状态。</li><li><code>LOCK_NB</code>：无法建立锁定时，此操作可不被阻塞，马上返回进程，通常与前面的操作组合使用。</li></ul><h3 id="目录流基本操作"><a href="#目录流基本操作" class="headerlink" title="目录流基本操作"></a>目录流基本操作</h3><pre class="language-c" data-language="c"><code class="language-c">DIR <span class="token operator">*</span><span class="token function">opendir</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">closedir</span><span class="token punctuation">(</span>DIR <span class="token operator">*</span>dirp<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>opendir()</code> 打开路径为 <code>name</code> 的目录，并使用一个目录流指针，用来标识后续操作中的目录流。<br><code>closedir()</code> 用于关闭指定的目录流，然后释放与 DIR 指针关联的结构。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">dirent</span> <span class="token operator">*</span><span class="token function">readdir</span><span class="token punctuation">(</span>DIR <span class="token operator">*</span>dirp<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>每调用一次 <code>readdir()</code> ，其将返回指向下一个目录条目的指针。如果到达目录的结尾，或者检测到无效的 <code>seekdir()</code> 操作，将返回 <code>NULL</code> 指针。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">readdir_r</span><span class="token punctuation">(</span>DIR <span class="token operator">*</span>dirp<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dirent</span> <span class="token operator">*</span>entry<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">dirent</span> <span class="token operator">*</span><span class="token operator">*</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>readdir()</code> 在多线程操作中会不安全，因此，Linux 提供了 <code>readdir_r()</code> 函数实现多线程读取目录内容操作。<br>第 1 个参数为打开的目录指针，它将初始化第 2 个参数 <code>entry</code> 引用的 <code>dirent</code> 结构，以表示第 1 个参数 <code>dirp</code> 所引用的目录流中的当前位置；然后在第 3 个参数 <code>result</code> 所指示的位置存储指向该结构的目录信息。<br>如果成功完成，将在第 3 个参数返回一个指向描述目录条目的 struct <code>dirent</code> 类型对象的指针。如果到达目录的结尾，则在第 3 个参数中返回 <code>NULL</code> 指针，并返回 <code>0</code> 。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">long</span> <span class="token function">telldir</span><span class="token punctuation">(</span>DIR <span class="token operator">*</span>dirp<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>返回目录流相关联的当前位置。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">seekdir</span><span class="token punctuation">(</span>DIR <span class="token operator">*</span>dirp<span class="token punctuation">,</span> <span class="token keyword">long</span> loc<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在 <code>dirp</code> 引用的目录流上设置下一个 <code>readdir()</code> 操作的位置。 <code>loc</code> 参数是从 <code>telldir()</code> 获取的目录流中的一个位置。只有当对应的 DIR 指针处于打开状态时，这些值才有效。如果将目录流关闭后再重新打开，其值可能无效。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">rewinddir</span><span class="token punctuation">(</span>DIR <span class="token operator">*</span>dirp<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>将 <code>dirp</code> 引用的目录流的位置重置到目录的开头。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> mkdir <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> mode_t mode<span class="token punctuation">)</span><span class="token keyword">int</span> rmdir <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">)</span></code></pre><p>第 1 个参数为欲创建的目录文件路径<br>第 2 个参数用于设置该目录的访问权限，新创建文件权限为 <code>mode &amp; ~umask &amp; 0777</code> 。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">getcwd</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">get_current_dir_name</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>将当前工作路径的绝对路径名置于由 <code>buf</code> 所指定的数组中，并返回 <code>buf</code> 。 <code>size</code> 的数值至少比所返回路径名的长度大 1，否则返回 <code>NULL</code> 。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">chdir</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">fchdir</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>修改当前进程工作路径</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">chroot</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>修改一个进程可以访问的根目录路径</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">isfdtype</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> fdtype<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>测试某个打开的文件描述符的原文件是什么类型</p><h3 id="文件属性管理"><a href="#文件属性管理" class="headerlink" title="文件属性管理"></a>文件属性管理</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">stat</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">stat</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">fstat</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">stat</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">lstat</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">stat</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>第 1 个参数为欲读取状态的文件（路径字符串），可以使用绝对路径或相对路径<br>第 2 个参数为文件属性临时存放位置，其类型为 struct <code>stat</code></p><p>读取已打开的文件可以使用 <code>fstat</code> 函数 。<br>如果 <code>stat</code> 函数的第 1 个参数为符号连接文件，其读取的属性为源文件的属性，要获取连接文件自身的属性，需要调用 <code>lstat</code> 函数。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">chmod</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> mode_t mode<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>第 1 个参数为要修改权限的文件名<br>第 2 个参数为修改的权限描述， <code>mode_t</code> 原始类型为 unsigned int</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> chown <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> uid_t owner<span class="token punctuation">,</span> gid_t group<span class="token punctuation">)</span><span class="token keyword">int</span> fchown <span class="token punctuation">(</span><span class="token keyword">int</span> filedes<span class="token punctuation">,</span> uid_t owner<span class="token punctuation">,</span> gid_t group<span class="token punctuation">)</span></code></pre><p>第 1 个参数为欲修改用户的文件<br>第 2 个参数为修改后的文件拥有者 ID<br>第 3 个参数为修改后该文件拥有者所在的 GID  </p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> link <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>oldname<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>newname<span class="token punctuation">)</span><span class="token keyword">int</span> unlink <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">)</span></code></pre><p>创建硬连接文件<br>第 1 个参数为源文件的路径<br>第 2 个参数为新硬连接文件的路径  </p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">symlink</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>target<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>linkpath<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>创建符号连接<br>第 1 个参数为源文件的路径<br>第 2 个参数为新连接文件的路径  </p><pre class="language-c" data-language="c"><code class="language-c">ssize_t <span class="token function">readlink</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t bufsiz<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>将指定符号连接文件的源文件路径读入到 <code>buf</code> 中<br>第 1 个参数为符号连接文件路径<br>第 2 个参数为存储源文件路径的内存起始地址<br>第 3 个参数为可用空间大小  </p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> utime <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">utimbuf</span> <span class="token operator">*</span>times<span class="token punctuation">)</span></code></pre><p>修改文件的访问时间和修改时间</p><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><pre class="language-c" data-language="c"><code class="language-c">pid_t <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pid_t <span class="token function">getppid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>获得当前进程号或父进程号</p><pre class="language-c" data-language="c"><code class="language-c">pid_t <span class="token function">getpgid</span><span class="token punctuation">(</span>pid_t pid<span class="token punctuation">)</span><span class="token punctuation">;</span>pid_t <span class="token function">getpgrp</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>getpgid()</code> 函数来获得指定进程的进程组号。参数 <code>pid</code> 为要获得进程组号的进程号，如果为 <code>0</code> 表示获取当前进程组号。<br><code>getpgrp()</code> 也可以用来获取当前进程的进程组号。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">setpgid</span><span class="token punctuation">(</span>pid_t pid<span class="token punctuation">,</span> pid_t pgid<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>将某个进程加到某个进程组。<br>第 1 个参数为欲修改进程 PGID 的进程 PID<br>第 2 个参数为新的进程组号<br>如果这两个参数相等，则由 <code>pid</code> 指定的进程变成进程组组长；如果 <code>pid</code> 为 <code>0</code> ，则修改当前进程的 PGID；如果 <code>pgid</code> 是 <code>0</code> ，则由 <code>pid</code> 指定的进程的 PID 将用于进程组号 PGID。</p><pre class="language-c" data-language="c"><code class="language-c">pid_t <span class="token function">getsid</span><span class="token punctuation">(</span>pid_t pid<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如果 <code>pid</code> 是 <code>0</code> ，返回调用进程的会话号 SID，一般来说，该值等于进程组号 PGID。如果 <code>pid</code> 并不属于调用者所在的会话，则调用者就不能获得 SID。</p><pre class="language-c" data-language="c"><code class="language-c">pid_t <span class="token function">setsid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>创建新会话。</p><pre class="language-c" data-language="c"><code class="language-c">pid_t <span class="token function">tcgetpgrp</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">tcsetpgrp</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> pid_t pgrp<span class="token punctuation">)</span><span class="token punctuation">;</span>pid_t <span class="token function">tcgetsid</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>tcgetpgrp()</code> 返回与打开的终端 <code>fd</code> 相关联前台进程组的进程组号。<br><code>tcsetpgrp()</code> 用来设置某个进程组是前台还是后台进程组<br><code>tcgetsid()</code> 可以获取控制终端的会话首进程的会话 ID  </p><pre class="language-c" data-language="c"><code class="language-c">uid_t <span class="token function">getuid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>uid_t <span class="token function">geteuid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>获得当前进程的 RUID<br>获得当前进程的 EUID  </p><pre class="language-c" data-language="c"><code class="language-c">gid_t <span class="token function">getgid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>gid_t <span class="token function">getegid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>获得当前进程的 GID<br>获得当前进程的 EGID  </p><pre class="language-c" data-language="c"><code class="language-c">pid_t fork <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>pid_t vfork <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span></code></pre><p>如果执行成功，在父进程中返回新进程的 PID，在子进程中返回 <code>0</code> 。<br>如果执行失败，则在父进程中返回 <code>-1</code> 。<br><code>vfork()</code> 函数创建新进程时不复制父进程的地址空间。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> execl <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg0<span class="token punctuation">,</span> …<span class="token punctuation">)</span><span class="token keyword">int</span> execlp <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg0<span class="token punctuation">,</span> …<span class="token punctuation">)</span><span class="token keyword">int</span> execle <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg0<span class="token punctuation">,</span> …<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> env<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">int</span> execv <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">int</span> execvp <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">int</span> execve <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> env<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><ul><li>v: 使用 <code>argv</code> 参数数组</li><li>l: 使用参数列表</li><li>p: 搜索 PATH 环境变量查找程序</li><li>e: 设置环境变量</li></ul><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">system</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>创建新进程，并在此进程中运行新进程，直到新进程结束后，才继续运行父进程。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">atexit</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>function<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">on_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>function<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>注册在执行 <code>exit()</code> 函数前执行的操作函数。<br><code>atexit</code> 注册的函数没有参数， <code>on_exit</code> 注册的函数带参数。<br>第 1 个参数为退出的状态，在执行 <code>exit()</code> 函数时此参数值为 <code>exit()</code> 函数的参数。<br>第 2 个参数为用户输入的信息，一个无类型的指针。用户可以指定一段代码位置或输出信息。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">_exit</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>_exit</code> 函数不调用任何注册函数而直接退出进程。</p><pre class="language-c" data-language="c"><code class="language-c">pid_t <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>wstatus<span class="token punctuation">)</span><span class="token punctuation">;</span>pid_t <span class="token function">waitpid</span><span class="token punctuation">(</span>pid_t pid<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>wstatus<span class="token punctuation">,</span> <span class="token keyword">int</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>调用 <code>wait()</code> 函数的父进程将阻塞式等待该进程的任意一个子进程结束后，回收该子进程的内核进程资源。<br>返回当前结束的子进程的 PID，同时将子进程退出时的状态存储在 <code>＿stat_loc</code> 变量中。  </p><p><code>waitpid()</code> 函数来等待指定子进程结束。<br>第 1 个参数为进程 PID 值：</p><ul><li>PID &gt; 0：等待进程 PID 为该 PID 值的进程结束</li><li>PID = -1：等待任意子进程结束，相当于调用 <code>wait</code> 函数</li><li>PID = 0：等待与当前进程的进程组 PGID 一致的进程结束</li><li>PID &lt; -1：等待进程组 PGID 是此值的绝对值的进程结束</li></ul><p>第 2 个参数为调用它的函数中某个变量地址，如果执行成功，则用来存储结束进程的结束状态。<br>第 3 个参数为等待选项，可以设置为 <code>0</code> ，亦可为 <code>WNOHANG</code> （不阻塞等待）和 <code>WUNTRACED</code> （报告状态信息）</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">access</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">int</span> amode<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>用来检查当前进程是否拥有对某文件的相应访问权限。<br>第 1 个参数为欲访问的文件（包含路径）<br>第 2 参数为相应的访问权限</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">setuid</span><span class="token punctuation">(</span>uid_t uid<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> <span class="token function">setgid</span><span class="token punctuation">(</span>gid_t gid<span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre><p>设置进程真实用户 RUID。<br>如果当前用户是超级用户，则将设置真实用户号（UID）、有效用户号 EUID 为指定 ID，并返回 <code>0</code> 以标识成功。<br>如果当前用户是普通用户，且欲设置的 UID 值为自己的 UID，则可以修改成功，否则无权修改，函数将返回 <code>-1</code> 。<br><code>setgid</code> 类似。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">seteuid</span><span class="token punctuation">(</span>uid_t euid<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">setegid</span><span class="token punctuation">(</span>gid_t egid<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>设置进程有效用户 EUID<br>如果是超级用户，将设置有效用户号（EUID）为指定 ID。如果调用成功，该函数将返回 <code>0</code> ；如果调用失败，将返回 <code>-1</code> ，并有错误代码设置。<br>如果是普通用户，可以设置 EUID 为自己的 ID，如果想设置为其他用户，则不予更改，返回 <code>-1</code></p><p><code>setegid</code> 类似。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">setreuid</span><span class="token punctuation">(</span>uid_t ruid<span class="token punctuation">,</span> uid_t euid<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">setregid</span><span class="token punctuation">(</span>gid_t rgid<span class="token punctuation">,</span> gid_t egid<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>同时修改 UID/GID 和 EUID/EGID</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">openlog</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>ident<span class="token punctuation">,</span> <span class="token keyword">int</span> option<span class="token punctuation">,</span> <span class="token keyword">int</span> facility<span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><p>打开当前程序与日志守候进程之间的联系<br>第 1 个参数：要向每个消息加入的字符串，一般可设置为为当前进程名<br>第 2 个参数：用来描述已打开选项<br>第 3 个参数：消息的类型，决定将消息写入到哪个日志文件中  </p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">syslog</span><span class="token punctuation">(</span><span class="token keyword">int</span> priority<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>format<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><p>产生一条日志信息，然后由日志守候进程将其发布到各日志文件中<br>第 1 个参数决定日志级别<br>第 2 个参数为日志输出格式，类似于 <code>printf</code> 函数的第 2 个参数  </p><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> pipe <span class="token punctuation">(</span><span class="token keyword">int</span> filedes<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>创建无名管道<br>使用 <code>read</code> 或 <code>write</code> 等函数进行读写操作，不能使用 <code>lseek</code> 函数来修改当前的读写位置，因为管道需要满足 FIFO 的原则。  </p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> dup <span class="token punctuation">(</span><span class="token keyword">int</span> old<span class="token punctuation">)</span><span class="token keyword">int</span> dup2 <span class="token punctuation">(</span><span class="token keyword">int</span> old<span class="token punctuation">,</span> <span class="token keyword">int</span> new<span class="token punctuation">)</span></code></pre><p>复制文件描述符</p><pre class="language-c" data-language="c"><code class="language-c">FILE <span class="token operator">*</span><span class="token function">popen</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>command<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">pclose</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>流重定向  </p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> mkfifo <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">,</span> mode_t mode<span class="token punctuation">)</span></code></pre><p>创建有名管道<br><code>filename</code> 为要创建的管道文件名<br><code>mode</code> 为生成文件的权限<br>在通过 <code>write</code> 和 <code>read</code> 系统调用来执行读写操作前，需要调用 <code>open()</code> 函数打开该文件<br>操作有名管道的阻塞位置为 open 位置，而不是无名管道的读写位置。</p><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">kill</span><span class="token punctuation">(</span>pid_t pid<span class="token punctuation">,</span> <span class="token keyword">int</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>第 1 个参数为要传递信号的进程号<br>第 2 个参数为发送的信号值<br><code>pid</code> 可以取以下几种值：  </p><ul><li>pid &gt; 0：将信号发送给进程的 PID 值为 <code>pid</code> 的进程。</li><li>pid = 0：将信号发送给和当前进程在同一进程组的所有进程。</li><li>pid = -1：将信号发送给系统内的所有进程。</li><li>pid &lt; 0：将信号发送给进程组号 PGID 为 <code>pid</code> 绝对值的所有进程。</li></ul><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">raise</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>给当前进程发送一个信号</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">alarm</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> seconds<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在多少时间（秒为单位）内发送 <code>SIGALRM</code> 信号给当前进程，默认情况下，当进程接收到 <code>alarm</code> 信号后将终止执行。  </p><ul><li>如果 <code>sec</code> 为 <code>0</code>，则取消所有先前发出的报警请求。</li><li>如果在调用 <code>alarm()</code> 函数前没有调用过 <code>alarm()</code> 函数，则执行成功返回值 <code>0</code>，否则返回<code>-1</code>，并设置 <code>errno</code> 标识错误。</li><li>如果在此前调用过 <code>alarm()</code> 函数，则将重新设置调用进程的闹钟。如果执行成功，将以当前时间为基准，返回值为上次设置的 <code>alarm()</code> 将在多少时间内产生 <code>SIGALRM</code> 信号。如果执行失败返回<code>-1</code>，并设置 <code>errno</code> 标识错误。</li></ul><pre class="language-c" data-language="c"><code class="language-c">useconds_t <span class="token function">ualarm</span><span class="token punctuation">(</span>useconds_t usecs<span class="token punctuation">,</span> useconds_t interval<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>使当前进程在指定时间（第 1 个参数，以 us 为单位）内产生 <code>SIGALRM</code> 信号，然后每隔指定时间（第 2 个参数，以 us 为单位）重复产生 <code>SIGALRM</code> 信号。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">getitimer</span><span class="token punctuation">(</span><span class="token keyword">int</span> which<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">itimerval</span> <span class="token operator">*</span>curr_value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">setitimer</span><span class="token punctuation">(</span><span class="token keyword">int</span> which<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">itimerval</span> <span class="token operator">*</span>new_value<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">itimerval</span> <span class="token operator">*</span>old_value<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>getitimer()</code> 和 <code>setitimer()</code> 根据逝去时间、在用户空间执行时间、总的执行时间来设置／读出超时定时器信息，定时器将在超时后产生相应的信号。</p><pre class="language-c" data-language="c"><code class="language-c">sighandler_t signal <span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">,</span> sighandler_t action<span class="token punctuation">)</span></code></pre><p>安装信号处理函数<br>第 1 个参数 <code>signum</code> 为接收到的信号<br>第 2 个参数为接收到此信号后的处理代码入口或下面几个宏：  </p><ul><li><code>SIG_ERR</code>: 返回错误</li><li><code>SIG_DFL</code>: 执行信号默认操作</li><li><code>SIG_IGN</code>: 忽略信号</li></ul><p>如果执行成功，此函数将返回针对此信号的上一次设置，如果设置多次，最终生效者为最近一次设置操作。如果执行失败，将返回 <code>SIG_ERR</code> 错误。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> sigaction <span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> <span class="token operator">*</span>restrict action<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sigaction</span> <span class="token operator">*</span>restrict old<span class="token operator">-</span>action<span class="token punctuation">)</span></code></pre><p>第 1 个参数为接收到的信号<br>第 2 个参数用来指定欲设置的信号处理方式<br>第 3 个参数将存储执行此函数前针对此信号的安装信息<br>第 2、3 个参数均为信号结构 <code>sigaction</code> 变量。  </p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sigprocmask</span><span class="token punctuation">(</span><span class="token keyword">int</span> how<span class="token punctuation">,</span> <span class="token keyword">const</span> sigset_t <span class="token operator">*</span>set<span class="token punctuation">,</span> sigset_t <span class="token operator">*</span>oldset<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>设置当前进程屏蔽的信号集合<br>第 1 个参数为更改该集的方式：</p><ul><li><code>SIG_BLOCK</code>：将第 2 个参数所描述的集合添加到当前进程屏蔽的信号集中</li><li><code>SIG_UNBLOCK</code>：将第 2 个参数所描述的集合从当前进程屏蔽的信号集中删除</li><li><code>SIG_SETMASK</code>：无论之前屏蔽了哪些信号，设置当前进程屏蔽的集合为第 2 个参数描述的对象</li></ul><p>如果 <code>set</code> 是空指针，则参数 <code>how</code> 的值没有意义，且不会更改进程的屏蔽信号集，因此该调用可用于查询当前屏蔽的信号集合 ( <code>oldset</code> )</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> sigpending <span class="token punctuation">(</span>sigset_t <span class="token operator">*</span>set<span class="token punctuation">)</span></code></pre><p>获取当前未决的信号集合</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sigaddset</span><span class="token punctuation">(</span>sigset_t <span class="token operator">*</span>set<span class="token punctuation">,</span> <span class="token keyword">int</span> signum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">sigdelset</span><span class="token punctuation">(</span>sigset_t <span class="token operator">*</span>set<span class="token punctuation">,</span> <span class="token keyword">int</span> signum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">sigemptyset</span><span class="token punctuation">(</span>sigset_t <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">sigfillset</span><span class="token punctuation">(</span>sigset_t <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">sigismember</span><span class="token punctuation">(</span><span class="token keyword">const</span> sigset_t <span class="token operator">*</span>set<span class="token punctuation">,</span> <span class="token keyword">int</span> signum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">sigisemptyset</span><span class="token punctuation">(</span><span class="token keyword">const</span> sigset_t <span class="token operator">*</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">sigandset</span><span class="token punctuation">(</span>sigset_t <span class="token operator">*</span>dest<span class="token punctuation">,</span> <span class="token keyword">const</span> sigset_t <span class="token operator">*</span>left<span class="token punctuation">,</span> <span class="token keyword">const</span> sigset_t <span class="token operator">*</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">sigorset</span><span class="token punctuation">(</span>sigset_t <span class="token operator">*</span>dest<span class="token punctuation">,</span> <span class="token keyword">const</span> sigset_t <span class="token operator">*</span>left<span class="token punctuation">,</span> <span class="token keyword">const</span> sigset_t <span class="token operator">*</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>添加信号到信号集<br>从信号集中删除某个信号<br>清空信号集<br>填充所有信号到信号集<br>检测信号是否在信号集中<br>检测信号集是否为空信号集<br>按逻辑与方式将两个信号集合并<br>按逻辑或方式将两个信号集合并</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pause</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>使当前进程处于等待状态，直到当前进程屏蔽信号外的任意一个信号出现  </p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sigsuspend</span><span class="token punctuation">(</span><span class="token keyword">const</span> sigset_t <span class="token operator">*</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>将当前进程屏蔽的信号集替换为其参数所指定的信号集合，直到收到一个非指定集合中的信号后继续执行  </p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><pre class="language-c" data-language="c"><code class="language-c">key_t <span class="token function">ftok</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pathname<span class="token punctuation">,</span> <span class="token keyword">int</span> proj_id<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>创建 IPC KEY<br><code>pathname</code> 为文件路径，一般使用当前目录 <code>.</code></p><p><code>proj_id</code> 为一个 int 型变量</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">msgget</span><span class="token punctuation">(</span>key_t key<span class="token punctuation">,</span> <span class="token keyword">int</span> msgflg<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>创建消息队列<br>第 1 个参数 <code>key</code> 为由 <code>ftok</code> 创建的 key 值<br>第 2 个参数 <code>msgflg</code> 的低位用来确定消息队列的访问权限，其最终权限为 <code>perm &amp; ~umask</code> , 其高位包含以下项：</p><ul><li><code>IPC_CREAT</code>: 如果 key 不存在则创建，存在则返回 ID</li><li><code>IPC_EXCL</code>: 如果 key 存在，返回失败</li><li><code>IPC_NOWAIT</code>: 如果需要等待，直接返回错误</li></ul><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">msgctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> msqid<span class="token punctuation">,</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">msqid_ds</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>消息队列属性控制<br>第 1 个参数 <code>msqid</code> 为消息队列标识符，该值为使用 <code>msgget</code> 函数创建消息队列的返回值<br>第 2 个参数 <code>cmd</code> 为执行的控制命令，包括以下选项：</p><ul><li><code>IPC_STAT</code>：读取消息队列属性。取得此队列的 <code>msqid _ds</code> 结构，并将其存放在 <code>buf</code> 指向的结构中</li><li><code>IPC_SET</code>：设置消息队列属性。按由 <code>buf</code> 指向的结构中的值，设置与此队列相关的结构中的下列 4 个字段：<code>msg_perm.uid</code>、<code>msg_perm.gid</code>、<code>msg_perm、mode</code> 和 <code>msg_qbytes</code>。此命令只能由下列两种进程执行：一种是其有效用户 ID 等于 <code>msg_perm.cuid</code> 或 <code>msg_perm.uid</code> 的进程，另一种是具有超级用户特权的进程。只有超级用户才能增加 <code>msg_qbytes</code> 的值。</li><li><code>IPC_RMID</code>：删除消息队列。从系统中删除该消息队列以及仍在该队列上的所有数据，这种删除立即生效。仍在使用这一消息队列的其他进程在它们下一次试图对此队列进行操作时，将出错返回 <code>EIDRM</code>。此命令只能由下列两种进程执行：一种是其有效用户号（UID）等于 <code>msg_perm.cuid</code> 或 <code>msg_perm.uid</code> 的进程，另一种是具有超级用户特权的进程。</li><li><code>IPC_INFO</code>：读取消息队列基本情况。  </li></ul><blockquote><p>这 4 条选项（ <code>IPC_STAT</code> 、 <code>IPC_SET</code> 、 <code>IPC_INFO</code> 和 <code>IPC_RMID</code> ）也可用于信号量和共享内存  </p></blockquote><p>第 3 个参数是一个临时的 <code>msqid_ds</code> 结构体类型的变量。用于存储读取的消息队列属性或者需要修改的消息队列属性。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">msgsnd</span><span class="token punctuation">(</span><span class="token keyword">int</span> msqid<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>msgp<span class="token punctuation">,</span> size_t msgsz<span class="token punctuation">,</span> <span class="token keyword">int</span> msgflg<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>发送信息到消息队列<br>第 1 个参数 <code>msqid</code> 为指定的消息队列标识符（由 <code>msgget</code> 生成的消息队列标识符）<br>第 2 个参数 <code>msgp</code> 指向的用户定义缓冲区，结构为：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">msgbuf</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">long</span> mtype<span class="token punctuation">;</span>       <span class="token comment">/* message type, must be > 0 */</span>    <span class="token keyword">char</span> mtext<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">/* message data */</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><ul><li><code>mtype</code> 是一个正整数，表示消息的类型，接收进程可以用来进行消息选择（消息队列在存储信息时是按发送的先后顺序放置的）</li><li><code>mtext</code> 存储消息内容，在使用时自己重新定义此结构</li></ul><p>第 3 个参数为接收信息的大小，其数据类型为 <code>size_t</code> ，即 unsigned int 类型。其大小为 0 到系统对消息队列的限制值<br>第 4 个参数用来指定在达到系统为消息队列所定的界限（如达到字数限制）时应采取的操作：  </p><ul><li><code>IPC_NOWAIT</code>：如果需要等待，则不发送消息并且调用进程立即返回错误信息 <code>EAGAIN</code></li><li><code>0</code>：如果需要等待，则阻塞调用进程</li></ul><pre class="language-c" data-language="c"><code class="language-c">ssize_t <span class="token function">msgrcv</span><span class="token punctuation">(</span><span class="token keyword">int</span> msqid<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>msgp<span class="token punctuation">,</span> size_t msgsz<span class="token punctuation">,</span> <span class="token keyword">long</span> msgtyp<span class="token punctuation">,</span> <span class="token keyword">int</span> msgflg<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>从消息队列接收信息<br>第 1 个参数为读的消息队列<br>第 2 个参数为一个临时消息数据结构，用来保存读取的信息。其定义 <code>msgbuf</code> 如上<br>第 3 个参数 <code>msgsz</code> 用于指定 <code>mtext</code> 的大小（以字节为单位）<br>第 4 个参数 <code>msgtyp</code> 用于指定请求的消息类型，具体如下所示：</p><ul><li><code>msgtyp</code> = 0：接收队列中的第一条消息，任意类型</li><li><code>msgtyp</code> &gt; 0：接收第一条 <code>msgtyp</code> 类型的消息</li><li><code>msgtyp</code> &lt; 0：接收第一条最低类型（小于或等于 <code>msgtyp</code> 的绝对值）的消息</li></ul><p>第 5 个参数 <code>msgflg</code> 用于指定所需类型消息不在队列上时将要采取的操作。具体如下所示：</p><ul><li>如果设置 <code>IPC_NOWAIT</code>，如果现在没有消息，调用进程立即返回，同时返回<code>-1</code>，并将 <code>errno</code> 设为<code>ENOMSG</code>  </li><li>如果未设置 <code>IPC_NOWAIT</code>，则阻塞调用进程行，直至出现以下任何一种情况发生  <ul><li>某一所需类型的消息被放置到队列中</li><li><code>msqid</code> 从系统中删除。当该情况发生时，将 <code>errno</code> 设为<code>EIDRM</code>，并返回<code>-1</code></li><li>调用进程收到一个要捕获的信号。在这种情况下，未收到消息，并且调用进程按 <code>signal (SIGTRAP)</code>中指定方式恢复执行</li></ul></li></ul><p>返回接收到的消息大小</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">semget</span><span class="token punctuation">(</span>key_t key<span class="token punctuation">,</span> <span class="token keyword">int</span> nsems<span class="token punctuation">,</span> <span class="token keyword">int</span> semflg<span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre><p>创建信号量集合<br>第 1 个参数为 <code>key_t</code> 类型的 <code>key</code> 值<br>第 2 个参数 <code>nsems</code> 为创建的信号量个数，以数组的方式存储<br>第 3 个参数 <code>semflg</code> 用来标识信号量集合的权限，与消息队列的相同  </p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">semctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> semid<span class="token punctuation">,</span> <span class="token keyword">int</span> semnum<span class="token punctuation">,</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>第 1 个参数 <code>semid</code> 为要操作的信号量集合标识符，该值一般由 <code>semget</code> 函数返回<br>第 2 个参数为集合中信号量的编号。如果标识某个信号量，此值为该信号量的下标（从 <code>0</code> 到 <code>n-1</code> ）；如果操作整个信号量集合，此参数无意义。<br>第 3 个参数为要执行的操作，如果是对整个信号量集合操作，则包括 <code>IPC_RMID</code> 、 <code>IPC_SET</code> 、 <code>IPC_STAT</code> 和 <code>IPC_INFO</code> 。如果是对信号量集合中的某个或某些信号量操作，则包括：</p><ul><li><code>GETPID</code>: 获取信号量拥有者的 <code>pid</code></li><li><code>GETVAL</code>: 获取信号量的值</li><li><code>GETALL</code>: 获取所有信号量的值，第 2 个参数为 <code>0</code>，第 4 个参数为存储所有信号量值内存空间首地址</li><li><code>GETNCNT</code>: 获取等待信号量的值递增的进程数</li><li><code>GETZCNT</code>: 获取等待信号量的值递减的进程数</li><li><code>SETVAL</code>: 设置信号量的值</li><li><code>SETALL</code>: 设置所有信号量的值，第 2 个参数为 <code>0</code>，第 4 个参数为欲设置的信号量值所在数组首地址</li></ul><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">semop</span><span class="token punctuation">(</span><span class="token keyword">int</span> semid<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sembuf</span> <span class="token operator">*</span>sops<span class="token punctuation">,</span> size_t nsops<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>操作信号量集合<br>第 1 个参数为要操作的信号量集合 ID<br>第 2 个参数为 struct <code>sembuf</code> 结构的变量  </p><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">shmget</span><span class="token punctuation">(</span>key_t key<span class="token punctuation">,</span> size_t size<span class="token punctuation">,</span> <span class="token keyword">int</span> shmflg<span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre><p>创建共享内存<br>第 1 个参数为 <code>key_t</code> 类型的 <code>key</code> 值<br>第 2 个参数 <code>size</code> 为欲创建的共享内存段大小（单位为字节）<br>第 3 个参数 <code>shmflg</code> 用来标识共享内存段的创建标识，包括： <code>IPC_CREAT</code>  <code>IPC_EXCL</code>  <code>IPC_NOWAIT</code>  <code>SHM_R</code> （可读） <code>SHM_W</code> （可写）</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">shmctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> shmid<span class="token punctuation">,</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">shmid_ds</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>  </code></pre><p>共享内存控制<br>第 1 个参数为要操作的共享内存标识符，该值一般由 shmget 函数返回<br>第 2 个参数为要执行的操作，包括 <code>IPC_RMID</code> 、 <code>IPC_SET</code> 、 <code>IPC_STAT</code> 和 <code>IPC_INFO</code></p><p>第 3 个参数为 struct <code>shmid_ds</code> 结构的临时共享内存变量信息，此内容根据第 2 个参数的不同而改变  </p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">shmat</span><span class="token punctuation">(</span><span class="token keyword">int</span> shmid<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>shmaddr<span class="token punctuation">,</span> <span class="token keyword">int</span> shmflg<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>映射共享内存对象<br>将一个共享内存段映射到调用进程的数据段中，并返回该内存空间首地址<br>第 1 个参数 <code>shmid</code> 为要操作的共享内存标识符，该值一般由 <code>shmget</code> 函数返回<br>第 2 个参数 <code>shmaddr</code> 指定共享内存的映射地址。如果该值为非零，则将用此值作为映射共享内存的地址，如果此值为 <code>0</code> ，则由系统来选择映射的地址。一般都将此值设置为 <code>0</code></p><p>第 3 个参数用来指定共享内存段的访问权限和映射条件： <code>0</code> （读写） <code>SHM_RND</code>  <code>SHM_EXEC</code>  <code>SHM_RDONLY</code>  <code>SHM_REMAP</code></p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">shmdt</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>shmaddr<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>分离共享内存对象</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span>pthread_t <span class="token operator">*</span>thread<span class="token punctuation">,</span> <span class="token keyword">const</span> pthread_attr_t <span class="token operator">*</span>attr<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>start_routine<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>第 1 个参数用来存储线程 ID，参数为指向线程 ID 的指针，线程的 ID 在某个进程中是唯一的。如果创建成功，在此参数中返回新线程 ID；如果设置为 <code>NULL</code> ，则不会返回生成的线程的标识值<br>第 2 个参数用来设置线程属性，一般设置为 <code>NULL</code> ，新的线程将使用系统默认的属性<br>第 3 个参数是线程运行的代码起始地址<br>第 4 个参数是运行函数的参数地址。如果需要传入多个参数，则需要使用一个包含这些参数的结构体地址  </p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>retval<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>结束一个线程，与进程调用 <code>exit()</code> 函数类似。参数为线程退出状态</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pthread_join</span><span class="token punctuation">(</span>pthread_t thread<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span>retval<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>等待某线程结束，此函数将阻塞调用当前线程的线程，直到目标线程退出<br>第 1 个参数为被等待的线程 ID，此线程必须同调用它的进程相联系，而不能是独立的线程，默认情况下线程为关联线程，如果要设置某个线程为独立线程，则可以调用 <code>pthread_detach()</code> 函数<br>第 2 个参数为一个用户定义的指针，指向一个保存等待线程的完整退出状态的静态区域，它可以用来存储被等待线程的返回值  </p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">pthread_cleanup_push</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>routine<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">pthread_cleanup_pop</span><span class="token punctuation">(</span><span class="token keyword">int</span> execute<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>线程取消时自动释放资源，采用先入后出的栈结构管理<br><code>routine</code> 是要执行的清理函数， <code>arg</code> 为函数参数<br><code>execute</code> 表示执行到 <code>pthread_cleanup_pop()</code> 时，是否在弹出清理函数的同时执行该函数， <code>0</code> 表示不执行；非 <code>0</code> 为执行。  </p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pthread_cancel</span><span class="token punctuation">(</span>pthread_t thread<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>取消线程<br>一个线程能够被取消并终止执行需要满足以下条件：  </p><ul><li>线程是否可以被其他取消，默认可以被取消。</li><li>线程处于可取消点才能取消。也就是说，即使该线程被设置为可以取消状态，另一个线程发起取消操作，该线程也不是一定马上终止，只能在可取消点才终止执行。可以设置线程为立即取消或只能在取消点被取消。</li></ul><p>执行取消操作时，将调用线程的 <code>pthread_cleanup_push</code> 函数。 <code>pthread_cancel()</code> 的调用者不会等待目标线程操作完成。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pthread_setcancelstate</span><span class="token punctuation">(</span><span class="token keyword">int</span> state<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>oldstate<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">pthread_setcanceltype</span><span class="token punctuation">(</span><span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>oldtype<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>设置和查询当前线程的可取消性状态或类型</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pthread_key_create</span><span class="token punctuation">(</span>pthread_key_t <span class="token operator">*</span>key<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>destructor<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>创建线程私有数据<br>该函数从 TSD 池中分配一项，将其地址值赋给 <code>key</code> 供以后访问使用。如果第 2 个参数不为空，在线程退出（调用 <code>pthread_exit()</code> 函数）时将以 <code>key</code> 所关联的数据为参数调用其指向的资源释放函数，以释放分配的缓冲区。<br>不论哪个线程调用 <code>pthread_key_create()</code> ，所创建的 <code>key</code> 都是所有线程可访问的，但各个线程可根据自己的需要往 <code>key</code> 中填入不同的值，相当于提供了一个同名而不同值的全局变量。  </p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pthread_key_delete</span><span class="token punctuation">(</span>pthread_key_t key<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>注销一个 TSD<br>不检查当前是否有线程正使用该 TSD，也不会调用清理函数（destr_function），只是将 TSD 释放以供下一次调用 <code>pthread_key_create()</code> 使用  </p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pthread_setspecific</span><span class="token punctuation">(</span>pthread_key_t key<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">pthread_getspecific</span><span class="token punctuation">(</span>pthread_key_t key<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>读写线程私有数据<br><code>pthread_setspecific()</code> 将 <code>value</code> 的值（不是所指的内容）与 <code>key</code> 相关联<br><code>pthread_getspecific()</code> 函数将与 <code>key</code> 相关联的数据读出来<br>数据类型都设为 <code>void*</code> ，因此可以指向任何类型的数据</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span>pthread_mutex_t <span class="token operator">*</span>restrict mutex<span class="token punctuation">,</span> <span class="token keyword">const</span> pthread_mutexattr_t <span class="token operator">*</span>restrict attr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">pthread_mutex_destroy</span><span class="token punctuation">(</span>pthread_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>初始化和销毁互斥锁<br>第 1 个参数 <code>mutex</code> 是指向要初始化的互斥锁的指针<br>第 2 个参数 <code>attr</code> 是指向属性对象的指针，该属性对象定义要初始化的互斥锁的属性。如果该指针为 <code>NULL</code> ，则使用默认的属性  </p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span>pthread_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">pthread_mutex_trylock</span><span class="token punctuation">(</span>pthread_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span>pthread_mutex_t <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>pthread_mutex_lock()</code> 函数以阻塞方式申请互斥锁<br><code>pthread_mutex_trylock()</code> 函数以非阻塞方式申请互斥锁<br><code>pthread_mutex_unlock()</code> 函数用来释放互斥锁  </p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pthread_cond_init</span><span class="token punctuation">(</span>pthread_cond_t <span class="token operator">*</span>restrict cond<span class="token punctuation">,</span> <span class="token keyword">const</span> pthread_condattr_t <span class="token operator">*</span>restrict attr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">pthread_cond_destroy</span><span class="token punctuation">(</span>pthread_cond_t <span class="token operator">*</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>初始化和销毁条件变量<br>第 1 个参数 <code>cond</code> 是指向要初始化或损坏的条件变量的指针。<br>第 2 个参数 <code>cond_attr</code> 是指向属性对象的指针，该属性对象定义要初始化的条件变量的特性，如果该指针为 <code>NULL</code> ，则使用默认的属性。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pthread_cond_signal</span><span class="token punctuation">(</span>pthread_cond_t <span class="token operator">*</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">pthread_cond_broadcast</span><span class="token punctuation">(</span>pthread_cond_t <span class="token operator">*</span>cond<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>pthread_cond_signal()</code> 函数用来通知等待条件变量的第 1 个线程。<br><code>pthread_cond_broadcast()</code> 函数用来通知等待条件变量的所有线程。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span>pthread_cond_t <span class="token operator">*</span>restrict cond<span class="token punctuation">,</span> pthread_mutex_t <span class="token operator">*</span>restrict mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">pthread_cond_timedwait</span><span class="token punctuation">(</span>pthread_cond_t <span class="token operator">*</span>restrict cond<span class="token punctuation">,</span> pthread_mutex_t <span class="token operator">*</span>restrict mutex<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">timespec</span> <span class="token operator">*</span>restrict abstime<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>pthread_cond_wait()</code> 函数用来阻塞等待某个条件变量<br>第 1 个参数 <code>cond</code> 是指向要等待的条件变量的指针。<br>第 2 个参数 <code>mutex</code> 是指向与条件变量 <code>cond</code> 关联的互斥锁的指针。  </p><p><code>pthread_cond_timedwait()</code> 函数将在指定的时间范围内等待条件变量<br>第 1 个参数 <code>cond</code> 是指向要等待的条件变量的指针。<br>第 2 个参数 <code>mutex</code> 是指向与条件变量 <code>cond</code> 关联的互斥锁的指针。<br>第 3 个参数 <code>abstime</code> 是等待过期时的绝对时间，如果在此时间范围内取到该条件变量函数将返回。该时间为从 1970-1-1 0:0:0 以来的秒数，即为一个绝对时间。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pthread_kill</span><span class="token punctuation">(</span>pthread_t thread<span class="token punctuation">,</span> <span class="token keyword">int</span> sig<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">pthread_sigmask</span><span class="token punctuation">(</span><span class="token keyword">int</span> how<span class="token punctuation">,</span> <span class="token keyword">const</span> sigset_t <span class="token operator">*</span>set<span class="token punctuation">,</span> sigset_t <span class="token operator">*</span>oldset<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Miscellaneous </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KubeEdge 部署记录</title>
      <link href="2020/12/22/KubeEdgeDeployLog/"/>
      <url>2020/12/22/KubeEdgeDeployLog/</url>
      
        <content type="html"><![CDATA[<h2 id="云端-Cloud-Side"><a href="#云端-Cloud-Side" class="headerlink" title="云端 (Cloud Side)"></a>云端 (Cloud Side)</h2><p>此处安装云端的环境是 VMWare 安装 CentOS 7 虚拟机，登录用户为 root 用户</p><p><img src="/images/1608627604874.png" alt="系统环境"></p><h3 id="安装-Kubernetes"><a href="#安装-Kubernetes" class="headerlink" title="安装 Kubernetes"></a>安装 Kubernetes</h3><h4 id="修改-Hostname"><a href="#修改-Hostname" class="headerlink" title="修改 Hostname"></a>修改 Hostname</h4><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/hostname <span class="token comment"># 修改 hostname</span><span class="token function">vim</span> /etc/hosts <span class="token comment"># 将本机 IP 指向 hostname</span></code></pre><h4 id="确认-MAC-地址-和-product-uuid-唯一"><a href="#确认-MAC-地址-和-product-uuid-唯一" class="headerlink" title="确认 MAC 地址 和 product_uuid 唯一"></a>确认 MAC 地址 和 <code>product_uuid</code> 唯一</h4><pre class="language-bash" data-language="bash"><code class="language-bash">ifocnfig -a<span class="token function">cat</span> /sys/class/dmi/id/product_uuid</code></pre><h4 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h4><pre class="language-bash" data-language="bash"><code class="language-bash">systemctl stop firewalldsystemctl disable firewalld</code></pre><h4 id="禁用-SELinux"><a href="#禁用-SELinux" class="headerlink" title="禁用 SELinux"></a>禁用 SELinux</h4><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/selinux/config </code></pre><p>修改其中的 <code>SELINUX=disabled</code></p><h4 id="禁用-SWAP"><a href="#禁用-SWAP" class="headerlink" title="禁用 SWAP"></a>禁用 SWAP</h4><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/fstab</code></pre><p>注释掉 swap:</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#/dev/mapper/centos-swap swap                    swap    defaults        0 0</span></code></pre><h4 id="使桥接流量经过-iptables"><a href="#使桥接流量经过-iptables" class="headerlink" title="使桥接流量经过 iptables"></a>使桥接流量经过 iptables</h4><p>确定内核模块 <code>br_netfilter</code> 已经加载</p><pre class="language-bash" data-language="bash"><code class="language-bash">lsmod <span class="token operator">|</span> <span class="token function">grep</span> br_netfilter</code></pre><p>创建 <code>sysctl</code> 配置</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/sysctl.d/k8s.conf</code></pre><p>加入下面两行内容：</p><pre class="language-conf" data-language="conf"><code class="language-conf">net.bridge.bridge-nf-call-ip6tables &#x3D; 1net.bridge.bridge-nf-call-iptables &#x3D; 1</code></pre><p>载入配置</p><pre class="language-bash" data-language="bash"><code class="language-bash">sysctl --system</code></pre><blockquote><p>准备工作完成后重启一次系统 <code>reboot</code></p></blockquote><h4 id="安装-docker"><a href="#安装-docker" class="headerlink" title="安装 docker"></a>安装 docker</h4><p>此时可以设置代理服务器</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">http_proxy</span><span class="token operator">=</span>http://172.31.1.1:1080<span class="token builtin class-name">export</span> <span class="token assign-left variable">https_proxy</span><span class="token operator">=</span>http://172.31.1.1:1080<span class="token builtin class-name">export</span> <span class="token assign-left variable">no_proxy</span><span class="token operator">=</span><span class="token number">172.31</span>.16.53 <span class="token comment"># 本机 IP</span></code></pre><p>安装 docker</p><pre class="language-bash" data-language="bash"><code class="language-bash">yum update -y <span class="token operator">&amp;&amp;</span> yum <span class="token function">install</span> -y yum-utils device-mapper-persistent-data lvm2yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repoyum update -y <span class="token operator">&amp;&amp;</span> <span class="token function">sudo</span> yum <span class="token function">install</span> -y containerd.io-1.2.13 docker-ce-19.03.11 docker-ce-cli-19.03.11</code></pre><blockquote><p>docker 和 containerd 要使用 <a href="https://kubernetes.io/docs/setup/production-environment/container-runtimes/#docker">官方文档</a> 指定的版本</p></blockquote><p>配置 docker</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> /etc/docker<span class="token function">vim</span> /etc/docker/daemon.json</code></pre><p>加入以下内容：</p><pre class="language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"exec-opts"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"native.cgroupdriver=systemd"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token property">"log-driver"</span><span class="token operator">:</span> <span class="token string">"json-file"</span><span class="token punctuation">,</span>  <span class="token property">"log-opts"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"max-size"</span><span class="token operator">:</span> <span class="token string">"100m"</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  <span class="token property">"storage-driver"</span><span class="token operator">:</span> <span class="token string">"overlay2"</span><span class="token punctuation">,</span>  <span class="token property">"storage-opts"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token string">"overlay2.override_kernel_check=true"</span>  <span class="token punctuation">]</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> -p /etc/systemd/system/docker.service.dsystemctl daemon-reloadsystemctl <span class="token builtin class-name">enable</span> dockersystemctl restart docker</code></pre><h4 id="安装-kubeadm-、-kubelet-和-kubectl"><a href="#安装-kubeadm-、-kubelet-和-kubectl" class="headerlink" title="安装 kubeadm 、 kubelet 和 kubectl"></a>安装 <code>kubeadm</code> 、 <code>kubelet</code> 和 <code>kubectl</code></h4><p>配置源</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/yum.repos.d/kubernetes.repo</code></pre><p>加入以下内容：</p><pre class="language-ini" data-language="ini"><code class="language-ini"><span class="token selector">[kubernetes]</span><span class="token constant">name</span><span class="token attr-value"><span class="token punctuation">=</span>Kubernetes</span><span class="token constant">baseurl</span><span class="token attr-value"><span class="token punctuation">=</span>https://packages.cloud.google.com/yum/repos/kubernetes-el7-\$basearch</span><span class="token constant">enabled</span><span class="token attr-value"><span class="token punctuation">=</span>1</span><span class="token constant">gpgcheck</span><span class="token attr-value"><span class="token punctuation">=</span>1</span><span class="token constant">repo_gpgcheck</span><span class="token attr-value"><span class="token punctuation">=</span>1</span><span class="token constant">gpgkey</span><span class="token attr-value"><span class="token punctuation">=</span>https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg</span><span class="token constant">exclude</span><span class="token attr-value"><span class="token punctuation">=</span>kubelet kubeadm kubectl</span></code></pre><pre class="language-bash" data-language="bash"><code class="language-bash">yum <span class="token function">install</span> -y kubelet kubeadm kubectl --disableexcludes<span class="token operator">=</span>kubernetessystemctl <span class="token builtin class-name">enable</span> kubelet <span class="token operator">&amp;&amp;</span> systemctl start kubelet</code></pre><h4 id="初始化-Master-节点"><a href="#初始化-Master-节点" class="headerlink" title="初始化 Master 节点"></a>初始化 Master 节点</h4><p>生成初始化文件</p><pre class="language-bash" data-language="bash"><code class="language-bash">kubeadm config print init-defaults <span class="token operator">></span> kubeadm-init.yaml</code></pre><p>该文件有两处需要修改：<br>将 <code>advertiseAddress: 1.2.3.4</code> 修改为本机地址<br>将 <code>imageRepository: k8s.gcr.io 修改为 imageRepository: registry.cn-hangzhou.aliyuncs.com/google_containers</code></p><p>修改完成后的文件如下：</p><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> kubeadm.k8s.io/v1beta2<span class="token key atrule">bootstrapTokens</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">groups</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> system<span class="token punctuation">:</span>bootstrappers<span class="token punctuation">:</span>kubeadm<span class="token punctuation">:</span>default<span class="token punctuation">-</span>node<span class="token punctuation">-</span>token  <span class="token key atrule">token</span><span class="token punctuation">:</span> abcdef.0123456789abcdef  <span class="token key atrule">ttl</span><span class="token punctuation">:</span> 24h0m0s  <span class="token key atrule">usages</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> signing  <span class="token punctuation">-</span> authentication<span class="token key atrule">kind</span><span class="token punctuation">:</span> InitConfiguration<span class="token key atrule">localAPIEndpoint</span><span class="token punctuation">:</span>  <span class="token key atrule">advertiseAddress</span><span class="token punctuation">:</span> 172.31.16.53  <span class="token key atrule">bindPort</span><span class="token punctuation">:</span> <span class="token number">6443</span><span class="token key atrule">nodeRegistration</span><span class="token punctuation">:</span>  <span class="token key atrule">criSocket</span><span class="token punctuation">:</span> /var/run/dockershim.sock  <span class="token key atrule">name</span><span class="token punctuation">:</span> centos7vm<span class="token punctuation">-</span>master  <span class="token key atrule">taints</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">effect</span><span class="token punctuation">:</span> NoSchedule    <span class="token key atrule">key</span><span class="token punctuation">:</span> node<span class="token punctuation">-</span>role.kubernetes.io/master<span class="token punctuation">---</span><span class="token key atrule">apiServer</span><span class="token punctuation">:</span>  <span class="token key atrule">timeoutForControlPlane</span><span class="token punctuation">:</span> 4m0s<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> kubeadm.k8s.io/v1beta2<span class="token key atrule">certificatesDir</span><span class="token punctuation">:</span> /etc/kubernetes/pki<span class="token key atrule">clusterName</span><span class="token punctuation">:</span> kubernetes<span class="token key atrule">controllerManager</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token key atrule">dns</span><span class="token punctuation">:</span>  <span class="token key atrule">type</span><span class="token punctuation">:</span> CoreDNS<span class="token key atrule">etcd</span><span class="token punctuation">:</span>  <span class="token key atrule">local</span><span class="token punctuation">:</span>    <span class="token key atrule">dataDir</span><span class="token punctuation">:</span> /var/lib/etcd<span class="token key atrule">imageRepository</span><span class="token punctuation">:</span> registry.cn<span class="token punctuation">-</span>hangzhou.aliyuncs.com/google_containers<span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterConfiguration<span class="token key atrule">kubernetesVersion</span><span class="token punctuation">:</span> v1.20.0<span class="token key atrule">networking</span><span class="token punctuation">:</span>  <span class="token key atrule">dnsDomain</span><span class="token punctuation">:</span> cluster.local  <span class="token key atrule">serviceSubnet</span><span class="token punctuation">:</span> 10.96.0.0/12<span class="token key atrule">scheduler</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></code></pre><p>取消代理服务器</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">http_proxy</span><span class="token operator">=</span><span class="token builtin class-name">export</span> <span class="token assign-left variable">https_proxy</span><span class="token operator">=</span></code></pre><p>下载镜像</p><pre class="language-bash" data-language="bash"><code class="language-bash">kubeadm config images pull --config kubeadm-init.yaml</code></pre><p>执行初始化</p><pre class="language-bash" data-language="bash"><code class="language-bash">kubeadm init --config kubeadm-init.yaml</code></pre><p>执行成功后，会输出以下内容：</p><pre class="language-bash" data-language="bash"><code class="language-bash">Your Kubernetes control-plane has initialized successfully<span class="token operator">!</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>Then you can <span class="token function">join</span> any number of worker nodes by running the following on each as root:kubeadm <span class="token function">join</span> <span class="token number">172.31</span>.16.53:6443 --token abcdef.0123456789abcdef <span class="token punctuation">\</span>    --discovery-token-ca-cert-hash sha256:c8aad7fdc9faa6dddc7d29dfd8af633afe996e07cad2e32617abc358faae4f63</code></pre><p>最后两行需要保存下来， <code>kubeadm join</code> 是 <code>worker</code> 节点加入所需要执行的命令。<br>因为我们是 root 用户，执行以下命令，也可以加入 Shell 配置中。<br><code>KUBECONFIG</code> 即是 <code>Kubernetes</code> 的配置文件，之后安装 <code>KubeEdge</code> 也会用到。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">KUBECONFIG</span><span class="token operator">=</span>/etc/kubernetes/admin.conf</code></pre><p>简单测试<br>此处的 <code>NotReady</code> 是因为网络还没配置。</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ kubectl get nodeNAME               STATUS     ROLES                  AGE     VERSIONcentos7vm-master   NotReady   control-plane,master   5d21h   v1.20.0</code></pre><h4 id="安装网络插件"><a href="#安装网络插件" class="headerlink" title="安装网络插件"></a>安装网络插件</h4><p>网络插件有很多选择，这里使用 Calico</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://docs.projectcalico.org/manifests/calico.yaml<span class="token function">vim</span> calico.yaml</code></pre><p>找到 <code>CALICO_IPV4POOL_CIDR</code> ，修改 value 为 <code>10.96.0.0/12</code></p><p>应用网络配置</p><pre class="language-bash" data-language="bash"><code class="language-bash">kubectl apply -f calico.yaml</code></pre><p>此时查看 node 信息， master 的状态已经是 <code>Ready</code> 了</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ kubectl get nodeNAME               STATUS   ROLES                  AGE     VERSIONcentos7vm-master   Ready    control-plane,master   5d21h   v1.20.0</code></pre><h4 id="安装-Dashoard"><a href="#安装-Dashoard" class="headerlink" title="安装 Dashoard"></a>安装 Dashoard</h4><h5 id="部署-Dashboard"><a href="#部署-Dashboard" class="headerlink" title="部署 Dashboard"></a>部署 Dashboard</h5><pre class="language-bash" data-language="bash"><code class="language-bash">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/deploy/recommended.yaml</code></pre><p>部署完毕后，执行 <code>kubectl get pods --all-namespaces</code> 查看 pods 状态</p><pre class="language-bash" data-language="bash"><code class="language-bash">$ kubectl get pods --all-namespaces <span class="token operator">|</span> <span class="token function">grep</span> dashboardkubernetes-dashboard   dashboard-metrics-scraper-7b59f7d4df-jjpvt   <span class="token number">1</span>/1     Running   <span class="token number">1</span>          5d1hkubernetes-dashboard   kubernetes-dashboard-74d688b6bc-x7fqm        <span class="token number">1</span>/1     Running   <span class="token number">2</span>          5d1h</code></pre><h5 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h5><p>创建一个用于登录 Dashboard 的用户</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> dashboard-adminuser.yaml</code></pre><p>加入以下内容：</p><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> admin<span class="token punctuation">-</span>user  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>system<span class="token punctuation">---</span><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> rbac.authorization.k8s.io/v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRoleBinding<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> admin<span class="token punctuation">-</span>user<span class="token key atrule">roleRef</span><span class="token punctuation">:</span>  <span class="token key atrule">apiGroup</span><span class="token punctuation">:</span> rbac.authorization.k8s.io  <span class="token key atrule">kind</span><span class="token punctuation">:</span> ClusterRole  <span class="token key atrule">name</span><span class="token punctuation">:</span> cluster<span class="token punctuation">-</span>admin<span class="token key atrule">subjects</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">kind</span><span class="token punctuation">:</span> ServiceAccount  <span class="token key atrule">name</span><span class="token punctuation">:</span> admin<span class="token punctuation">-</span>user  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> kube<span class="token punctuation">-</span>system</code></pre><pre class="language-bash" data-language="bash"><code class="language-bash">kubectl apply -f dashboard-adminuser.yaml</code></pre><h5 id="修改-dashboard-服务"><a href="#修改-dashboard-服务" class="headerlink" title="修改 dashboard 服务"></a>修改 dashboard 服务</h5><pre class="language-bash" data-language="bash"><code class="language-bash">kubectl edit <span class="token function">service</span> kubernetes-dashboard -n kubernetes-dashboard</code></pre><p>修改 <code>type: ClusterIP</code> 为 <code>type: NodePort</code> ，并在 <code>ports</code> 下增加 <code>nodePort: 30443</code></p><h5 id="获取-Token"><a href="#获取-Token" class="headerlink" title="获取 Token"></a>获取 Token</h5><pre class="language-bash" data-language="bash"><code class="language-bash">kubectl -n kube-system describe secret <span class="token variable"><span class="token variable">$(</span>kubectl -n kube-system get secret <span class="token operator">|</span> <span class="token function">grep</span> admin-user <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'&#123;print <span class="token variable">$1</span>&#125;'</span><span class="token variable">)</span></span></code></pre><p>可以将 Token 保存下来便于以后登录使用。</p><h5 id="登录-dashboard"><a href="#登录-dashboard" class="headerlink" title="登录 dashboard"></a>登录 dashboard</h5><p>访问 <code>https://172.31.16.53:30443</code> ，选择使用 Token 登录，粘贴刚才得到的 Token 即可进入 Dashboard。</p><h3 id="安装-KubeEdge"><a href="#安装-KubeEdge" class="headerlink" title="安装 KubeEdge"></a>安装 KubeEdge</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://github.com/kubeedge/kubeedge/releases/download/v1.5.0/keadm-v1.5.0-linux-amd64.tar.gz<span class="token function">tar</span> -xzf keadm-v1.5.0-linux-amd64.tar.gz <span class="token operator">&amp;&amp;</span>  <span class="token builtin class-name">cd</span> keadm-v1.5.0-linux-amd64./keadm init --kube-config<span class="token operator">=</span>/etc/kubernetes/admin.conf</code></pre><h2 id="边缘端-Edge-Side"><a href="#边缘端-Edge-Side" class="headerlink" title="边缘端 (Edge Side)"></a>边缘端 (Edge Side)</h2>]]></content>
      
      
      <categories>
          
          <category> Ops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
            <tag> KubeEdge </tag>
            
            <tag> K8S </tag>
            
            <tag> 边缘云 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg 命令整理</title>
      <link href="2020/12/22/ffmpeg/"/>
      <url>2020/12/22/ffmpeg/</url>
      
        <content type="html"><![CDATA[<h3 id="从-MP4-中提取-M4A"><a href="#从-MP4-中提取-M4A" class="headerlink" title="从 MP4 中提取 M4A"></a>从 MP4 中提取 M4A</h3><pre class="language-bash" data-language="bash"><code class="language-bash">ffmpeg -i input.mp4 -vn -c:a copy output.m4a</code></pre><h3 id="无损切割音频"><a href="#无损切割音频" class="headerlink" title="无损切割音频"></a>无损切割音频</h3><p><code>ss</code> : 起始秒<br><code>t</code> : 持续秒数</p><pre class="language-bash" data-language="bash"><code class="language-bash">ffmpeg -ss <span class="token number">5990</span>  -i in.aac -t <span class="token number">181</span> -c copy out.m4a</code></pre><h3 id="输出-YUV4MPEG2"><a href="#输出-YUV4MPEG2" class="headerlink" title="输出 YUV4MPEG2"></a>输出 YUV4MPEG2</h3><pre class="language-bash" data-language="bash"><code class="language-bash">ffmpeg -y -i input.mp4 -pix_fmt yuv420p output.y4m</code></pre><h3 id="视频转图片序列"><a href="#视频转图片序列" class="headerlink" title="视频转图片序列"></a>视频转图片序列</h3><pre class="language-bash" data-language="bash"><code class="language-bash">ffmpeg -i input.mp4 -vf <span class="token assign-left variable">fps</span><span class="token operator">=</span><span class="token number">30</span>/1.001 %0d.jpg <span class="token comment"># 29.97fps 的视频，每帧都取</span>ffmpeg -i input.mp4 -vf <span class="token assign-left variable">fps</span><span class="token operator">=</span><span class="token number">1</span>/60 %0d.png <span class="token comment"># 每 60 帧抽取一幅图片</span></code></pre><h3 id="Opus-转-CAF-封装"><a href="#Opus-转-CAF-封装" class="headerlink" title="Opus 转 CAF 封装"></a>Opus 转 CAF 封装</h3><pre class="language-bash" data-language="bash"><code class="language-bash">ffmpeg -i input.opus -c:a copy output.caf</code></pre>]]></content>
      
      
      <categories>
          
          <category> Codec </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffmpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows 批处理中的变量</title>
      <link href="2020/12/06/windowsBatchVariable/"/>
      <url>2020/12/06/windowsBatchVariable/</url>
      
        <content type="html"><![CDATA[<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p><code>%varname%</code> ，例如 <code>%PATH%</code>  <code>%USERNAME%</code>  <code>%APPDATA%</code> 等</p><h2 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h2><ul><li><code>%CD%</code> : 当前目录，不包含反斜线除非是在驱动器根目录下</li><li><code>%TIME%</code> : <code>HH:MM:SS.mm</code> 格式的系统时间</li><li><code>%DATE%</code> : 本地化的系统日期</li><li><code>%RANDOM%</code> : <code>0~32767</code> 之间的伪随机数</li><li><code>%ERRORLEVEL%</code> : 上一个执行命令的或批处理的错误等级</li><li><code>%CMDEXTVERSION%</code> : <code>cmd.exe</code> 的版本</li><li><code>%CMDCMDLINE%</code> : 启动 <code>cmd.exe</code> 的命令行</li></ul><h2 id="调用参数"><a href="#调用参数" class="headerlink" title="调用参数"></a>调用参数</h2><ul><li><code>%0</code>: bat 文件的路径</li><li><code>%1</code> - <code>%9</code> : 第 1~9 个参数（大于 9 个参数要循环<code>%*</code>获得）</li></ul><h2 id="变量处理"><a href="#变量处理" class="headerlink" title="变量处理"></a>变量处理</h2><ul><li><code>~d</code>: 驱动器号</li><li><code>~p</code>: 文件路径</li><li><code>~dp</code>: 驱动器号+文件路径</li><li><code>~n</code>: 文件名或文件夹名（不含扩展名）</li><li><code>~x</code>: 文件扩展名</li><li><code>~a</code>: 文件属性</li><li><code>~t</code>: 文件修改时间</li><li><code>~s</code>: 扩展短文件名</li><li><code>~z</code>: 文件大小（字节）</li><li><code>~$PATH:1</code> : 在 <code>PATH</code> 环境变量中查找 <code>%1</code> ，返回第一个含有 <code>%1</code> 的路径，如果没有找到，返回空字符串</li></ul><blockquote><p>在批处理中执行命令，需要使用双百分号 <code>%%</code> 转义出一个百分号 <code>%</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Ops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM 汇编笔记</title>
      <link href="2020/11/18/armAssembly/"/>
      <url>2020/11/18/armAssembly/</url>
      
        <content type="html"><![CDATA[<h2 id="GNU-ARM-汇编程序格式"><a href="#GNU-ARM-汇编程序格式" class="headerlink" title="GNU ARM 汇编程序格式"></a>GNU ARM 汇编程序格式</h2><h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><pre class="language-nasm" data-language="nasm"><code class="language-nasm">.section .mysection, <span class="token string">"x"</span>.text.<span class="token keyword">global test</span><span class="token label function">test:</span>    ADD <span class="token register variable">r0</span>, <span class="token register variable">r0</span>, <span class="token register variable">r1</span>    MOV pc, lr.data   <span class="token operator">/</span><span class="token operator">*</span>定义数据段，即程序运行需要用到的数据<span class="token operator">*</span><span class="token operator">/</span><span class="token label function">stack:</span>  .space <span class="token number">4</span><span class="token operator">*</span><span class="token number">512</span>    @分配 <span class="token number">4</span><span class="token operator">*</span><span class="token number">512</span> 大小的数据空间，缺省值为 <span class="token number">0</span>.end                    @汇编文件结束标志，常常省略不用</code></pre><ul><li>在 GNU ARM 汇编语言程序中，以段 <code>section</code> 为单位组织代码。段是相对独立的指令或数据序列，可以具有特定的名称。</li><li><code>a</code>允许段，<code>w</code>可写段，<code>x</code>执行段</li><li>每个 <code>section</code> 段又可以包含代码段 <code>.text</code> 、数据段 <code>.data</code> 及未初始化的数据段 <code>.bss</code> 等子段。</li><li>每一个段以段名为开始，以下一个段名或者文件结尾为结束。</li><li>绝大多数汇编程序只有一个 <code>section</code> 段，可省略<code>.section</code> 的声明。</li></ul><p>只有一个 <code>section</code> 段的简单汇编程序：</p><pre class="language-nasm" data-language="nasm"><code class="language-nasm">.text.<span class="token keyword">global _start</span><span class="token label function">_start:</span>    mov <span class="token register variable">r0</span>,#<span class="token number">9</span>    mov <span class="token register variable">r1</span>,#<span class="token number">15</span>    add <span class="token register variable">r1</span>,<span class="token register variable">r1</span>,<span class="token register variable">r0</span> @<span class="token register variable">r1</span><span class="token operator">=</span><span class="token register variable">r0</span><span class="token operator">+</span><span class="token register variable">r1</span><span class="token label function">stop:</span>    b stop.data<span class="token label function">stack:</span> .space <span class="token number">4</span><span class="token operator">*</span><span class="token number">512</span> @分配 <span class="token number">4</span><span class="token operator">*</span><span class="token number">512</span> 大小的数据空间，缺省值为 <span class="token number">0</span></code></pre><h3 id="语句格式"><a href="#语句格式" class="headerlink" title="语句格式"></a>语句格式</h3><pre class="language-nasm" data-language="nasm"><code class="language-nasm"><span class="token operator">[</span><span class="token operator">&lt;</span>label<span class="token operator">></span>:<span class="token operator">]</span> <span class="token operator">[</span><span class="token operator">&lt;</span>instruction or directive or pseudo<span class="token operator">-</span>instruction<span class="token operator">></span><span class="token operator">]</span> @comment</code></pre><h4 id="标号-label"><a href="#标号-label" class="headerlink" title="标号 (label)"></a>标号 (label)</h4><ul><li>GNU 汇编中，任何以冒号结尾的标识符都被认为是一个标号，而不一定非要在一行的开始。</li><li>在 ARM 汇编中，标号代表它所在的地址，因此也可以当作变量或者函数来使用。</li><li>标号只能由 <code>a～z</code>，<code>A～Z</code>，<code>0～9</code>，<code>.</code>，<code>_</code>等（由点、字母、数字、下划线等组成，除局部标号外，不能以数字开头）字符组成。</li><li>语句标号不能与寄存器名、指令助记符、伪指令（操作）助记符、变量名同名。</li><li>标号可以单独一行，也可以与汇编语句在同一行。</li></ul><p>GNU 汇编语言需要定义入口点。汇编程序的缺省入口是 <code>_start</code> 标号，用户也可以在连接脚本文件中用 <code>ENTRY</code> 标志指明其它入口点，例：</p><pre class="language-nasm" data-language="nasm"><code class="language-nasm">.section .data    <span class="token operator">&lt;</span>initializeddatahere<span class="token operator">></span>.section .bss    <span class="token operator">&lt;</span>uninitializeddatahere<span class="token operator">></span>.section .text.globl _start<span class="token label function">_start:</span>    <span class="token operator">&lt;</span>instructioncodegoeshere<span class="token operator">></span></code></pre><h4 id="操作助记符域-OPERATION"><a href="#操作助记符域-OPERATION" class="headerlink" title="操作助记符域 (OPERATION)"></a>操作助记符域 (OPERATION)</h4><ul><li>操作助记符域可以为指令、伪操作、宏指令或伪指令的助记符。</li><li>ARM 汇编器对大小写敏感，在汇编语言程序设计中，每一条指令的助记符可以全部用大写、或全部用小写，但不允许在一条指令中大、小写混用。</li><li>指令助记符和后面的操作数或操作寄存器之间必须有空格，不可以在这之间使用逗号。</li></ul><h4 id="操作数域-OPERAND"><a href="#操作数域-OPERAND" class="headerlink" title="操作数域 (OPERAND)"></a>操作数域 (OPERAND)</h4><p>操作数域表示操作的对象，操作数可以是常量、变量、标号、寄存器名或表达式，不同对象之间必须用逗号 <code>,</code> 分开，直接操作数前加 <code>#</code> 。<br>其中常量的表示方法如下：</p><ul><li>十进制数以非 0 数字开头，如：<code>123</code> 和 <code>9876</code></li><li>二进制数以 <code>0b</code> 开头，其中字母也可以为大写</li><li>八进制数以 <code>0</code> 开始，如：<code>0456</code>,                           <code>0123</code></li><li>十六进制数以 <code>0x</code> 开头，如：<code>0xabcd</code>,                           <code>0X123f</code></li></ul><h4 id="注释域-COMMENT"><a href="#注释域-COMMENT" class="headerlink" title="注释域 (COMMENT)"></a>注释域 (COMMENT)</h4><p>ARM 汇编使用 <code>@</code> 或者 <code>/*...*/</code> 标注注释。</p><h2 id="ARM-指令的基本格式"><a href="#ARM-指令的基本格式" class="headerlink" title="ARM 指令的基本格式"></a>ARM 指令的基本格式</h2><pre class="language-nasm" data-language="nasm"><code class="language-nasm">opcode &#123;<span class="token operator">&lt;</span>cond<span class="token operator">></span>&#125;&#123;S&#125; <span class="token operator">&lt;</span>Rd<span class="token operator">></span>,<span class="token operator">&lt;</span>Rn<span class="token operator">></span> &#123;,<span class="token operator">&lt;</span>shifter operand2<span class="token operator">></span>&#125;</code></pre><p>其中 <code>&lt;&gt;</code> 中的项是必须的， <code>｛｝</code> 中的项是可选的。<br><code>opcode</code> 表示指令助记符，比如 <code>LDR</code> 、 <code>STR</code> 、 <code>ADD</code> 等。  </p><ul><li><code>cond</code>: 表示执行条件，如 <code>EQ</code>、<code>NE</code> 等。</li><li><code>S</code>: 表示是否影响 <code>CPSR</code> 寄存器的值。</li><li><code>Rd</code>: 表示目标寄存器</li><li><code>Rn</code>: 表示第一个操作数的寄存器</li><li><code>Shifteroperand2</code>: 表示第 2 个操作数</li></ul><h3 id="执行条件码"><a href="#执行条件码" class="headerlink" title="执行条件码"></a>执行条件码</h3><p>几乎所有的 ARM 指令均可包含一个可选的条件码，句法说明中以 <code>&#123;cond&#125;</code> 表示，只有在 CPSR 中的条件码标志满足指定的条件时，带条件码的指令才能执行。并使用后缀 <code>S</code> 来区分是否根据执行结果修改条件码标志。  </p><table><thead><tr><th>操作码 <code>[31:28]</code></th><th>助记符后缀</th><th>标志</th><th>含义</th></tr></thead><tbody><tr><td>0000</td><td>EQ</td><td>Z 置位</td><td>相等</td></tr><tr><td>0001</td><td>NE</td><td>Z 清零</td><td>不等</td></tr><tr><td>0010</td><td>CS/HS</td><td>C 置位</td><td>大于或等于（无符号&gt;=）</td></tr><tr><td>0011</td><td>CC/LO</td><td>C 清零</td><td>小于（无符号&lt;）</td></tr><tr><td>0100</td><td>MI</td><td>N 置位</td><td>负</td></tr><tr><td>0101</td><td>PL</td><td>N 清零</td><td>正或零</td></tr><tr><td>0110</td><td>VS</td><td>V 置位</td><td>溢出</td></tr><tr><td>0111</td><td>VC</td><td>V 清零</td><td>未溢出</td></tr><tr><td>1000</td><td>HI</td><td>C 置位且 Z 清零</td><td>大于（无符号&gt;）</td></tr><tr><td>1001</td><td>LS</td><td>C 清零或 Z 置位</td><td>小于或等于（无符号&lt;=）</td></tr><tr><td>1010</td><td>GE</td><td>N 和 V 相同</td><td>带符号&gt;=</td></tr><tr><td>1011</td><td>LT</td><td>N 和 V 不同</td><td>带符号&lt;</td></tr><tr><td>1100</td><td>GT</td><td>Z 清零且 N 和 V 相同</td><td>带符号&gt;</td></tr><tr><td>1101</td><td>LE</td><td>Z 置位或 N 和 V 不同</td><td>带符号&lt;=</td></tr><tr><td>1110</td><td>AL</td><td>任何</td><td>总是（通常省略）</td></tr></tbody></table><h2 id="ARM-指令的寻址方式"><a href="#ARM-指令的寻址方式" class="headerlink" title="ARM 指令的寻址方式"></a>ARM 指令的寻址方式</h2><p>寻址方式是根据指令中给出的地址码字段来寻找真实操作数地址的方式。ARM 处理器支持的基本寻址方式有：</p><ul><li>立即寻址</li><li>寄存器寻址</li><li>寄存器移位寻址</li><li>寄存器间接寻址</li><li>基址寻址</li><li>多寄存器寻址</li><li>堆栈寻址</li><li>块拷贝寻址</li><li>相对寻址</li></ul><h3 id="立即数寻址"><a href="#立即数寻址" class="headerlink" title="立即数寻址"></a>立即数寻址</h3><p>操作数在指令中直接给出。</p><pre class="language-nasm" data-language="nasm"><code class="language-nasm">MOV <span class="token register variable">R0</span>,#<span class="token number">0xFF</span>ADD <span class="token register variable">R3</span>,<span class="token register variable">R3</span>,#<span class="token number">1</span>AND <span class="token register variable">R8</span>,<span class="token register variable">R7</span>,#<span class="token number">0xff</span></code></pre><blockquote><p>并不是所有的立即数都可以作为第二操作数。有效立即数必须为一个 8 位常数循环右移偶数位间接得到。</p></blockquote><h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><p>所需要的值在寄存器中，指令中地址码给出的是寄存器编<br>号，即寄存器的内容为操作数。</p><pre class="language-nasm" data-language="nasm"><code class="language-nasm">ADD <span class="token register variable">R0</span>,<span class="token register variable">R1</span>,<span class="token register variable">R2</span></code></pre><p>这条指令将 2 个寄存器（R1 和 R2）的内容相加，结果放入第 3 个寄存器 R0 中。必须注意写操作数的顺序，第 1 个是结果寄存器，然后是第一操作数寄存器，最后是第二操作数寄存器。</p><h3 id="寄存器移位寻址"><a href="#寄存器移位寻址" class="headerlink" title="寄存器移位寻址"></a>寄存器移位寻址</h3><p>该方式中，第 2 个寄存器操作数在与第 1 个操作数结合之前，先进行移位操作。</p><pre class="language-nasm" data-language="nasm"><code class="language-nasm">ADD <span class="token register variable">R3</span>,<span class="token register variable">R2</span>,<span class="token register variable">R1</span>,LSL #<span class="token number">3</span></code></pre><p>上述指令中，寄存器 R1 的内容先逻辑左移 3 位，再与寄存器 R2 内容相加，结果放入 R3 中。</p><blockquote><p>移位不额外花费时间，且不影响 R1 的值。</p></blockquote><h4 id="LSL"><a href="#LSL" class="headerlink" title="LSL"></a>LSL</h4><p>逻辑左移 (Logical Shift Left)<br>寄存器中字的低端空出的位补 0。</p><p><img src="/images/1605616942012.png" alt="LSL"></p><h4 id="LSR"><a href="#LSR" class="headerlink" title="LSR"></a>LSR</h4><p>逻辑右移 (Logical Shift Right)<br>寄存器中字的高端空出的位补 0。</p><p><img src="/images/1605616964082.png" alt="LSR"></p><h4 id="ASR"><a href="#ASR" class="headerlink" title="ASR"></a>ASR</h4><p>算术右移 (Arithmetic Shift Right)<br>算术移位的对象是带符号数，若源操作数为正数，则字的高端空出的位补 0。若源操作数为负数，则字的高端空出的位补 1。</p><p><img src="/images/1605617062931.png" alt="ASR"></p><h4 id="ROR"><a href="#ROR" class="headerlink" title="ROR"></a>ROR</h4><p>循环右移 (ROtate Right)<br>从字的最低端移出的位填入字的高端空出的位。</p><p><img src="/images/1605617082040.png" alt="ROR"></p><h4 id="RRX"><a href="#RRX" class="headerlink" title="RRX"></a>RRX</h4><p>扩展为 1 的循环右移 (Rotate Right eXtended by 1 place)<br>操作数右移一位，空位（位 <code>[31]</code> ）用原 <code>C</code> 标志值填充。</p><p><img src="/images/1605617129287.png" alt="RRX"></p><h3 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h3><p>指令中的地址码给出某一通用寄存器的编号。在被指定的寄存器中存放操作数的有效地址，而操作数则存放在存储单元中，即寄存器为地址指针。<br>指令为 <code>LDR</code> / <code>STR</code></p><h3 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h3><p>变址寻址就是将基址寄存器的内容与指令中给出的位移量相加，形成操作数有效地址。变址寻址用于访问基址附近的存储单元，包括基址加偏移和基址加索引寻址。寄存器间接寻址是偏移量为 0 的基址加偏移寻址。</p><h4 id="前索引寻址方式"><a href="#前索引寻址方式" class="headerlink" title="前索引寻址方式"></a>前索引寻址方式</h4><p>基址需加（或减）最大 4KB 的偏移来计算访问的地址。</p><pre class="language-nasm" data-language="nasm"><code class="language-nasm">LDR <span class="token register variable">R0</span>,<span class="token operator">[</span><span class="token register variable">R1</span>,#<span class="token number">4</span><span class="token operator">]</span>       @<span class="token register variable">R0</span> <span class="token operator">&lt;</span><span class="token operator">-</span> <span class="token operator">[</span><span class="token register variable">R1</span><span class="token operator">+</span><span class="token number">4</span><span class="token operator">]</span></code></pre><h4 id="后索引寻址方式"><a href="#后索引寻址方式" class="headerlink" title="后索引寻址方式"></a>后索引寻址方式</h4><p>基址不带偏移作为传送的地址，传送后自动索引。</p><pre class="language-nasm" data-language="nasm"><code class="language-nasm">LDR <span class="token register variable">R0</span>,<span class="token operator">[</span><span class="token register variable">R1</span><span class="token operator">]</span>,#<span class="token number">4</span>      @<span class="token register variable">R0</span> <span class="token operator">&lt;</span><span class="token operator">-</span> <span class="token operator">[</span><span class="token register variable">R1</span><span class="token operator">]</span>                    @<span class="token register variable">R1</span> <span class="token operator">&lt;</span><span class="token operator">-</span> <span class="token register variable">R1</span><span class="token operator">+</span><span class="token number">4</span></code></pre><h4 id="自动变址的前索引寻址"><a href="#自动变址的前索引寻址" class="headerlink" title="自动变址的前索引寻址"></a>自动变址的前索引寻址</h4><p>基址需加（或减）最大 4KB 的偏移来计算访问的地址，同时更新基址寄存器，并不消耗额外时间。</p><pre class="language-nasm" data-language="nasm"><code class="language-nasm">LDR <span class="token register variable">R0</span>,<span class="token operator">[</span><span class="token register variable">R1</span>,#<span class="token number">4</span><span class="token operator">]</span>！    @<span class="token register variable">R0</span> <span class="token operator">&lt;</span><span class="token operator">-</span> <span class="token operator">[</span><span class="token register variable">R1</span><span class="token operator">+</span><span class="token number">4</span><span class="token operator">]</span>                    @<span class="token register variable">R1</span> <span class="token operator">&lt;</span><span class="token operator">-</span> <span class="token register variable">R1</span><span class="token operator">+</span><span class="token number">4</span></code></pre><h4 id="基址加索引寻址"><a href="#基址加索引寻址" class="headerlink" title="基址加索引寻址"></a>基址加索引寻址</h4><p>指令指定一个基址寄存器，再指定另一个寄存器（索引），其值作为位移加到基址上形成存储器地址。</p><pre class="language-nasm" data-language="nasm"><code class="language-nasm">LDR <span class="token register variable">R0</span>,<span class="token operator">[</span><span class="token register variable">R1</span>,<span class="token register variable">R2</span><span class="token operator">]</span>      @<span class="token register variable">R0</span> <span class="token operator">&lt;</span><span class="token operator">-</span> <span class="token operator">[</span><span class="token register variable">R1</span><span class="token operator">+</span><span class="token register variable">R2</span><span class="token operator">]</span></code></pre><h3 id="多寄存器寻址"><a href="#多寄存器寻址" class="headerlink" title="多寄存器寻址"></a>多寄存器寻址</h3><p>该类指令支持批量数据加载/存储，可以一次在一片连续的存储器单元和多个寄存器之间传送数据。常用的加载/存储指令有 <code>LDM</code> （或 <code>STM</code> ）指令，指令格式为：</p><pre class="language-nasm" data-language="nasm"><code class="language-nasm">LDM(STM)    &#123;类型&#125;  基址寄存器&#123;<span class="token operator">!</span>&#125;, 寄存器列表&#123;∧&#125;</code></pre><p><code>LDM</code> （或 <code>STM</code> ）指令用于从由基址寄存器所指示的一片连续存储器到寄存器列表所指示的多个寄存器之间传送数据，该指令的常见用途是将多个寄存器的内容入栈或出栈。</p><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>IA</td><td>每次传送后地址加 4</td></tr><tr><td>IB</td><td>每次传送前地址加 4</td></tr><tr><td>DA</td><td>每次传送后地址减 4</td></tr><tr><td>DB</td><td>每次传送前地址减 4</td></tr><tr><td>FD</td><td>满递减堆栈</td></tr><tr><td>ED</td><td>空递减堆栈</td></tr><tr><td>FA</td><td>满递增堆栈</td></tr><tr><td>EA</td><td>空递增堆栈</td></tr></tbody></table><p><img src="/images/1605661275399.png" alt="数据块传送"></p><p><img src="/images/1605661335233.png" alt="堆栈寻址"></p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><pre class="language-nasm" data-language="nasm"><code class="language-nasm">LDMIA   <span class="token register variable">R0</span>, &#123;<span class="token register variable">R1</span>,<span class="token register variable">R3</span><span class="token operator">-</span><span class="token register variable">R5</span>&#125;      @<span class="token register variable">R1</span> <span class="token operator">&lt;</span><span class="token operator">-</span> <span class="token operator">[</span><span class="token register variable">R0</span><span class="token operator">]</span>, <span class="token register variable">R3</span> <span class="token operator">&lt;</span><span class="token operator">-</span> <span class="token operator">[</span><span class="token register variable">R0</span><span class="token operator">+</span><span class="token number">4</span><span class="token operator">]</span>                            @<span class="token register variable">R4</span> <span class="token operator">&lt;</span><span class="token operator">-</span> <span class="token operator">[</span><span class="token register variable">R0</span><span class="token operator">+</span><span class="token number">8</span><span class="token operator">]</span>, <span class="token register variable">R5</span> <span class="token operator">&lt;</span><span class="token operator">-</span> <span class="token operator">[</span><span class="token register variable">R0</span><span class="token operator">+</span><span class="token number">12</span><span class="token operator">]</span></code></pre><p>由于传送的数据项总是 32 位的字，基址 R0 应该字对准。这条指令将 R0 指向的连续存储单元的内容送到寄存器 R1、R3、R4、R5 中。</p><pre class="language-nasm" data-language="nasm"><code class="language-nasm">LDMIA   <span class="token register variable">R0</span><span class="token operator">!</span>, &#123;<span class="token register variable">R1</span>,<span class="token register variable">R3</span><span class="token operator">-</span><span class="token register variable">R5</span>&#125;     @<span class="token register variable">R1</span> <span class="token operator">&lt;</span><span class="token operator">-</span> <span class="token operator">[</span><span class="token register variable">R0</span><span class="token operator">]</span>, <span class="token register variable">R3</span> <span class="token operator">&lt;</span><span class="token operator">-</span> <span class="token operator">[</span><span class="token register variable">R0</span><span class="token operator">+</span><span class="token number">4</span><span class="token operator">]</span>                            @<span class="token register variable">R4</span> <span class="token operator">&lt;</span><span class="token operator">-</span> <span class="token operator">[</span><span class="token register variable">R0</span><span class="token operator">+</span><span class="token number">8</span><span class="token operator">]</span>, <span class="token register variable">R5</span> <span class="token operator">&lt;</span><span class="token operator">-</span> <span class="token operator">[</span><span class="token register variable">R0</span><span class="token operator">+</span><span class="token number">12</span><span class="token operator">]</span></code></pre><blockquote><p>后缀 <code>!</code> 表示最后的地址写回到 R0 中</p></blockquote><h2 id="常用-ARM-指令"><a href="#常用-ARM-指令" class="headerlink" title="常用 ARM 指令"></a>常用 ARM 指令</h2><blockquote><p>以 <code>#</code> 为前缀，十六进制值以在 <code>#</code> 后加 <code>0x</code> 或 <code>&amp;</code> 表示。</p></blockquote><h3 id="LDR-STR"><a href="#LDR-STR" class="headerlink" title="LDR/STR"></a>LDR/STR</h3><p>加载/存储指令用于在寄存器和存储器之间传送数据，加载指令用于将存储器中的数据传送到寄存器，存储指令则完成相反的操作。</p><pre class="language-nasm" data-language="nasm"><code class="language-nasm">LDR(STR)&#123;条件&#125;      目的寄存器，<span class="token operator">&lt;</span>存储器地址<span class="token operator">></span></code></pre><p>条件后可跟加载模式：</p><ul><li>默认：字数据</li><li><code>T</code>: 用户模式</li><li><code>S</code>: 有符号数</li><li><code>B</code>: 字节数据（Rd<code>[7:0]</code> 有效，Rd<code>[31:8]</code>=0）</li><li><code>H</code>: 半字数据（Rd<code>[15:0]</code> 有效，Rd<code>[31:16]</code>=0）</li></ul><p>存储器地址的形式：</p><table><thead><tr><th>指令格式</th><th>说明</th><th>操作</th></tr></thead><tbody><tr><td><code>LDR &lt;Rd&gt;, [Rn]</code></td><td>零偏移</td><td>Rn 为传送地址，Rd &lt;- [Rn]</td></tr><tr><td><code>LDR &lt;Rd&gt;, [Rn, offset][!]</code></td><td>前索引偏移</td><td>Rd←[Rn+offset]     !=Rn &lt;- Rn+offset</td></tr><tr><td><code>LDR &lt;Rd&gt;, label</code></td><td>程序相对偏移</td><td>偏移量=±4KB 范围</td></tr><tr><td><code>LDR &lt;Rd&gt;, [Rn], offset</code></td><td>后索引偏移</td><td>Rd &lt;- [Rn]    Rn &lt;- Rn+offset</td></tr></tbody></table><h3 id="SWP"><a href="#SWP" class="headerlink" title="SWP"></a>SWP</h3><pre class="language-nasm" data-language="nasm"><code class="language-nasm">SWP&#123;cond&#125;&#123;B&#125;    Rd, Rm, <span class="token operator">[</span>Rn<span class="token operator">]</span></code></pre><p>在寄存器和存储器之间，由一次存储器读和一次存储器写组成的原子操作。完成一个字节或字的交换。</p><pre class="language-nasm" data-language="nasm"><code class="language-nasm">SWP <span class="token register variable">R0</span>,<span class="token register variable">R1</span>,<span class="token operator">[</span><span class="token register variable">R2</span><span class="token operator">]</span>       @<span class="token register variable">R0</span> <span class="token operator">&lt;</span><span class="token operator">-</span> <span class="token operator">[</span><span class="token register variable">R2</span><span class="token operator">]</span>, <span class="token operator">[</span><span class="token register variable">R2</span><span class="token operator">]</span> <span class="token operator">&lt;</span><span class="token operator">-</span> <span class="token register variable">R1</span>SWP <span class="token register variable">R1</span>,<span class="token register variable">R1</span>,<span class="token operator">[</span><span class="token register variable">R2</span><span class="token operator">]</span>       @<span class="token register variable">R1</span> <span class="token operator">&lt;</span><span class="token operator">-</span> <span class="token operator">[</span><span class="token register variable">R2</span><span class="token operator">]</span>, <span class="token operator">[</span><span class="token register variable">R2</span><span class="token operator">]</span> <span class="token operator">&lt;</span><span class="token operator">-</span> <span class="token register variable">R1</span></code></pre><blockquote><p>Rn!=Rm 或 Rd，Rm 可与 Rd 相同，此时 Rd &lt;-&gt; [Rn]<br>字节交换：[Rn] 单元的字节数据 -&gt; Rd（高 24 位清零），Rm 中低 8 位 -&gt; [Rn]</p></blockquote><h3 id="MOV-MVN"><a href="#MOV-MVN" class="headerlink" title="MOV/MVN"></a>MOV/MVN</h3><p>数据传送：</p><pre class="language-nasm" data-language="nasm"><code class="language-nasm">MOV<span class="token operator">[</span><span class="token operator">&lt;</span>cond<span class="token operator">></span><span class="token operator">]</span><span class="token operator">[</span>s<span class="token operator">]</span> <span class="token operator">&lt;</span>Rd<span class="token operator">></span>, <span class="token operator">&lt;</span>op2<span class="token operator">></span></code></pre><p>数据取非传送：</p><pre class="language-nasm" data-language="nasm"><code class="language-nasm">MVN<span class="token operator">[</span><span class="token operator">&lt;</span>cond<span class="token operator">></span><span class="token operator">]</span><span class="token operator">[</span>s<span class="token operator">]</span> <span class="token operator">&lt;</span>Rd<span class="token operator">></span>, <span class="token operator">&lt;</span>op2<span class="token operator">></span></code></pre><blockquote><p>带有 <code>[s]</code> 的指令缺省不更新 CPSR 标志位，需更新时要加上 <code>S</code></p></blockquote><h3 id="算数运算指令"><a href="#算数运算指令" class="headerlink" title="算数运算指令"></a>算数运算指令</h3><table><thead><tr><th>指令格式</th><th>说明</th><th>操作</th></tr></thead><tbody><tr><td><code>ADD[&lt;cond&gt;][s]    Rd,Rn,op2</code></td><td>加法</td><td>Rd &lt;- Rn+op2</td></tr><tr><td><code>ADC[&lt;cond&gt;][s]    Rd,Rn,op2</code></td><td>带进位加法</td><td>Rd &lt;- Rn+op2+C</td></tr><tr><td><code>SUB[&lt;cond&gt;][s]    Rd,Rn,op2</code></td><td>减法</td><td>Rd &lt;- Rn-op2</td></tr><tr><td><code>SBC[&lt;cond&gt;][s]    Rd,Rn,op2</code></td><td>带进位减法</td><td>Rd &lt;- Rn-op2-C</td></tr><tr><td><code>RSB[&lt;cond&gt;][s]    Rd,Rn,op2</code></td><td>逆向减法</td><td>Rd &lt;- op2-Rn</td></tr><tr><td><code>RSC[&lt;cond&gt;][s]    Rd,Rn,op2</code></td><td>带进位逆向减法</td><td>Rd &lt;- op2-Rn-C</td></tr></tbody></table><p>带 <code>s</code> 时，影响 <code>NVCZ</code> 标志，除非 Rd=R15 （异常模式下，恢复标志）  </p><p>对标志 C 的影响：<br><code>ADD</code> / <code>ADC</code> : <code>C=1</code> 有进位， <code>C=0</code> 无进位<br><code>SUB</code> / <code>SBC</code> / <code>RSC</code> : <code>C=1</code> 无借位， <code>C=0</code> 有借位</p><h3 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h3><table><thead><tr><th>指令格式</th><th>说明</th><th>操作</th></tr></thead><tbody><tr><td><code>AND[&lt;cond&gt;][s]   Rd,Rn,op2</code></td><td>逻辑与操作</td><td>Rd &lt;- Rn&amp; op2</td></tr><tr><td><code>ORR[&lt;cond&gt;][s]   Rd,Rn,op2</code></td><td>逻辑或操作</td><td>Rd &lt;- Rn &#124; op2</td></tr><tr><td><code>EOR[&lt;cond&gt;][s]   Rd,Rn,op2</code></td><td>逻辑异或操作</td><td>Rd &lt;- Rn ^ op2</td></tr><tr><td><code>BIC[&lt;cond&gt;][s]   Rd,Rn,op2</code></td><td>位清除</td><td>Rd &lt;- Rn &amp; (op2)</td></tr></tbody></table><blockquote><p><code>AND</code> 运算通常用于某些位置 <code>0</code></p></blockquote><blockquote><p><code>ORR</code> 运算通常用于某些位置 <code>1</code></p></blockquote><blockquote><p><code>EOR</code> 运算通常用于某些位取反</p></blockquote><h3 id="比较运算指令"><a href="#比较运算指令" class="headerlink" title="比较运算指令"></a>比较运算指令</h3><table><thead><tr><th>指令格式</th><th>说明</th><th>操作</th></tr></thead><tbody><tr><td><code>CMP[&lt;cond&gt;]    Rn, op2</code></td><td>两数相减，结果影响标志位</td><td>Rn-op2</td></tr><tr><td><code>CMN[&lt;cond&gt;]    Rn, op2</code></td><td>两数相加，结果影响标志位</td><td>Rn-(-op2)</td></tr><tr><td><code>TST[&lt;cond&gt;]    Rn, op2</code></td><td>位测试指令</td><td>标志 &lt;- Rn &amp; op2</td></tr><tr><td><code>TEQ[&lt;cond&gt;]    Rn, op2</code></td><td>相等测试指令</td><td>标志 &lt;- Rn ^ op2</td></tr></tbody></table><h3 id="分支指令"><a href="#分支指令" class="headerlink" title="分支指令"></a>分支指令</h3><table><thead><tr><th>指令格式</th><th>说明</th><th>操作</th></tr></thead><tbody><tr><td><code>B[&lt;cond&gt;]    label</code></td><td>分支指令</td><td>PC &lt;- label</td></tr><tr><td><code>BL[&lt;cond&gt;]    label</code></td><td>带链接的分支指令</td><td>LR &lt;- PC-4  , PC &lt;- label</td></tr><tr><td><code>BX[&lt;cond&gt;]    Rm</code></td><td>带状态切换的分支指令</td><td>PC &lt;- Rm</td></tr></tbody></table><h3 id="协处理器指令"><a href="#协处理器指令" class="headerlink" title="协处理器指令"></a>协处理器指令</h3><table><thead><tr><th>指令格式</th><th>说明</th><th>操作</th></tr></thead><tbody><tr><td><code>MCR coproc,opcode1,Rd,CRn,CRm&#123;,opcode2&#125;</code></td><td>ARM 寄存器到协处理器寄存器的数据传送指令</td><td>ARM -&gt; 协处理器</td></tr><tr><td><code>MRC coproc,opcode1,Rd,CRn,CRm&#123;,opcode2&#125;</code></td><td>协处理器寄存器到 ARM 寄存器到的数据传送指令</td><td>协处理器 &lt;- ARM</td></tr></tbody></table><ul><li><code>coproc</code>: 协处理器名称（p0-p15）</li><li><code>opc1</code> ：<code>0-7</code> 之间的处理器特定编码。</li><li><code>Rd</code> : 向协处理器传送值的 ARM 核寄存器（r0-r14）</li><li><code>CRn</code> : 目的协处理器寄存器</li><li><code>CRm</code> : 附加源或者目的协处理器寄存器</li><li><code>opc2</code> : <code>0-7</code> 之间的处理器特定编码，缺省为 <code>0</code></li></ul><h3 id="程序状态寄存器读写指令"><a href="#程序状态寄存器读写指令" class="headerlink" title="程序状态寄存器读写指令"></a>程序状态寄存器读写指令</h3><table><thead><tr><th>指令格式</th><th>说明</th><th>操作</th></tr></thead><tbody><tr><td><code>MRS[&lt;cond&gt;]    Rd,psr</code></td><td>读 PSR</td><td>Rd &lt;- psr</td></tr><tr><td><code>MSR[&lt;cond&gt;]    psr_fields,Rm</code></td><td>写 PSR</td><td>psr_fields &lt;- Rm</td></tr><tr><td><code>MSR[&lt;cond&gt;]    psr_fields,#imm_8</code></td><td>写 PSR</td><td>psr_fields &lt;- #imm_8</td></tr></tbody></table><ul><li>Rd ≠ R15</li><li>psr = <code>CPSR</code>/<code>SPSR</code></li><li>fields = <code>f</code>      条件标志位域 PSR<code>[31:24]</code></li><li>fields = <code>s</code>      状态位域 PSR<code>[23:16]</code></li><li>fields = <code>x</code>      扩展位域 PSR<code>[15:8]</code></li><li>fields = <code>c</code>      控制位域 PSR<code>[7:0]</code></li></ul><p><img src="/images/1605689788913.png" alt="PSR"></p><blockquote><p>特权模式下才能写 PSR，不能通过 MSR 指令直接修改 <code>T</code> 位实现 ARM/Thumb 切换，必须使用 <code>BX</code> 指令完成处理器状态的切换。</p></blockquote><h3 id="SWI"><a href="#SWI" class="headerlink" title="SWI"></a>SWI</h3><pre class="language-nasm" data-language="nasm"><code class="language-nasm">SWI<span class="token operator">[</span><span class="token operator">&lt;</span>cond<span class="token operator">></span><span class="token operator">]</span>    immed_24</code></pre><p>产生软中断，处理器进入管理模式</p><h3 id="ADR-ADRL"><a href="#ADR-ADRL" class="headerlink" title="ADR/ADRL"></a>ADR/ADRL</h3><p>将程序相对偏移或寄存器相对偏移地址加载到寄存器中。</p><pre class="language-nasm" data-language="nasm"><code class="language-nasm">ADR<span class="token operator">[</span><span class="token operator">&lt;</span>cond<span class="token operator">></span><span class="token operator">]</span>    Rd, label</code></pre><ul><li><code>label</code> 必须与 <code>ADR</code> 指令在同一个代码段中</li><li>当地址是字对齐时，<code>label</code> 取值范围为 <code>-1024~1024</code> 字节</li><li>当使用 <code>ADRL</code> 指令时，<code>label</code> 取值范围为 <code>-256K~256K</code> 字节</li></ul><h3 id="LDR-伪指令"><a href="#LDR-伪指令" class="headerlink" title="LDR 伪指令"></a>LDR 伪指令</h3><p>用 32 位常量或一个地址加载寄存器</p><pre class="language-nasm" data-language="nasm"><code class="language-nasm">LDR<span class="token operator">[</span><span class="token operator">&lt;</span>cond<span class="token operator">></span><span class="token operator">]</span>    register, <span class="token operator">=</span><span class="token operator">[</span>expr<span class="token operator">|</span>label<span class="token operator">-</span>expr<span class="token operator">]</span></code></pre><ul><li><code>register</code>: 加载的寄存器</li><li><code>expr</code>: 赋值成数字常量</li><li><code>label-expr</code>: 程序相对偏移或外部表达式</li></ul><p>例：</p><pre class="language-nasm" data-language="nasm"><code class="language-nasm">LDR     <span class="token register variable">R3</span>,<span class="token operator">=</span><span class="token number">0xFF0</span>   @把立即数 <span class="token number">0xFF0</span> 赋值给 <span class="token register variable">R3</span>LDR     <span class="token register variable">R3</span>,<span class="token operator">=</span>place   @把标号 place 对应的地址赋值给 <span class="token register variable">R2</span></code></pre><blockquote><p>从指令到文字池的偏移量必须小于 4KB<br>与 ARM 指令的 <code>LDR</code> 相比，伪指令的 <code>LDR</code> 的参数有 <code>=</code> 号</p></blockquote><h3 id="NOP"><a href="#NOP" class="headerlink" title="NOP"></a>NOP</h3><p>空操作，可用于延时操作。</p><h2 id="数据定义伪操作"><a href="#数据定义伪操作" class="headerlink" title="数据定义伪操作"></a>数据定义伪操作</h2><p>数据定义伪操作一般用于为特定的数据分配存储单元，同时可完成已分配存储单元的初始化。</p><table><thead><tr><th>指令</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>.byte</code></td><td>定义单字节</td><td><code>.byte0x12</code> @分配一个字节的空间并初始化为 0x12</td></tr><tr><td><code>.short</code></td><td>定义双字节数据</td><td><code>.short   0x1234</code></td></tr><tr><td><code>.long</code> / <code>.word</code></td><td>定义 4 字节数据</td><td><code>.word    0x12345678</code></td></tr><tr><td><code>.quad</code></td><td>定义 8 字节</td><td><code>.quad  0x1234567812345678</code></td></tr><tr><td><code>.float</code></td><td>定义浮点数</td><td><code>.float   0f3.2</code></td></tr><tr><td><code>.string</code> / <code>.asciz</code> / <code>.ascii</code></td><td>定义字符串</td><td><code>.ascii    &quot;abcd\0&quot;</code></td></tr><tr><td><code>.space</code></td><td>分配任意的字节空间</td><td><code>.space   4*512,35</code> @分配 4*512 字节的内存空间并初始化为 35</td></tr></tbody></table><h2 id="符号定义伪操作"><a href="#符号定义伪操作" class="headerlink" title="符号定义伪操作"></a>符号定义伪操作</h2><h3 id="equ"><a href="#equ" class="headerlink" title=".equ"></a>.equ</h3><p><code>.equ</code> 伪指令用于为程序中的常量、标号等定义一个等效的字符名称，类似于 C 语言中的 <code>＃define</code> 。</p><pre class="language-nasm" data-language="nasm"><code class="language-nasm">.equ        symbol, expr</code></pre><ul><li><code>symbol</code>: 等效字符</li><li><code>expr</code>: 常量或者标号</li></ul><p>例：</p><pre class="language-nasm" data-language="nasm"><code class="language-nasm">.equ    x,<span class="token number">2020</span>      @将 x 定义为数值 <span class="token number">2020</span>.equ    y,_start    @ y<span class="token operator">=</span> 标号 _start 的值</code></pre><blockquote><p>使用等价伪指令 <code>.equ</code> 定义的符号名不会被系统分配存储空间。</p></blockquote><h3 id="global"><a href="#global" class="headerlink" title=".global"></a>.global</h3><p><code>.glabal</code> 伪指令用于在程序中声明一个全局的标号，该标号可在其他的文件中引用。</p><pre class="language-nasm" data-language="nasm"><code class="language-nasm">.<span class="token keyword">global    label</span></code></pre><p>例：</p><pre class="language-nasm" data-language="nasm"><code class="language-nasm">.glabal    _start   @将标号 _start 定义为全局标号</code></pre>]]></content>
      
      
      <categories>
          
          <category> Ops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
            <tag> Assembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 中配置路由</title>
      <link href="2020/10/25/routeCommand/"/>
      <url>2020/10/25/routeCommand/</url>
      
        <content type="html"><![CDATA[<h2 id="查看路由表"><a href="#查看路由表" class="headerlink" title="查看路由表"></a>查看路由表</h2><ul><li><code>netstat -r</code></li><li><code>route</code></li></ul><pre class="language-none"><code class="language-none">Kernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Ifacedefault         _gateway        0.0.0.0         UG    101    0        0 ens224172.31.112.0    0.0.0.0         255.255.240.0   U     101    0        0 ens224192.168.122.0   0.0.0.0         255.255.255.0   U     0      0        0 virbr0192.168.248.0   0.0.0.0         255.255.255.0   U     100    0        0 ens160</code></pre><h3 id="Flags"><a href="#Flags" class="headerlink" title="Flags"></a>Flags</h3><ul><li><code>U</code> : 路由是活动的</li><li><code>H</code> : 目标是一个主机</li><li><code>G</code> : 路由指向网关</li><li><code>R</code> : 恢复动态路由产生的表项</li><li><code>D</code> : 由路由的后台程序动态地安装</li><li><code>M</code> : 由路由的后台程序修改</li><li><code>!</code> : 拒绝路由</li></ul><h3 id="Metric"><a href="#Metric" class="headerlink" title="Metric"></a>Metric</h3><p>路由度量，内核用它来在多条可行路径中选择一条最佳路径。数值越低，优先级越高。</p><h3 id="Iface"><a href="#Iface" class="headerlink" title="Iface"></a>Iface</h3><p>该路由表项对应的输出接口。</p><h2 id="添加路由"><a href="#添加路由" class="headerlink" title="添加路由"></a>添加路由</h2><h3 id="添加到主机的路由"><a href="#添加到主机的路由" class="headerlink" title="添加到主机的路由"></a>添加到主机的路由</h3><pre class="language-sh" data-language="sh"><code class="language-sh">route add -host 192.168.0.4 dev ens160 route add -host 172.31.160.1 gw 172.31.112.1</code></pre><h3 id="添加到网络的路由"><a href="#添加到网络的路由" class="headerlink" title="添加到网络的路由"></a>添加到网络的路由</h3><pre class="language-sh" data-language="sh"><code class="language-sh">route add -net 172.31.112.0 netmask 255.255.255.240 ens224route add -net 192.168.240.0 netmask 255.255.255.0 gw 192.168.240.1route add -net 172.31.112.0&#x2F;20 ens224</code></pre><h3 id="添加默认路由"><a href="#添加默认路由" class="headerlink" title="添加默认路由"></a>添加默认路由</h3><pre class="language-sh" data-language="sh"><code class="language-sh">route add default gw 172.31.161.254 dev ens160</code></pre><h2 id="删除路由"><a href="#删除路由" class="headerlink" title="删除路由"></a>删除路由</h2><pre class="language-sh" data-language="sh"><code class="language-sh">route del -host 192.168.0.4 dev ens160route del -host 172.31.160.1 gw 172.31.112.1route del -net 172.31.112.0 netmask 255.255.255.240 ens224route del -net 192.168.240.0 netmask 255.255.255.0 gw 192.168.240.1route del -net 172.31.112.0&#x2F;20 ens224route del default ens160route del default gw 172.31.161.254</code></pre>]]></content>
      
      
      <categories>
          
          <category> Ops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> route </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给 Windows 驱动签名</title>
      <link href="2020/10/16/signWindowsDrive/"/>
      <url>2020/10/16/signWindowsDrive/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从 Windows 8 开始，微软在操作系统中引入了驱动程序强制签名的安全特性，没有正确签名的驱动将直接无法安装。这毫无疑问的增强了系统的安全性，但同时你可能会遇到老设备装不上驱动、自己修改 <code>INF</code> 文件后校验错误等问题。一个常用的解决方法是禁用驱动程序强制签名，这需要修改引导参数并重新启动系统，而且启动后你会发现屏幕右下角有 <code>Test mode</code> 字样（虽然有办法去除）。最麻烦的是有些游戏厂商<del>miHoYo</del>的反作弊机制会禁止使用测试模式开始游戏，如果你的未签名驱动是阵列卡之类的重要硬件的话，这就很蛋疼了。这时唯一解决办法就是自己给驱动签名，一劳永逸，彻底摆脱测试模式。</p><h2 id="创建证书"><a href="#创建证书" class="headerlink" title="创建证书"></a>创建证书</h2><p>从 Windows PowerShell 3.0 版本（Windows Server 2012、Windows 8 自带）开始你可以执行 <code>New-SelfSignedCertificate</code> 命令来创建自签名证书：</p><pre class="language-powershell" data-language="powershell"><code class="language-powershell"><span class="token variable">$cert</span> = New<span class="token operator">-</span>SelfSignedCertificate <span class="token operator">-</span>DnsName konata<span class="token punctuation">.</span>tech <span class="token operator">-</span><span class="token function">Type</span> CodeSigning <span class="token operator">-</span>CertStoreLocation Cert:\CurrentUser\My<span class="token variable">$CertPassword</span> = ConvertTo<span class="token operator">-</span>SecureString <span class="token operator">-</span>String mypass <span class="token operator">-</span>Force <span class="token operator">-</span>AsPlainTextExport<span class="token operator">-</span>PfxCertificate <span class="token operator">-</span>Cert <span class="token string">"cert:\CurrentUser\My\<span class="token function">$<span class="token punctuation">(</span><span class="token variable">$cert</span><span class="token punctuation">.</span>Thumbprint<span class="token punctuation">)</span></span>"</span> <span class="token operator">-</span>FilePath <span class="token string">"C:\konatacodecer.pfx"</span> <span class="token operator">-</span>Password <span class="token variable">$CertPassword</span></code></pre><h2 id="给驱动签名"><a href="#给驱动签名" class="headerlink" title="给驱动签名"></a>给驱动签名</h2><ol><li><p>下载 <a href="https://www.wosign.com/marketing/2015_WoSign_sign_tools/index.htm">沃通代码签名工具</a>（虽然沃通名声很臭，但这个工具挺好用的）。  </p></li><li><p>打开代码签名工具，选择 <code>CAB/CAT</code> 标签  </p></li><li><p>打开要签名的 <code>INF</code> 文件，将 <code>SourceDisksFiles</code> 等项目内使用到的驱动文件都添加到窗口中  </p></li><li><p>点击创建 <code>CAT</code> 按钮，将 <code>CAT</code> 文件保存到 <code>INF</code> 文件同目录下  </p></li><li><p>点击代码签名标签，选择刚刚生成的 <code>pfx</code> 证书，并输入密码 <code>mypass</code></p></li><li><p>点击签名按钮，完成后可以看到生成的 <code>CAT</code> 文件  </p></li></ol><h2 id="安装证书和驱动"><a href="#安装证书和驱动" class="headerlink" title="安装证书和驱动"></a>安装证书和驱动</h2><p>如果你现在打开上面生成的 <code>CAT</code> 文件，会提示证书目录无效，这是因为我们自己生成的证书还没被信任，需要手动添加证书到信任列表。</p><ol><li>打开第一步生成的 <code>pfx</code> 证书，选择存储位置为 <code>Local Machine</code></li><li>点击下一步输入密码 <code>mypass</code></li><li>点击下一步选择证书存储区域，选择 <code>Place all certificates in the following store</code> ，单击浏览选择 <code>Trusted Root Cerification Authorities</code></li><li>点击下一步完成，我们自己创建的证书就被系统信任了  </li></ol><p>接下来就可以安装驱动了，右键点击 <code>INF</code> 文件选择安装，如果驱动安装成功会显示操作成功完成，这时可以愉快的使用新硬件啦。</p>]]></content>
      
      
      <categories>
          
          <category> Ops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 驱动 </tag>
            
            <tag> 证书 </tag>
            
            <tag> 签名 </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逻辑位移</title>
      <link href="2020/10/11/logicalShift/"/>
      <url>2020/10/11/logicalShift/</url>
      
        <content type="html"><![CDATA[<h2 id="逻辑左移"><a href="#逻辑左移" class="headerlink" title="逻辑左移"></a>逻辑左移</h2><p>左移运算符 <code>&lt;&lt;</code> 是双目运算符。<strong>左移 <code>n</code> 位就是乘以 2 的 <code>n</code> 次方</strong>。 其功能把 <code>&lt;&lt;</code> 左边的运算数的各二进位全部左移若干位，由 <code>&lt;&lt;</code> 右边的数指定移动的位数，高位丢弃，低位补 0。</p><h2 id="逻辑右移"><a href="#逻辑右移" class="headerlink" title="逻辑右移"></a>逻辑右移</h2><p>右移运算符 <code>&gt;&gt;</code> 是双目运算符。<strong>右移 <code>n</code> 位就是除以 2 的 <code>n</code> 次方</strong>。 其功能是把 <code>&gt;&gt;</code> 左边的运算数的各二进位全部右移若干位， <code>&gt;&gt;</code> 右边的数指定移动的位数。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON Web Token</title>
      <link href="2020/10/07/JSONWebToken/"/>
      <url>2020/10/07/JSONWebToken/</url>
      
        <content type="html"><![CDATA[<p>JWT(JSON Web Token) 是一个基于 JSON 的开放标准，用于通信双方之间传递安全信息的简洁的、URL 安全的表述性声明规范，经常用于身份验证。  </p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>JWT 有三部分组成，他们之间用 <code>.</code> 分隔，这三部分分别是 <code>Header</code> 、 <code>Payload</code> 、 <code>Signature</code> ，结构为 <code>Header.Payload.Signature</code><br><a href="https://jwt.io/">示例</a>：  </p><pre class="language-none"><code class="language-none">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</code></pre><p>对于这个例子，其三部分组成分别为：</p><pre class="language-json" data-language="json"><code class="language-json"><span class="token comment">// header</span><span class="token punctuation">&#123;</span>  <span class="token property">"alg"</span><span class="token operator">:</span> <span class="token string">"HS256"</span><span class="token punctuation">,</span>  <span class="token property">"typ"</span><span class="token operator">:</span> <span class="token string">"JWT"</span><span class="token punctuation">&#125;</span><span class="token comment">// Payload</span><span class="token punctuation">&#123;</span>  <span class="token property">"sub"</span><span class="token operator">:</span> <span class="token string">"1234567890"</span><span class="token punctuation">,</span>  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"John Doe"</span><span class="token punctuation">,</span>  <span class="token property">"iat"</span><span class="token operator">:</span> <span class="token number">1516239022</span><span class="token punctuation">&#125;</span><span class="token comment">// Signature</span>HMACSHA<span class="token number">256</span>(  base<span class="token number">64</span>UrlEncode(header) + <span class="token string">"."</span> + base<span class="token number">64</span>UrlEncode(payload)<span class="token punctuation">,</span> <span class="token string">"your-256-bit-secret"</span>)</code></pre><h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><p><code>Header</code> 头部，其由两部分组成：声明类型和算法名称，在本例中的 <code>Token</code> 类型为 <code>jwt</code> ，加密算法为 <code>HMAC-SHA256</code> 。将 <code>Header</code> 进行 <code>BASE64URL</code> 算法编码，即可得到 <code>jwt</code> 的第一部分，注意 <code>BASE64URL</code> 算法编码与 <code>BASE64</code> 编码略有不同， <code>BASE64URL</code> 需要将 <code>BASE64</code> 中输出中的 <code>+</code> 替换为减号 <code>-</code> ， <code>/</code> 替换为 <code>_</code> ，而且没有标准的 <code>BASE64</code> 填充，即把 <code>=</code> 去掉。  </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token function">base64UrlEncode</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    <span class="token string">"alg"</span><span class="token punctuation">:</span> <span class="token string">"HS256"</span><span class="token punctuation">,</span>    <span class="token string">"typ"</span><span class="token punctuation">:</span> <span class="token string">"JWT"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9"</span><span class="token punctuation">;</span></code></pre><h2 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h2><p><code>Payload</code> 有效载荷，其为 <code>JWT</code> 的主体，这里可以存放主体数据信息， <code>Payload</code> 包含三个部分：标准中注册的声明、公共的声明、私有的声明。  </p><h3 id="标准中注册的声明-（建议但不强制使用）"><a href="#标准中注册的声明-（建议但不强制使用）" class="headerlink" title="标准中注册的声明 （建议但不强制使用）"></a>标准中注册的声明 （建议但不强制使用）</h3><ul><li><code>iss</code> : jwt 签发者</li><li><code>sub</code> : jwt 主题</li><li><code>aud</code> : jwt 接收者</li><li><code>exp</code> : jwt 过期时间</li><li><code>nbf</code> : jwt 生效时间</li><li><code>iat</code> : jwt 的签发时间</li><li><code>jti</code> : jwt 的唯一身份标识，避免重放攻击</li></ul><h3 id="公共声明"><a href="#公共声明" class="headerlink" title="公共声明"></a>公共声明</h3><p>可以在公共声明添加任何信息，我们一般会在里面添加用户信息和业务信息，但是不建议添加敏感信息，因为公共声明部分可以在客户端解密，除非此信息是加密的。  </p><h3 id="私有声明"><a href="#私有声明" class="headerlink" title="私有声明"></a>私有声明</h3><p>私有声明是服务器和客户端共同定义的声明，同样这里不建议添加敏感信息。  </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token function">base64UrlEncode</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    <span class="token string">"sub"</span><span class="token punctuation">:</span> <span class="token string">"1234567890"</span><span class="token punctuation">,</span>    <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"John Doe"</span><span class="token punctuation">,</span>    <span class="token string">"iat"</span><span class="token punctuation">:</span> <span class="token number">1516239022</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">"eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ"</span><span class="token punctuation">;</span></code></pre><h2 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h2><p><code>Signature</code> 哈希签名，其通过 JWT 中 <code>Header</code> 定义的算法，将前两部分数据进行编码后哈希来生成签名，主要是确保数据不会被篡改。  </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token constant">HMACSHA256</span><span class="token punctuation">(</span><span class="token function">base64UrlEncode</span><span class="token punctuation">(</span>header<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"."</span> <span class="token operator">+</span> <span class="token function">base64UrlEncode</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"your-256-bit-secret"</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">"SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"</span></code></pre><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>无状态和可拓展性，服务器将 JWT 存储到客户端以后不存在状态或者会话信息，易于拓展</li><li>可以预防 CSRF 攻击，由于使用 JWT 一般放置于请求头的 <code>Authorization: Bearer $&#123;JWT&#125;</code> 字段中而不使用 Cookie 可以有效防止 CSRF 攻击</li><li><code>payload</code> 部分可以存储一些其他业务逻辑所必要的非敏感信息，可以减轻服务端压力</li><li>JWT 的跨语言支持性，由于 json 与加密算法的通用性，在多数语言中都能得到支持</li><li>相对于 OAuth2 更加轻量，但是其应用场景有所区别，OAuth2 是一种授权框架，通常用于第三方应用授权，JWT 是一种认证协议，用于前后端分离的用户认证以及后端 API 的保护</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>一旦签发无法更新，如果想更新数据或者续签，必须重新签发</li><li>无法废弃，在 JWT 设置的过期时间到达之前，JWT 始终有效</li><li><code>payload</code> 是使用 BASE64URL 编码的，并没有加密，因此 JWT 中在未加密的情况下不能存储敏感数据</li><li>JWT 本身包含认证信息，因此一旦信息泄露，任何人都可以获得令牌的所有权限，所以 JWT 的有效期不宜设置太长。</li><li>伪造 JWT，攻击者拥有一个 JWT，可以伪造 <code>Header</code> 中的 <code>alg</code> 为 <code>none</code> 来验证身份，理论上这是符合 JWT 规范要求的，而且有些库中都默认实现此验证，所以需要禁用 <code>alg</code> 为 <code>none</code> 的请求。</li><li>爆破 HMAC 密钥，由于用户可以拿到完整的 JWT，其中就包含加密算法，用户可以根据 JWT 中信息爆破密钥，而且整个操作可以本地完成，不需要与服务端交互。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件冒泡</title>
      <link href="2020/10/04/eventBubble/"/>
      <url>2020/10/04/eventBubble/</url>
      
        <content type="html"><![CDATA[<p>当一个元素接收到事件的时候，会把他接收到的事件传给自己的父级，一直到 <code>window</code> ，当然其传播的是事件，绑定的执行函数并不会传播，如果父级没有绑定事件函数，就算传递了事件，也不会有什么表现，但事件确实传递了。<br>事件冒泡的原因是事件源本身可能没有处理事件的能力，即处理事件的函数并未绑定在该事件源上。它本身并不能处理事件，所以需要将事件传播出去，从而能达到处理该事件的执行函数。  </p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>当点击 <code>id</code> 为 <code>c</code> 的 <code>&lt;div&gt;</code> 时，浏览器会依次弹出 <code>3 2 1</code> ，这就是事件冒泡，此正方形处于叶节点上，对其操作的事件会向上进行冒泡，直到根节点。  </p><pre class="language-html" data-language="html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>事件冒泡<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>a<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">height</span><span class="token punctuation">:</span> 150px<span class="token punctuation">;</span><span class="token property">width</span><span class="token punctuation">:</span> 150px<span class="token punctuation">;</span><span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>b<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span><span class="token property">width</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span><span class="token property">background</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>c<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">height</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span><span class="token property">width</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span><span class="token property">background</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token parameter">e</span> <span class="token operator">=></span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token parameter">e</span> <span class="token operator">=></span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token parameter">e</span> <span class="token operator">=></span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><p>s</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>例如我们有 <code>10</code> 个 <code>&lt;li&gt;</code> 标签，每个标签有一个 <code>uid</code> 作为判断用户点击的区别，使用冒泡就不需要为每个 <code>&lt;li&gt;</code> 绑定点击事件，可以称为事件委托。  </p><pre class="language-html" data-language="html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>事件冒泡<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>u1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">uid</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">uid</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">uid</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">uid</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>3<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">uid</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>4<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">uid</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>5<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"u1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token parameter">e</span> <span class="token operator">=></span> <span class="token function">alert</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>srcElement<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">'uid'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><h2 id="阻止冒泡"><a href="#阻止冒泡" class="headerlink" title="阻止冒泡"></a>阻止冒泡</h2><p>有时候我们并不希望事件冒泡而去执行上级节点绑定的事件，这时候就需要阻止事件的冒泡，W3C 的方法是 <code>e.stopPropagation()</code> ，IE 则是使用 <code>window.event.cancelBubble = true</code> 。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>不是所有的事件都能冒泡。以下事件不冒泡： <code>blur</code> 、 <code>focus</code> 、 <code>load</code> 、 <code>unload</code> 。  </li><li>事件解决方案方式在不同浏览器，可能是有所区别的，有些不支持捕获型方案，多数浏览器默认冒泡型方案。</li><li>阻止冒泡并不能阻止对象默认行为，例如 <code>submit</code> 按钮被点击后会提交表单数据，需使用 <code>e.preventDefault()</code> 阻止默认行为，IE 则是 <code>window.event.returnValue = false</code> 。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XML 与 JSON</title>
      <link href="2020/10/02/jsonAndXml/"/>
      <url>2020/10/02/jsonAndXml/</url>
      
        <content type="html"><![CDATA[<p>XML 与 JSON 都可以用来描述或者存储数据，两者都有各自的优点，使用场景取决于需求。  </p><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><blockquote><p>可扩展标记语言 (Extensible Markup Language)，是一种用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型、存储数据等，是一种允许用户对自己的标记语言进行定义的源语言，并提供统一的方法来描述和交换独立于应用程序或供应商的结构化数据。 XML 基于标准通用标记语言 SGML 与超文本标记语言 HTML 发展而来，使用 DTD 文档类型定义 (Document Type Definition) 来组织数据，格式统一，跨平台和语言，目前的版本标准为 XML 1.0。  </p></blockquote><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><blockquote><p>JSON 即 (JavaScript Object Notation)，是一种轻量级的数据交换格式，其是 ECMAScript 规范的一个子集，采用兼容性很高的、完全独立于编程语言的文本格式来存储和表示数据，简洁和清晰的层次结构使得 JSON 成为比较理想的数据交换语言，易于阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</p></blockquote><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><h3 id="可读性"><a href="#可读性" class="headerlink" title="可读性"></a>可读性</h3><p>可读性方面，JSON 与 XML 都作为标准的规范，可读性都比较不错，对于可读性的比较其实还是应该取决于应用场景，对于将完整的 XML 映射为 JSON 格式的话，XML 的可读性更好一些，对于单纯的数据描述而言，其可读性不相上下。</p><pre class="language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8" ?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>block</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>demo<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>content</span><span class="token punctuation">></span></span>Hello World<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>content</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>block</span><span class="token punctuation">></span></span></code></pre><pre class="language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    tag<span class="token operator">:</span> <span class="token string">"block"</span><span class="token punctuation">,</span>    name<span class="token operator">:</span> <span class="token string">"demo"</span><span class="token punctuation">,</span>    children<span class="token operator">:</span><span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>            tag<span class="token operator">:</span> <span class="token string">"content"</span><span class="token punctuation">,</span>            children<span class="token operator">:</span><span class="token punctuation">[</span>                <span class="token string">"Hello World"</span>            <span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">]</span><span class="token punctuation">&#125;</span></code></pre><h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><p>XML 与 JSON 都有很好的扩展性，没有什么是 XML 能扩展而 JSON 不能的，同样也没有什么是 JOSN 能扩展而 XML 不能的。  </p><h3 id="编码难度"><a href="#编码难度" class="headerlink" title="编码难度"></a>编码难度</h3><p>无论是 XML 还是 JSON 都有丰富的编码工具，但是对于 JSON 来说即使不借助工具也能轻易地实现对应格式的编码，相反 XML 的编码不借助工具的话就比较难以实现了。  </p><h3 id="数据体积"><a href="#数据体积" class="headerlink" title="数据体积"></a>数据体积</h3><p>XML 格式的数据的冗余度是大于 JSON 格式的数据的，通常而言，XML 比较适合于标记文档，而 JSON 却更适于进行数据交换处理。  </p><h3 id="数据解析"><a href="#数据解析" class="headerlink" title="数据解析"></a>数据解析</h3><p>无论是 XML 还是 JSON 都有丰富的解析工具，对于 XML 而言设计了两种解析方式：DOM 和 SAX，DOM 方式就是将整个 XML 读入内存，全部解析；SAX 方式是一种逐步解析的方法，不需要读入整个 XML 就可以对解析的内容逐步处理，SAX 适合于大型文档的解析。JSON 只提供整体解析方案，对于数据量较少的文档处理效果比较好。  </p><h3 id="数据交互"><a href="#数据交互" class="headerlink" title="数据交互"></a>数据交互</h3><p>对于 JSON 格式的数据，很多语言都在标准库中提供了支持，直接调用库函数即可解析，特别是对于前端，JSON 是 ECMAScript 规范的一个子集，与 JavaScript 的交互更加方便，在前端的应用更加广泛，对于 XML 格式的数据解析一般都需要借助第三方工具库实现。</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSON </tag>
            
            <tag> XML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 中的继承</title>
      <link href="2020/10/01/inheritanceInJavaScript/"/>
      <url>2020/10/01/inheritanceInJavaScript/</url>
      
        <content type="html"><![CDATA[<p>继承是面向对象软件技术当中的一个概念，与多态、封装共为面向对象的三个基本特征。继承可以使得子类具有父类的属性和方法或者重新定义、追加属性和方法等。  </p><h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>通过将子类的原型对象指向父类的实例，实现继承访问父类属性方法等  </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 定义父类</span><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"parent"</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 定义子类</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"child"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将子类的原型对象指向父类的实例</span><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child<span class="token punctuation">;</span> <span class="token comment">// 修复 constructor 使符合原型链规定</span><span class="token keyword">var</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 实例化子类</span>child<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// child</span><span class="token comment">// 此时子类能够访问父类的 say 方法，在查找 name 属性的时候首先在自身属性中查找成功所以不再向上查找，若子类没有 name 成员，则会打印 parent</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child <span class="token keyword">instanceof</span> <span class="token class-name">Parent</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true // 判断 child 的构造函数 Child 的 prototype 对象是否在 Parent 的原型链上</span></code></pre><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>父类新增原型方法与属性，子类都能访问到</li><li>非常纯粹的继承关系，实例是子类的实例，也是父类的实例</li><li>子类实例可以继承父类构造函数属性和方法、父类原型属性和方法</li></ul><h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><ul><li>无法实现多继承</li><li>子类实例化时无法向父类的构造函数传参</li><li>所有子类实例都会共享父类的原型对象中的属性</li></ul><h2 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h2><p>当子类构造函数被调用时，借助 call 或者 apply 调用父类构造方法实现对于 this 的拓展  </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 定义父类</span><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">from</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"parent"</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>from <span class="token operator">=</span> <span class="token keyword">from</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 定义子类</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">from</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用父类构造函数并绑定 this 来拓展 Child 实例成员方法，可以传递参数</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"child"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">"child"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 实例化子类</span>child<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// child</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// child</span></code></pre><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>子类实例不会共享父类属性方法</li><li>实例化子类时可以向父类构造函数传参</li><li>通过调用多个父类构造函数可以实现多继承</li></ul><h3 id="不足-1"><a href="#不足-1" class="headerlink" title="不足"></a>不足</h3><ul><li>实例并不是父类的实例，只是子类的实例</li><li>只继承了父类的构造函数的属性和方法，没有继承父类原型的属性和方法</li><li>每个子类都有父类实例函数的副本，拷贝了父类函数而不是引用，影响性能</li></ul><h2 id="实例继承"><a href="#实例继承" class="headerlink" title="实例继承"></a>实例继承</h2><p>为父类实例增加成员与方法，作为实例返回  </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 定义父类</span><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">from</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"parent"</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>from <span class="token operator">=</span> <span class="token keyword">from</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 定义子类</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">from</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token keyword">from</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    instance<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"child"</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> instance<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">"child"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 实例化子类</span>child<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// child</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// child</span></code></pre><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul><li>实例化子类时可以向父类构造函数传参</li><li>子类的实例化方式可以为 <code>new Child()</code> 或直接调用 <code>Child()</code></li></ul><h3 id="不足-2"><a href="#不足-2" class="headerlink" title="不足"></a>不足</h3><ul><li>不支持多继承</li><li>实例是父类的实例，不是子类的实例</li><li>同样也是将父类的成员与方法做了实例化拷贝</li></ul><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>通过共享原型对象实现继承  </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 定义父类</span><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"parent"</span><span class="token punctuation">;</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 定义子类</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">from</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"child"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> <span class="token comment">// 共享原型</span><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child<span class="token punctuation">;</span><span class="token keyword">var</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">"child"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 实例化子类</span>child<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// child</span></code></pre><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><ul><li>实现了方法与属性的复用</li><li>父类新增原型方法与属性，子类都能访问到</li></ul><h3 id="不足-3"><a href="#不足-3" class="headerlink" title="不足"></a>不足</h3><ul><li>不能继承父构造函数的实例对象的成员</li><li>所有子类实例都会共享父类的原型对象中的属性</li></ul><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>组合原型链继承和借用构造函数继承，结合了两种模式的优点，传参和复用  </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 定义父类</span><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">from</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"parent"</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>from <span class="token operator">=</span> <span class="token keyword">from</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 定义子类</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">from</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用父类构造函数并绑定 this 来拓展 Child 实例成员方法，可以传递参数</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"child"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child<span class="token punctuation">;</span><span class="token keyword">var</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">"child"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 实例化子类</span>child<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// child</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// child</span></code></pre><h3 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h3><ul><li>原型方法可以复用</li><li>既是子类的实例，也是父类的实例</li><li>实例化子类时可以向父类构造函数传参</li><li>可以继承实例属性和方法，也可以继承原型属性和方法</li></ul><h3 id="不足-4"><a href="#不足-4" class="headerlink" title="不足"></a>不足</h3><ul><li>调用了两次父类构造函数，生成了两份实例，子类的构造函数的拷贝会代替原型上的父类构造函数的实例</li></ul><h2 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h2><p>通过寄生方式，砍掉父类的实例属性，在调用两次父类的构造的时候，就不会初始化两次实例方法和属性，避免的组合继承的缺点  </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 定义父类</span><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">from</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"parent"</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>from <span class="token operator">=</span> <span class="token keyword">from</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 定义子类</span><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">from</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">Parent</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"child"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 创建一个没有实例方法的类</span>f<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> <span class="token comment">// 浅拷贝父类原型</span><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 实例化 f，此时没有实例化方法调用，同时将原型链建立</span><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Child<span class="token punctuation">;</span><span class="token keyword">var</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token string">"child"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 实例化子类</span>child<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// child</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// child</span></code></pre><h3 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h3><ul><li>比较完善</li></ul><h3 id="不足-5"><a href="#不足-5" class="headerlink" title="不足"></a>不足</h3><ul><li>相对比较复杂</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器事件总结</title>
      <link href="2020/09/28/browserEvent/"/>
      <url>2020/09/28/browserEvent/</url>
      
        <content type="html"><![CDATA[<p>常用浏览器事件与 DOM 事件，包括鼠标事件、键盘事件、框架/对象事件、表单事件、剪贴板事件、打印事件、拖动事件、多媒体事件、动画事件、过渡事件。</p><h2 id="浏览器事件"><a href="#浏览器事件" class="headerlink" title="浏览器事件"></a>浏览器事件</h2><h3 id="加载相关"><a href="#加载相关" class="headerlink" title="加载相关"></a>加载相关</h3><ul><li><code>onbeforeunload</code> : 该事件在即将离开页面（刷新或关闭）时触发。</li><li><code>onload</code> : 文档加载完成后触发。</li><li><code>onunload</code> : 当窗口卸载其内容和资源时触发。</li><li><code>onerror</code> : 当发生 JavaScript 运行时错误与资源加载失败时触发。</li><li><code>onabort</code> : 发送到 window 的中止 abort 事件的事件处理程序。在 IE 中， <code>onabort</code> 只对 <code>&lt;img&gt;</code> 标签有效。</li></ul><h3 id="窗口相关"><a href="#窗口相关" class="headerlink" title="窗口相关"></a>窗口相关</h3><ul><li><code>onblur</code> : 窗口失去焦点时触发。</li><li><code>onfocus</code> : 窗口获得焦点时触发。</li><li><code>onresize</code> : 窗口大小发生改变时触发。</li><li><code>onscroll</code> : 窗口发生滚动时触发。</li><li><code>onmessage</code> : 窗口对象接收消息事件时触发。</li><li><code>onchange</code> : 窗口内表单元素的内容改变时触发。</li><li><code>oninput</code> : 窗口内表单元素获取用户输入时触发。</li><li><code>onreset</code> : 窗口内表单重置时触发。</li><li><code>onselect</code> : 窗口内表单元素中文本被选中时触发。</li><li><code>onsubmit</code> : 窗口内表单中 submit 按钮被按下触发。</li><li><code>onhashchange</code> : 当窗口的锚点哈希值发生变化时触发。</li></ul><h3 id="鼠标相关"><a href="#鼠标相关" class="headerlink" title="鼠标相关"></a>鼠标相关</h3><ul><li><code>onclick</code> : 当点击页面时触发。</li><li><code>onmouseup</code> : 鼠标按键被松开时触发。</li><li><code>ondblclick</code> : 当双击页面时调用事件句柄。</li><li><code>oncontextmenu</code> : 在点击鼠标右键打开上下文菜单时触发。</li><li><code>onmousedown</code> : 鼠标按钮被按下时触发。</li><li><code>onmousemove</code> : 当移动鼠标时触发。</li><li><code>onmouseout</code> : 鼠标移出窗口时触发。</li><li><code>onmouseover</code> : 鼠标移动到窗口时触发。</li><li><code>onauxclick</code> : 指示在输入设备上按下非主按钮时触发，例如鼠标中键。</li></ul><h3 id="键盘相关"><a href="#键盘相关" class="headerlink" title="键盘相关"></a>键盘相关</h3><ul><li><code>onkeydown</code> : 某个键盘按键被按下时触发。</li><li><code>onkeyup</code> : 某个键盘按键被松开后触发。</li><li><code>onkeypress</code> : 某个键盘按键被按下并松开后触发。</li></ul><h3 id="动画相关"><a href="#动画相关" class="headerlink" title="动画相关"></a>动画相关</h3><ul><li><code>onanimationcancel</code> : 当 CSS 动画意外中止时，即在任何时候它停止运行而不发送 <code>animationend</code> 事件时将发送此事件，例如当 <code>animation-name</code> 被改变，动画被删除等</li><li><code>onanimationend</code> : 当 CSS 动画到达其活动周期的末尾时，按照 <code>(animation-duration*animation-iteration-count) + animation-delay</code> 进行计算，将发送此事件。</li><li><code>onanimationiteration</code> : 此事件将会在 CSS 动画到达每次迭代结束时触发，当通过执行最后一个动画步骤完成对动画指令序列的单次传递完成时，迭代结束。</li></ul><h3 id="设备相关"><a href="#设备相关" class="headerlink" title="设备相关"></a>设备相关</h3><ul><li><code>ondevicemotion</code> : 设备状态发生改变时触发</li><li><code>ondeviceorientation</code> : 设备相对方向发生改变时触发</li><li><code>ondeviceproximity</code> : 当设备传感器检测到物体变得更接近或更远离设备时触发。</li></ul><h3 id="打印相关"><a href="#打印相关" class="headerlink" title="打印相关"></a>打印相关</h3><ul><li><code>onbeforeprint</code> : 该事件在页面即将开始打印时触发</li><li><code>onafterprint</code> : 该事件在页面已经开始打印或者打印窗口已经关闭时触发。</li></ul><h3 id="应用相关"><a href="#应用相关" class="headerlink" title="应用相关"></a>应用相关</h3><ul><li><code>onappinstalled</code> : 一旦将 Web 应用程序成功安装为渐进式 Web 应用程序，该事件就会被分派。</li><li><code>onbeforeinstallprompt</code> : 当用户即将被提示安装 web 应用程序时，该处理程序将在设备上调度，其相关联的事件可以保存以供稍后用于在更适合的时间提示用户。 </li></ul><h2 id="DOM-事件"><a href="#DOM-事件" class="headerlink" title="DOM 事件"></a>DOM 事件</h2><h3 id="鼠标相关-1"><a href="#鼠标相关-1" class="headerlink" title="鼠标相关"></a>鼠标相关</h3><ul><li><code>onclick</code> : 当用户点击某个对象时调用的事件句柄。</li><li><code>oncontextmenu</code> : 在用户点击鼠标右键打开上下文菜单时触发</li><li><code>ondblclick</code> : 当用户双击某个对象时调用的事件句柄。</li><li><code>onmousedown</code> : 鼠标按钮被按下。</li><li><code>onmouseenter</code> : 当鼠标指针移动到元素上时触发。</li><li><code>onmouseleave</code> : 当鼠标指针移出元素时触发</li><li><code>onmousemove</code> : 鼠标被移动。</li><li><code>onmouseover</code> : 鼠标移到某元素之上。</li><li><code>onmouseout</code> : 鼠标从某元素移开。</li><li><code>onmouseup</code> : 鼠标按键被松开。</li><li><code>onwheel</code> : 该事件在鼠标滚轮在元素上下滚动时触发。</li></ul><h3 id="键盘相关-1"><a href="#键盘相关-1" class="headerlink" title="键盘相关"></a>键盘相关</h3><ul><li><code>onkeydown</code> : 某个键盘按键被按下。</li><li><code>onkeypress</code> : 某个键盘按键被按下并松开。</li><li><code>onkeyup</code> : 某个键盘按键被松开。</li></ul><h3 id="框架-图像相关"><a href="#框架-图像相关" class="headerlink" title="框架/图像相关"></a>框架/图像相关</h3><ul><li><code>onabort</code> : 图像的加载被中断。</li><li><code>onbeforeunload</code> : 该事件在即将离开页面（刷新或关闭）时触发</li><li><code>onerror</code> : 在加载文档或图像时发生错误。</li><li><code>onhashchange</code> : 该事件在当前 URL 的锚部分发生修改时触发。</li><li><code>onload</code> : 一张页面或一幅图像完成加载。</li><li><code>onpageshow</code> : 该事件在用户访问页面时触发</li><li><code>onpagehide</code> : 该事件在用户离开当前网页跳转到另外一个页面时触发</li><li><code>onresize</code> : 窗口或框架被重新调整大小。</li><li><code>onscroll</code> : 当文档被滚动时发生的事件。</li><li><code>onunload</code> : 用户退出页面。</li><li><code>visibilitychange</code> : document 监听事件，浏览器标签页被隐藏或显示的时触发</li><li><code>onmessage</code> : 从 <code>WebSocket</code> 、 <code>Web Worker</code> 、 <code>Event Source</code> 、 <code>iframe</code> 或父窗口接收到消息时触发。</li><li><code>ononline</code> : 该事件在浏览器开始在线工作时触发。</li><li><code>onoffline</code> : 该事件在浏览器开始离线工作时触发。</li><li><code>onshow</code> : 该事件当 <code>&lt;menu&gt;</code> 元素在上下文菜单显示时触发。</li><li><code>ontoggle</code> : 该事件在用户打开或关闭 <code>&lt;details&gt;</code> 元素时触发。</li></ul><h3 id="表单事件相关"><a href="#表单事件相关" class="headerlink" title="表单事件相关"></a>表单事件相关</h3><ul><li><code>onblur</code> : 元素失去焦点时触发。</li><li><code>onchange</code> : 该事件在表单元素的内容改变时触发。</li><li><code>onfocus</code> : 元素获取焦点时触发。</li><li><code>onfocusin</code> : 元素即将获取焦点时触发。</li><li><code>onfocusout</code> : 元素即将失去焦点时触发。</li><li><code>oninput</code> : 元素获取用户输入时触发。</li><li><code>onreset</code> : 表单重置时触发。</li><li><code>onsearch</code> : 用户向搜索域输入文本时触发。</li><li><code>onselect</code> : 用户在输入框内选取文本时触发。</li><li><code>onsubmit</code> : 表单提交时触发。</li></ul><h3 id="剪贴板相关"><a href="#剪贴板相关" class="headerlink" title="剪贴板相关"></a>剪贴板相关</h3><ul><li><code>oncopy</code> : 该事件在用户拷贝元素内容时触发。</li><li><code>oncut</code> : 该事件在用户剪切元素内容时触发。</li><li><code>onpaste</code> : 该事件在用户粘贴元素内容时触发。</li></ul><h3 id="打印相关-1"><a href="#打印相关-1" class="headerlink" title="打印相关"></a>打印相关</h3><ul><li><code>onafterprint</code> : 该事件在页面已经开始打印，或者打印窗口已经关闭时触发。</li><li><code>onbeforeprint</code> : 该事件在页面即将开始打印时触发。</li></ul><h3 id="拖动相关"><a href="#拖动相关" class="headerlink" title="拖动相关"></a>拖动相关</h3><ul><li><code>ondrag</code> : 该事件在元素正在拖动时触发。</li><li><code>ondragend</code> : 该事件在用户完成元素的拖动时触发。</li><li><code>ondragenter</code> : 该事件在拖动的元素进入放置目标时触发。</li><li><code>ondragleave</code> : 该事件在拖动元素离开放置目标时触发。</li><li><code>ondragover</code> : 该事件在拖动元素在放置目标上时触发。</li><li><code>ondragstart</code> : 该事件在用户开始拖动元素时触发。</li><li><code>ondrop</code> : 该事件在拖动元素放置在目标区域时触发。</li></ul><h3 id="多媒体相关"><a href="#多媒体相关" class="headerlink" title="多媒体相关"></a>多媒体相关</h3><ul><li><code>onabort</code> : 事件在视频/音频终止加载时触发。</li><li><code>oncanplay</code> : 事件在用户可以开始播放视频/音频时触发。</li><li><code>oncanplaythrough</code> : 事件在视频/音频可以正常播放且无需停顿和缓冲时触发。</li><li><code>ondurationchange</code> : 事件在视频/音频的时长发生变化时触发。</li><li><code>onemptied</code> : 当期播放列表为空时触发</li><li><code>onended</code> : 事件在视频/音频播放结束时触发。</li><li><code>onerror</code> : 事件在视频/音频数据加载期间发生错误时触发。</li><li><code>onloadeddata</code> : 事件在浏览器加载视频/音当前帧时触发触发。</li><li><code>onloadedmetadata</code> : 事件在指定视频/音频的元数据加载后触发。</li><li><code>onloadstart</code> : 事件在浏览器开始寻找指定视频/音频触发。</li><li><code>onpause</code> : 事件在视频/音频暂停时触发。</li><li><code>onplay</code> : 事件在视频/音频开始播放时触发。</li><li><code>onplaying</code> : 事件在视频/音频暂停或者在缓冲后准备重新开始播放时触发。</li><li><code>onprogress</code> : 事件在浏览器下载指定的视频/音频时触发。</li><li><code>onratechange</code> : 事件在视频/音频的播放速度发送改变时触发。</li><li><code>onseeked</code> : 事件在用户重新定位视频/音频的播放位置后触发。</li><li><code>onseeking</code> : 事件在用户开始重新定位视频/音频时触发。</li><li><code>onstalled</code> : 事件在浏览器获取媒体数据，但媒体数据不可用时触发。</li><li><code>onsuspend</code> : 事件在浏览器读取媒体数据中止时触发。</li><li><code>ontimeupdate</code> : 事件在当前的播放位置发送改变时触发。</li><li><code>onvolumechange</code> : 事件在音量发生改变时触发。</li><li><code>onwaiting</code> : 事件在视频由于要播放下一帧而需要缓冲时触发。</li></ul><h3 id="动画相关-1"><a href="#动画相关-1" class="headerlink" title="动画相关"></a>动画相关</h3><ul><li><code>animationend</code> : 该事件在 CSS 动画结束播放时触发</li><li><code>animationiteration</code> : 该事件在 CSS 动画重复播放时触发</li><li><code>animationstart</code> : 该事件在 CSS 动画开始播放时触发</li></ul><h3 id="过渡相关"><a href="#过渡相关" class="headerlink" title="过渡相关"></a>过渡相关</h3><ul><li><code>atransitionend</code> : 该事件在 CSS 完成过渡后触发。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Browser </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Browser </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防抖与节流</title>
      <link href="2020/09/24/debounceAndThrottle/"/>
      <url>2020/09/24/debounceAndThrottle/</url>
      
        <content type="html"><![CDATA[<p>防抖 (debounce) 与节流 (throttle) 都是控制事件处理函数执行频率的方法，当函数会进行 DOM 操作或者具有请求服务器等行为并且作为高频事件例如 <code>onscroll</code> 触发的事件处理函数时，就需要进行事件处理函数执行频率的控制，否则会造成大量的资源浪费致使性能下降，当然无论是防抖与节流实质上并没有减少事件触发次数，而是通过减少事件处理函数的执行次数从而提高性能。</p><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><h3 id="非立即防抖"><a href="#非立即防抖" class="headerlink" title="非立即防抖"></a>非立即防抖</h3><p>当持续触发事件的时候，事件处理函数是完全不执行的，等最后一次触发结束的一段时间之后，再去执行。最常见的例子就是搜索建议功能，当用户进行持续输入时，并不会请求服务器进行搜索建议的计算，直至用户输入完成后的 N 毫秒后才会将数据传输至后端并返回搜索建议。<br>实现思路：每次触发事件时都取消之前的延时调用方法并重设定时器。</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">wait<span class="token punctuation">,</span> funct<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>        timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">funct</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>window<span class="token punctuation">.</span>onscroll <span class="token operator">=</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="立即防抖"><a href="#立即防抖" class="headerlink" title="立即防抖"></a>立即防抖</h3><p>当持续触发事件的时候，事件处理函数会立即执行，然后不再执行事件处理函数，直至最后一次事件触发之后的一段时间后才允许再次执行事件处理函数。<br>实现思路：判断是否存在定时器，没有则执行事件处理函数，然后无论是否已经存在定时器都需要重设定时器。</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">wait<span class="token punctuation">,</span> funct<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timer<span class="token punctuation">)</span> <span class="token function">funct</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>        timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>window<span class="token punctuation">.</span>onscroll <span class="token operator">=</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>当事件持续触发时，节流操作可以稀释事件处理函数执行频率，假设在 1s 内 <code>onmousemove</code> 事件触发了 100 次，通过节流就可以使得 <code>onmousemove</code> 事件的事件处理函数每 100ms 触发一次，也就是在 1s 内 <code>onmousemove</code> 事件的事件处理函数只执行 10 次。</p><h3 id="时间戳实现"><a href="#时间戳实现" class="headerlink" title="时间戳实现"></a>时间戳实现</h3><p>实现思路：通过时间戳记录上次事件处理函数执行时间，事件触发时若时间差大于执行周期则执行事件处理函数并赋值执行时间为当前时间戳。</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">wait<span class="token punctuation">,</span> funct<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> previous <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">var</span> now <span class="token operator">=</span> <span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> previous <span class="token operator">></span> wait<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">funct</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>            previous <span class="token operator">=</span> now<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>window<span class="token punctuation">.</span>onscroll <span class="token operator">=</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="定时器实现"><a href="#定时器实现" class="headerlink" title="定时器实现"></a>定时器实现</h3><p>实现思路：判断是否存在定时器，没有则执行事件处理函数并重设定时器。</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">wait<span class="token punctuation">,</span> funct<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timer<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">funct</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>            timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>window<span class="token punctuation">.</span>onscroll <span class="token operator">=</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 严格模式</title>
      <link href="2020/09/22/strictMode/"/>
      <url>2020/09/22/strictMode/</url>
      
        <content type="html"><![CDATA[<p>JavaScript 的严格模式 (strict mode)，即在严格的条件下运行。严格模式消除了 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为；消除代码运行的一些不安全之处，保证代码运行的安全；提高了引擎的效率，增加运行速度；为未来新的 JavaScript 版本做好铺垫  </p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>针对整个脚本文件启用严格模式：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token string">"use strict"</span><span class="token punctuation">;</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// Uncaught ReferenceError: x is not defined</span></code></pre><p>针对函数作用域启用严格模式：</p><pre class="language-js" data-language="js"><code class="language-js">x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">s</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token string">"use strict"</span><span class="token punctuation">;</span>    y <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// Uncaught ReferenceError: y is not defined</span><span class="token punctuation">&#125;</span><span class="token function">s</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="严格模式的限制"><a href="#严格模式的限制" class="headerlink" title="严格模式的限制"></a>严格模式的限制</h2><h3 id="不允许直接声明全局变量"><a href="#不允许直接声明全局变量" class="headerlink" title="不允许直接声明全局变量"></a>不允许直接声明全局变量</h3><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 非严格模式</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span></code></pre><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 严格模式</span><span class="token string">"use strict"</span><span class="token punctuation">;</span><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 可以使用 var 在全局作用域声明全局变量</span>y <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// Uncaught ReferenceError: y is not defined</span></code></pre><h3 id="不允许-delete-变量和函数"><a href="#不允许-delete-变量和函数" class="headerlink" title="不允许 delete 变量和函数"></a>不允许 delete 变量和函数</h3><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 非严格模式</span><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">delete</span> x<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span></code></pre><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 严格模式</span><span class="token string">"use strict"</span><span class="token punctuation">;</span><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">delete</span> x<span class="token punctuation">;</span> <span class="token comment">// Uncaught SyntaxError: Delete of an unqualified identifier in strict mode.</span></code></pre><h3 id="要求函数的参数名唯一"><a href="#要求函数的参数名唯一" class="headerlink" title="要求函数的参数名唯一"></a>要求函数的参数名唯一</h3><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 非严格模式</span><span class="token keyword">function</span> <span class="token function">s</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> a</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 6</span><span class="token punctuation">&#125;</span><span class="token function">s</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 严格模式</span><span class="token string">"use strict"</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">s</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> a</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// Uncaught SyntaxError: Duplicate parameter name not allowed in this context</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">s</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="不允许使用八进制数字语法"><a href="#不允许使用八进制数字语法" class="headerlink" title="不允许使用八进制数字语法"></a>不允许使用八进制数字语法</h3><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 非严格模式</span><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">010</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 8</span></code></pre><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 严格模式</span><span class="token string">"use strict"</span><span class="token punctuation">;</span><span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token number">010</span><span class="token punctuation">;</span> <span class="token comment">// Uncaught SyntaxError: Octal literals are not allowed in strict mode.</span><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">0O10</span><span class="token punctuation">;</span> <span class="token comment">// 可以使用 ES6 中的八进制表示法新写法 前缀 0o 或 0O</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 8</span></code></pre><h3 id="不允许使用转义字符"><a href="#不允许使用转义字符" class="headerlink" title="不允许使用转义字符"></a>不允许使用转义字符</h3><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 非严格模式</span><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token string">"\045"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// %</span></code></pre><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 严格模式</span><span class="token string">"use strict"</span><span class="token punctuation">;</span><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token string">"\045"</span><span class="token punctuation">;</span> <span class="token comment">// Uncaught SyntaxError: Octal escape sequences are not allowed in strict mode.</span></code></pre><h3 id="不允许对只读属性操作"><a href="#不允许对只读属性操作" class="headerlink" title="不允许对只读属性操作"></a>不允许对只读属性操作</h3><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 非严格模式</span><span class="token comment">// 操作静默失败，即不报错也没有任何效果</span><span class="token comment">// 给不可写属性赋值</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">"x"</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>    value<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>    writable<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0</span><span class="token comment">// 给只读属性赋值</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    _x<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token keyword">get</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0</span><span class="token comment">// 给不可扩展对象的新属性赋值</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">preventExtensions</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span></code></pre><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 严格模式</span><span class="token comment">// 操作失败抛出异常</span><span class="token string">"use strict"</span><span class="token punctuation">;</span><span class="token comment">// 给不可写属性赋值</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">"x"</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>    value<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>    writable<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// Uncaught TypeError: Cannot assign to read only property 'x' of object '#&lt;Object>'</span><span class="token comment">// 给只读属性赋值</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    _x<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token keyword">get</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// Uncaught TypeError: Cannot set property x of #&lt;Object> which has only a getter</span><span class="token comment">// 给不可扩展对象的新属性赋值</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">preventExtensions</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// Uncaught TypeError: Cannot add property x, object is not extensible</span></code></pre><h3 id="不允许使用保留关键字命名变量"><a href="#不允许使用保留关键字命名变量" class="headerlink" title="不允许使用保留关键字命名变量"></a>不允许使用保留关键字命名变量</h3><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 非严格模式</span><span class="token keyword">var</span> eval <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>eval<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span></code></pre><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 严格模式</span><span class="token string">"use strict"</span><span class="token punctuation">;</span><span class="token keyword">var</span> eval <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// Uncaught SyntaxError: Unexpected eval or arguments in strict mode</span></code></pre><h3 id="不允许使用-with-关键字"><a href="#不允许使用-with-关键字" class="headerlink" title="不允许使用 with 关键字"></a>不允许使用 with 关键字</h3><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 非严格模式</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    x<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">with</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 严格模式</span><span class="token string">"use strict"</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    x<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">with</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// Uncaught SyntaxError: Strict mode code may not include a with statement</span>    x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="eval-声明变量不能在外部使用"><a href="#eval-声明变量不能在外部使用" class="headerlink" title="eval 声明变量不能在外部使用"></a>eval 声明变量不能在外部使用</h3><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 非严格模式</span><span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">"var x = 0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0</span></code></pre><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 严格模式</span><span class="token string">"use strict"</span><span class="token punctuation">;</span><span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">"var x = 0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// eval 作用域</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Uncaught ReferenceError: x is not defined</span></code></pre><h3 id="arguments-保留原始参数"><a href="#arguments-保留原始参数" class="headerlink" title="arguments 保留原始参数"></a>arguments 保留原始参数</h3><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 非严格模式</span><span class="token keyword">function</span> <span class="token function">s</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arguments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2 2</span><span class="token punctuation">&#125;</span><span class="token function">s</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 严格模式</span><span class="token string">"use strict"</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">s</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arguments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1 2</span><span class="token punctuation">&#125;</span><span class="token function">s</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="this-的限制"><a href="#this-的限制" class="headerlink" title="this 的限制"></a>this 的限制</h3><p>在严格模式下通过 <code>this</code> 传递给一个函数的值不会被强制转换为一个对象。对一个普通的函数来说， <code>this</code> 总会是一个对象：不管调用时 <code>this</code> 它本来就是一个对象；还是用布尔值，字符串或者数字调用函数时函数里面被封装成对象的 <code>this</code> ；还是使用 <code>undefined</code> 或者 <code>null</code> 调用函数式 <code>this</code> 代表的全局对象（使用 <code>call</code> , <code>apply</code> 或者 <code>bind</code> 方法来指定一个确定的 <code>this</code> ）。这种自动转化为对象的过程不仅是一种性能上的损耗，同时在浏览器中暴露出全局对象也会成为安全隐患，因为全局对象提供了访问那些所谓安全的 JavaScript 环境必须限制的功能的途径。所以对于一个开启严格模式的函数，指定的 <code>this</code> 不再被封装为对象，而且如果没有指定 <code>this</code> 的话它值是 <code>undefined</code> 。</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 非严格模式</span><span class="token keyword">function</span> <span class="token function">s</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Window ...</span><span class="token punctuation">&#125;</span><span class="token function">s</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 严格模式</span><span class="token string">"use strict"</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">s</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span><span class="token punctuation">&#125;</span><span class="token function">s</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="禁止访问调用栈"><a href="#禁止访问调用栈" class="headerlink" title="禁止访问调用栈"></a>禁止访问调用栈</h3><p>在严格模式中再也不能通过广泛实现的 ECMAScript 扩展游走于 JavaScript 的栈中。在普通模式下用这些扩展的话，当一个叫 <code>fun</code> 的函数正在被调用的时候， <code>fun.caller</code> 是最后一个调用 <code>fun</code> 的函数，而且 <code>fun.arguments</code> 包含调用 <code>fun</code> 时用的形参。这两个扩展接口对于安全 JavaScript 而言都是有问题的，因为他们允许安全的代码访问专有函数和他们的（通常是没有经过保护的）形参。如果 <code>fun</code> 在严格模式下，那么 <code>fun.caller</code> 和 <code>fun.arguments</code> 都是不可删除的属性而且在存值、取值时都会报错。</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 非严格模式</span><span class="token keyword">function</span> <span class="token function">ss</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ss<span class="token punctuation">.</span>caller<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ƒ s()&#123; ss(); &#125;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ss<span class="token punctuation">.</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Arguments [callee: ƒ, Symbol(Symbol.iterator): ƒ]</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">s</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">ss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">s</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 严格模式</span><span class="token string">"use strict"</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">ss</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ss<span class="token punctuation">.</span>caller<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Uncaught TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ss<span class="token punctuation">.</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Uncaught TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them ƒ]</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">s</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">ss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">s</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 中的堆栈</title>
      <link href="2020/09/18/stackAndHeap/"/>
      <url>2020/09/18/stackAndHeap/</url>
      
        <content type="html"><![CDATA[<p>堆 (Heap) 是动态分配的内存，大小不定也不会自动释放，栈 (stack) 为自动分配的内存空间，在代码执行过程中自动释放。  </p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>在栈内存中提供一个供 JavaScript 代码执行的环境，关于作用域以及函数的调用都是栈内存中执行的。<br>JavaScript 中基本数据类型 <code>String</code> 、 <code>Number</code> 、 <code>Boolean</code> 、 <code>Null</code> 、 <code>Undefined</code> 、 <code>Symbol</code> ，占用空间小且大小固定，值直接保存在栈内存中，是按值访问，对于 <code>Object</code> 引用类型，其指针放置于栈内存中，指向堆内存的实际地址，是通过引用访问。<br>关于调用栈，每调用一个函数，解释器就会把该函数添加进调用栈并开始执行；正在调用栈中执行的函数还调用了其它函数，那么新函数也将会被添加进调用栈，一旦这个函数被调用，便会立即执行；当前函数执行完毕后，解释器将其清出调用栈，继续执行当前执行环境下的剩余的代码；当分配的调用栈空间被占满时，会引发堆栈溢出错误。  </p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>引用类型 <code>Object</code> 的变量占据空间大且大小不固定，堆内存中存储实际对象，在栈内存中存储对象的指针，对于对象的访问是按引用访问的，在堆区的内存不会随着程序的运行而自动释放，这就需要实现垃圾回收机制 GC，需要注意的是在 JavaScript 中没有类似于 C 中的 <code>free()</code> 函数去手动释放内存，对于堆区内存回收全部需要通过 JavaScript 的垃圾回收机制去实现。<br>在栈区中执行的变量等是通过值访问，当其作用域销毁后变量也就随之销毁，而使用引用访问的堆区变量，在一个作用域消失后还可能在外层作用域或者其他作用域仍然存在引用，不能直接销毁，此时就需要通过算法计算该堆区变量是否属于不再需要的变量，从而决定是否需要进行内存回收，在 JavaScript 中主要有引用计数与标记清除两种垃圾回收算法。  </p><p><img src="/images/HeapStack.jpg" alt="堆栈内存分配"></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 Liunx 中查找文件</title>
      <link href="2020/09/14/findCommand/"/>
      <url>2020/09/14/findCommand/</url>
      
        <content type="html"><![CDATA[<h2 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h2><p>使用 <code>locate</code> 命令需要安装 <code>mlocate</code> :</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> dnf <span class="token function">install</span> mlocate</code></pre><p><code>locate</code> 命令维护一个 <code>/var/lib/mlocate/mlocate.db</code> 文件存放索引，该数据文件会定期更新，也可以运行 <code>updatedb</code> 命令立即更新索引：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> updatedb</code></pre><p>查找文件时使用 <code>locate 文件名</code> 搜索文件：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">locate</span> my.ini</code></pre><h2 id="which"><a href="#which" class="headerlink" title="which"></a>which</h2><p><code>which</code> 命令查找 <code>$PATH</code> 中的目录中的可执行文件，并显示该可执行文件的完整路径。  </p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">which</span> gcc</code></pre><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p><code>find</code> 命令用来在指定目录下查找文件，任何位于参数之前的字符串都将被视为要查找的目录名，如果使用该命令时，不设置任何参数，则 <code>find</code> 命令将在当前目录下查找子目录与文件，并且将查找到的子目录和文件全部进行显示。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><pre class="language-none"><code class="language-none">find [-H] [-L] [-P] [-Olevel] [-D help|tree|search|stat|rates|opt|exec] [path...] [expression]</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>查找 <code>/etc/</code> 目录及其子目录下所有扩展名为 <code>conf</code> 的文件。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> /etc/ -name <span class="token string">'*.conf'</span></code></pre><p>查找 <code>/var/</code> 目录及其子目录下所有一般文件。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> /var/ -type f</code></pre><p>查找 <code>/var/</code> 目录及其子目录下所有最近 1 天内更改过的文件，+1 则表示 1 天前更改过文件。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> /var/ -ctime -1</code></pre><p>查找 <code>/var/</code> 目录及其子目录下所有更改时间在 7 日以前的普通文件，并在删除之前询问是否删除。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> /var/ -type f -mtime +7 -ok <span class="token function">rm</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">\</span><span class="token punctuation">;</span> </code></pre><p>查找 <code>/var/</code> 目录及其子目录下所有文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> /var/  -type f -perm <span class="token number">644</span> -exec <span class="token function">ls</span> -l <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">\</span><span class="token punctuation">;</span> </code></pre><p>查找 <code>/var/</code> 目录及其子目录下所有文件长度为 0 的普通文件，并列出它们的完整路径。</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">find</span> /var/ -type f -size <span class="token number">0</span> -exec <span class="token function">ls</span> -l <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">\</span><span class="token punctuation">;</span> </code></pre><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li><code>-amin&lt;minute&gt;</code> : 查找在指定时间曾被存取过的文件或目录，单位以分钟计算。</li><li><code>-anewer&lt;file or folder&gt;</code> : 查找其存取时间较指定文件或目录的存取时间更接近现在的文件或目录。</li><li><code>-atime&lt;day&gt;</code> : 查找在指定时间曾被存取过的文件或目录，单位以天计算。</li><li><code>-cmin&lt;minute&gt;</code> : 查找在指定时间之时被更改过的文件或目录。</li><li><code>-cnewer&lt;file or folder&gt;</code> 查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录。</li><li><code>-ctime&lt;day&gt;</code> : 查找在指定时间之时被更改的文件或目录，单位以天计算。</li><li><code>-daystart</code> : 从本日开始计算时间。</li><li><code>-depth</code> : 从指定目录下最深层的子目录开始查找。</li><li><code>-empty</code> : 寻找文件大小为 <code>0 Byte</code> 的文件，或目录下没有任何子目录或文件的空目录。</li><li><code>-exec&lt;command&gt;</code> : 假设 <code>find</code> 指令的回传值为 <code>True</code> ，就执行该指令。</li><li><code>-false</code> : 将 <code>find</code> 指令的回传值皆设为 <code>False</code> 。</li><li><code>-fls&lt;file list&gt;</code> : 此参数的效果和指定 <code>-ls</code> 参数类似，但会把结果保存为指定的列表文件。</li><li><code>-follow</code> : 排除符号连接。</li><li><code>-fprint&lt;file list&gt;</code> : 此参数的效果和指定 <code>-print</code> 参数类似，但会把结果保存成指定的列表文件。</li><li><code>-fprint0&lt;file list&gt;</code> : 此参数的效果和指定 <code>-print0</code> 参数类似，但会把结果保存成指定的列表文件。</li><li><code>-fprintf&lt;file list&gt;&lt;output format&gt;</code> : 此参数的效果和指定 <code>-printf</code> 参数类似，但会把结果保存成指定的列表文件。</li><li><code>-fstype&lt;file system type&gt;</code> : 只寻找该文件系统类型下的文件或目录。</li><li><code>-gid&lt;group id&gt;</code> : 查找符合指定之群组识别码的文件或目录。</li><li><code>-group&lt;group name&gt;</code> : 查找符合指定之群组名称的文件或目录。</li><li><code>-help, --help</code> : 在线帮助。</li><li><code>-ilname&lt;template style&gt;</code> : 此参数的效果和指定 <code>-lname</code> 参数类似，但忽略字符大小写的差别。</li><li><code>-iname&lt;template style&gt;</code> : 此参数的效果和指定 <code>-name</code> 参数类似，但忽略字符大小写的差别。</li><li><code>-inum&lt;inode num&gt;</code> : 查找符合指定的 inode 编号的文件或目录。</li><li><code>-ipath&lt;template style&gt;</code> : 此参数的效果和指定 <code>-path</code> 参数类似，但忽略字符大小写的差别。</li><li><code>-iregex&lt;template style&gt;</code> : 此参数的效果和指定 <code>-regexe</code> 参数类似，但忽略字符大小写的差别。</li><li><code>-links&lt;number of connections&gt;</code> : 查找符合指定的硬连接数目的文件或目录。</li><li><code>-iname&lt;template style&gt;</code> : 指定字符串作为寻找符号连接的范本样式。</li><li><code>-ls</code> : 假设 <code>find</code> 指令的回传值为 <code>Ture</code> ，就将文件或目录名称列出到标准输出。</li><li><code>-maxdepth&lt;directory level&gt;</code> : 设置最大目录层级。</li><li><code>-mindepth&lt;directory level&gt;</code> : 设置最小目录层级。</li><li><code>-mmin&lt;minute&gt;</code> : 查找在指定时间曾被更改过的文件或目录，单位以分钟计算。</li><li><code>-mount</code> : 此参数的效果和指定 <code>-xdev</code> 相同。</li><li><code>-mtime&lt;24 hour&gt;</code> : 查找在指定时间曾被更改过的文件或目录，单位以 <code>24</code> 小时计算。</li><li><code>-name&lt;template style&gt;</code> : 指定字符串作为寻找文件或目录的范本样式。</li><li><code>-newer&lt;file or folder&gt;</code> : 查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录。</li><li><code>-nogroup</code> : 找出不属于本地主机群组识别码的文件或目录。</li><li><code>-noleaf</code> : 不去考虑目录至少需拥有两个硬连接存在。</li><li><code>-nouser</code> : 找出不属于本地主机用户识别码的文件或目录。</li><li><code>-ok&lt;command&gt;</code> : 此参数的效果和指定 <code>-exec</code> 类似，但在执行指令之前会先询问用户，若回答 <code>y</code> 或 <code>Y</code> ，则放弃执行命令。</li><li><code>-path&lt;template style&gt;</code> : 指定字符串作为寻找目录的范本样式。</li><li><code>-perm&lt;permission value&gt;</code> : 查找符合指定的权限数值的文件或目录。</li><li><code>-print</code> : 假设 <code>find</code> 指令的回传值为 <code>Ture</code> ，就将文件或目录名称列出到标准输出。格式为每列一个名称，每个名称前皆有 <code>./</code> 字符串。</li><li><code>-print0</code> : 假设 <code>find</code> 指令的回传值为 <code>Ture</code> ，就将文件或目录名称列出到标准输出。格式为全部的名称皆在同一行。</li><li><code>-printf&lt;output format&gt;</code> : 假设 <code>find</code> 指令的回传值为 <code>Ture</code> ，就将文件或目录名称列出到标准输出。格式可以自行指定。</li><li><code>-prune</code> : 不寻找字符串作为寻找文件或目录的范本样式；</li><li><code>-regex&lt;template style&gt;</code> : 指定字符串作为寻找文件或目录的范本样式。</li><li><code>-size&lt;file size&gt;</code> : 查找符合指定的文件大小的文件。</li><li><code>-true</code> : 将 find 指令的回传值皆设为 <code>True</code> 。</li><li><code>-type&lt;file type&gt;</code> : 只寻找符合指定的文件类型的文件。</li><li><code>-uid&lt;user id&gt;</code> : 查找符合指定的用户识别码的文件或目录。</li><li><code>-used&lt;day&gt;</code> : 查找文件或目录被更改之后在指定时间曾被存取过的文件或目录，单位以日计算。</li><li><code>-user&lt;owner name&gt;</code> : 查找符和指定的拥有者名称的文件或目录。</li><li><code>-version, --version</code> : 显示版本信息。</li><li><code>-xdev</code> : 将范围局限在先行的文件系统中。</li><li><code>-xtype&lt;file type&gt;</code> : 此参数的效果和指定 <code>-type</code> 参数类似，差别在于它针对符号连接检查。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Ops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thunk 函数</title>
      <link href="2020/09/13/thunkFunction/"/>
      <url>2020/09/13/thunkFunction/</url>
      
        <content type="html"><![CDATA[<p>编译器的求值策略通常分为传值调用以及传名调用，Thunk 函数是应用于编译器的传名调用实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体，这个临时函数就叫做 Thunk 函数。  </p><h2 id="求值策略"><a href="#求值策略" class="headerlink" title="求值策略"></a>求值策略</h2><p>编译器的求值策略通常分为传值调用以及传名调用，在下面的例子中，将一个表达式作为参数进行传递，传值调用以及传名调用中实现的方式有所不同。</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">s</span><span class="token punctuation">(</span><span class="token parameter">y</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>y <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span><span class="token punctuation">&#125;</span><span class="token function">s</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在上述的例子中，无论是使用传值调用还是使用传名调用，执行的结果都是一样的，但是其调用过程不同：  </p><ul><li>传值调用：首先计算 <code>x + 1</code> ，然后将计算结果 <code>2</code> 传递到 <code>s</code> 函数，即相当于调用 <code>s(2)</code> 。</li><li>传名调用：直接将 <code>x + 1</code> 表达式传递给 <code>y</code> ，使用时再计算 <code>x + 1</code> ，即相当于计算 <code>(x + 1) + 1</code> 。  </li></ul><p>传值调用与传名调用各有利弊，传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成没有必要的计算。传名调用可以解决这个问题，但是实现相对来说比较复杂。  </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">s</span><span class="token punctuation">(</span><span class="token parameter">y</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>y <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span><span class="token punctuation">&#125;</span><span class="token function">s</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在上面这个例子中，函数 <code>s</code> 并没有用到 <code>x + 2</code> 这个表达式求得的值，使用传名调用的话只将表达式传入而并未计算，只要在函数中没有用到 x + 2 这个表达式就不会计算，使用传值调用的话就会首先将 <code>x + 2</code> 的值计算然后传入，如果没有用到这个值，那么就多了一次没有必要的计算。Thunk 函数就是作为传名调用的实现而构建的，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体，这个临时函数就叫做 Thunk 函数。  </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">s</span><span class="token punctuation">(</span><span class="token parameter">y</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>y <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span><span class="token punctuation">&#125;</span><span class="token function">s</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 等同于</span><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">s</span><span class="token punctuation">(</span><span class="token parameter">thunk</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">thunk</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> <span class="token function-variable function">thunk</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">s</span><span class="token punctuation">(</span>thunk<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="JavaScript-中的-Thunk-函数"><a href="#JavaScript-中的-Thunk-函数" class="headerlink" title="JavaScript 中的 Thunk 函数"></a>JavaScript 中的 Thunk 函数</h2><p>JavaScript 中的求值策略是是传值调用，在 JavaScript 中使用 Thunk 函数需要手动进行实现且含义有所不同，在 JavaScript 中，Thunk 函数替换的不是表达式，而是多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数。  </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 假设一个延时函数需要传递一些参数</span><span class="token comment">// 通常使用的版本如下</span><span class="token keyword">var</span> <span class="token function-variable function">delayAsync</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">time<span class="token punctuation">,</span> callback<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> <span class="token function-variable function">callback</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">delayAsync</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> callback<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 使用 Thunk 函数</span><span class="token keyword">var</span> <span class="token function-variable function">thunk</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">time<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> <span class="token function-variable function">callback</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> delayAsyncThunk <span class="token operator">=</span> <span class="token function">thunk</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">delayAsyncThunk</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>实现一个简单的 Thunk 函数转换器，对于任何函数，只要参数有回调函数，就能写成 Thunk 函数的形式。  </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> <span class="token function-variable function">convertToThunk</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">funct</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token function">funct</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token keyword">var</span> <span class="token function-variable function">callback</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> delayAsyncThunk <span class="token operator">=</span> <span class="token function">convertToThunk</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">time<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> thunkFunct <span class="token operator">=</span> <span class="token function">delayAsyncThunk</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">thunkFunct</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><p>Thunk 函数在 ES6 之前可能应用比较少，但是在 ES6 之后，出现了 Generator 函数，通过使用 Thunk 函数就可以可以用于 Generator 函数的自动流程管理。首先是关于 Generator 函数的基本使用，调用一个生成器函数并不会马上执行它里面的语句，而是返回一个这个生成器的迭代器 <code>iterator</code> 对象，他是一个指向内部状态对象的指针。当这个迭代器的 <code>next()</code> 方法被首次（后续）调用时，其内的语句会执行到第一个（后续）出现 <code>yield</code> 的位置为止，<code>yield</code> 后紧跟迭代器要返回的值，也就是指针就会从函数头部或者上一次停下来的地方开始执行到下一个 <code>yield</code>。或者如果用的是 <code>yield*</code>，则表示将执行权移交给另一个生成器函数（当前生成器暂停执行）。  </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">yield</span> x <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">yield</span> x <span class="token operator">+</span> <span class="token number">20</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> x <span class="token operator">+</span> <span class="token number">30</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// f &#123;&lt;suspended>&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#123;value: 11, done: false&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#123;value: 21, done: false&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#123;value: 31, done: true&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#123;value: undefined, done: true&#125; // 可以无限 next()，但是 value 总为 undefined，done 总为 true</span></code></pre><p>由于 Generator 函数能够将函数的执行暂时挂起，那么他就完全可以操作一个异步任务，当上一个任务完成之后再继续下一个任务，下面这个例子就是将一个异步任务同步化表达，当上一个延时定时器完成之后才会进行下一个定时器任务，可以通过这种方式解决一个异步嵌套的问题，例如利用回调的方式需要在一个网络请求之后加入一次回调进行下一次请求，很容易造成回调地狱，而通过 Generator 函数就可以解决这个问题，事实上 async/await 就是利用的 Generator 函数以及 Promise 实现的异步解决方案。  </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> it <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> rand <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>it<span class="token punctuation">)</span> it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>rand<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> r1 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>r1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> r2 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>r2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> r3 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>r3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>it <span class="token operator">=</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>虽然上边的例子能够自动执行，但是不够方便，现在实现一个 Thunk 函数的自动流程管理，其自动帮我们进行回调函数的处理，只需要在 Thunk 函数中传递一些函数执行所需要的参数比如例子中的 <code>index</code>，然后就可以编写 Generator 函数的函数体，通过左边的变量接收 Thunk 函数中 <code>funct</code> 执行的参数，在使用 Thunk 函数进行自动流程管理时，必须保证 <code>yield</code> 后是一个 Thunk 函数。<br>关于自动流程管理 <code>run</code> 函数，首先需要知道在调用 <code>next()</code> 方法时，如果传入了参数，那么这个参数会传给上一条执行的 <code>yield</code> 语句左边的变量，在这个函数中，第一次执行 <code>next</code> 时并未传递参数，而且在第一个 <code>yield</code> 上边也并不存在接收变量的语句，无需传递参数，接下来就是判断是否执行完这个生成器函数，在这里并没有执行完，那么将自定义的 <code>next</code> 函数传入 <code>res.value</code> 中，这里需要注意 <code>res.value</code> 是一个函数，可以在下边的例子中将注释的那一行执行，然后就可以看到这个值是 <code>f(funct)&#123;...&#125;</code>，此时我们将自定义的 <code>next</code> 函数传递后，就将 <code>next</code> 的执行权限交予了 <code>f</code> 这个函数，在这个函数执行完异步任务后，会执行回调函数，在这个回调函数中会触发生成器的下一个 <code>next</code> 方法，并且这个 <code>next</code> 方法是传递了参数的，上文提到传入参数后会将其传递给上一条执行的 <code>yield</code> 语句左边的变量，那么在这一次执行中会将这个参数值传递给 <code>r1</code>，然后在继续执行 <code>next</code>，不断往复，直到生成器函数结束运行，这样就实现了流程的自动管理。  </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">thunkFunct</span><span class="token punctuation">(</span><span class="token parameter">index</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">funct</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">var</span> rand <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">funct</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>            rand<span class="token punctuation">:</span> rand<span class="token punctuation">,</span>            index<span class="token punctuation">:</span> index        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> r1 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">thunkFunct</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>r1<span class="token punctuation">.</span>index<span class="token punctuation">,</span> r1<span class="token punctuation">.</span>rand<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> r2 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">thunkFunct</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>r2<span class="token punctuation">.</span>index<span class="token punctuation">,</span> r2<span class="token punctuation">.</span>rand<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> r3 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">thunkFunct</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>r3<span class="token punctuation">.</span>index<span class="token punctuation">,</span> r3<span class="token punctuation">.</span>rand<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token parameter">generator</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token function">generator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> <span class="token function-variable function">next</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">var</span> res <span class="token operator">=</span> g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span>done<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token comment">// console.log(res.value);</span>        res<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">run</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件流模型</title>
      <link href="2020/09/11/eventStreamModel/"/>
      <url>2020/09/11/eventStreamModel/</url>
      
        <content type="html"><![CDATA[<p>事件捕获 (Event Capturing) 是一种从上而下的传播方式，以 <code>click</code> 事件为例，其会从最外层根节向内传播到达点击的节点，为从最外层节点逐渐向内传播直到目标节点的方式。<br>事件冒泡 (Event Bubbling) 是一种从下往上的传播方式，同样以 <code>click</code> 事件为例，事件最开始由点击的节点，然后逐渐向上传播直至最高层节点。  </p><h2 id="DOM0-级模型"><a href="#DOM0-级模型" class="headerlink" title="DOM0 级模型"></a>DOM0 级模型</h2><p>也称为原始事件模型，这种方式较为简单且兼容所有浏览器，但是却将界面与逻辑耦合在一起，可维护性差。  </p><pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>i1<span class="token punctuation">"</span></span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>alert(0)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>i2<span class="token punctuation">"</span></span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>alert(1)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>i3<span class="token punctuation">"</span></span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>alert(2)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span></code></pre><p>上面的示例中，当点击 <code>id</code> 为 <code>i3</code> 的 <code>&lt;div&gt;</code> 时，浏览器会依次弹出 <code>2 1 0</code> 。  </p><h2 id="IE-事件模型"><a href="#IE-事件模型" class="headerlink" title="IE 事件模型"></a>IE 事件模型</h2><p>IE8 及之前的版本是不支持捕获事件的，IE 事件模型共有两个过程：<br>事件处理阶段 (target phase)，事件到达目标元素，触发目标元素的监听事件。<br>事件冒泡阶段 (bubbling phase) 事件从目标元素冒泡到 <code>document</code> ，依次执行经过的节点绑定的事件。 </p><h2 id="DOM2-级模型"><a href="#DOM2-级模型" class="headerlink" title="DOM2 级模型"></a>DOM2 级模型</h2><p>DOM2 事件模型是 W3C 制定的标准模型，支持捕获型事件和冒泡型事件，调用事件的处理阶段依次为捕获、目标、冒泡。  </p><pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>i1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>i2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>i3<span class="token punctuation">"</span></span><span class="token attr-name">"</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">    document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token parameter">e</span> <span class="token operator">=></span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'i1'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token parameter">e</span> <span class="token operator">=></span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'i2'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token parameter">e</span> <span class="token operator">=></span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'i3'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token parameter">e</span> <span class="token operator">=></span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><p>上面的示例中，当点击 <code>id</code> 为 <code>i3</code> 的 <code>&lt;div&gt;</code> 时，浏览器会依次弹出 <code>0 1 3 2</code> ， <code>addEventListener</code> 方法的第三个参数为声明绑定的事件为捕获型还是冒泡型，默认为 <code>false</code> ，也就是冒泡型。<br><code>document</code> 对象与 <code>i1</code> 节点绑定的是捕获型的监听事件， <code>i2</code> 与 <code>i3</code> 节点绑定的是冒泡型的事件，事件传递的顺序为：</p><pre class="language-none"><code class="language-none">window ── document ── html ── body ── i1 ── i2 ── i3 ── i2 ── i1 ── body ── html ── document ── window|                                                  |                                                 |└──────────────────────────────────────────────────┴─────────────────────────────────────────────────┘                     捕获阶段                     目标阶段                    冒泡阶段</code></pre><p>从 <code>window</code> 到 <code>i3</code> 的过程为捕获阶段，依次执行了过程中绑定的事件，本例中执行了 <code>alert(0)</code> 与 <code>alert(1)</code> ，然后到达目标阶段的 <code>i3</code> , 执行 <code>i3</code> 绑定的事件 <code>alert(3)</code> ，然后从 <code>i3</code> 到 <code>window</code> 的阶段为冒泡阶段，执行了绑定的 <code>alert(2)</code> ，执行顺序即为 <code>0 1 3 2</code> 。</p><h2 id="绑定监听事件使用的区别"><a href="#绑定监听事件使用的区别" class="headerlink" title="绑定监听事件使用的区别"></a>绑定监听事件使用的区别</h2><p>在 DOM0 中直接绑定函数执行时，后定义的函数会覆盖前边绑定的函数，下面这个例子只执行 <code>alert(1)</code> 而不执行 <code>alert(0)</code> 。 <code>click()</code> 是一个对象事件，点击即触发 <code>onclick()</code> 绑定的方法， <code>onclick()</code> 是对象的属性，将其绑定函数后即为 <code>click()</code> 事件触发后执行的方法。  </p><pre class="language-js" data-language="js"><code class="language-js">document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"i1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token comment">// 被覆盖</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"i1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token comment">// 执行</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包</title>
      <link href="2020/09/10/closures/"/>
      <url>2020/09/10/closures/</url>
      
        <content type="html"><![CDATA[<p>函数和对其词法环境 (lexical environment) 的引用捆绑在一起构成<strong>闭包 (closure)</strong>，也就是说，闭包可以让你从内部函数访问外部函数作用域。在 JavaScript，函数在每次创建时生成闭包。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。</p><h2 id="定义闭包"><a href="#定义闭包" class="headerlink" title="定义闭包"></a>定义闭包</h2><p>为了定义一个闭包，首先需要一个函数来套一个匿名函数。闭包是需要使用局部变量的，定义使用全局变量就失去了使用闭包的意义，最外层定义的函数可实现局部作用域从而定义局部变量，函数外部无法直接访问内部定义的变量。  </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">student</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">"Bronya"</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> <span class="token function-variable function">sayMyName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// sayMyName 作为内部函数，有权访问父级函数作用域 student 中的变量</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sayMyName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> sayMyName<span class="token punctuation">;</span> <span class="token comment">// return 是为了让外部能访问闭包，挂载到 window 对象也可以 </span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> stu <span class="token operator">=</span> <span class="token function">student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">stu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Bronya</span></code></pre><p>可以看到定义在函数内部的 name 变量并没有被销毁，我们仍然可以在外部使用函数访问这个局部变量，使用闭包，可以把局部变量驻留在内存中，从而避免使用全局变量。全局变量污染会导致应用程序不可预测性，每个模块都可调用必将引来灾难。  </p><h2 id="词法环境"><a href="#词法环境" class="headerlink" title="词法环境"></a>词法环境</h2><p>闭包共享相同的函数定义，但是保存了不同的词法环境 lexical environment。</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">student</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> <span class="token function-variable function">sayMyName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> sayMyName<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> stu1 <span class="token operator">=</span> <span class="token function">student</span><span class="token punctuation">(</span><span class="token string">"Bronya"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> stu2 <span class="token operator">=</span> <span class="token function">student</span><span class="token punctuation">(</span><span class="token string">"Kiana"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">stu1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Bronya</span><span class="token function">stu2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Kiana</span></code></pre><h2 id="模拟私有方法"><a href="#模拟私有方法" class="headerlink" title="模拟私有方法"></a>模拟私有方法</h2><p>在面向对象的语言中，例如 Java、PHP 等，都是支持定义私有成员的，即只有类内部能够访问，而无法被外部类访问。JavaScript 并未原生支持定义私有成员，但是可以使用闭包来模拟实现，私有方法不仅仅有利于限制对代码的访问，还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分。  </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">student</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> <span class="token constant">HP</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> <span class="token function-variable function">addHP</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">++</span><span class="token constant">HP</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">var</span> <span class="token function-variable function">decHP</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">--</span><span class="token constant">HP</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>        addHP<span class="token punctuation">,</span>        decHP    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> stu <span class="token operator">=</span> <span class="token function">student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stu<span class="token punctuation">.</span><span class="token constant">HP</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined 不允许直接访问</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stu<span class="token punctuation">.</span><span class="token function">addHP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 101</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stu<span class="token punctuation">.</span><span class="token function">decHP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 100</span></code></pre><h2 id="回调机制"><a href="#回调机制" class="headerlink" title="回调机制"></a>回调机制</h2><p>Js 的闭包为回调机制提供了支持，无论函数是否立马被调用，这个闭包都不会被释放。而且在 Js 里，无论把 callback 函数作为参数传递给其他函数，或者作为返回值返回，以便于之后调用，都是合法的。  </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">localContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> localVal <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> <span class="token function-variable function">callback</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>localVal<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span>callback<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span><span class="token punctuation">&#125;</span><span class="token function">localContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在本例中，callback 函数与其词法环境构成了闭包，其词法环境中存在的变量 localVal = 1 在函数 callback 作为回调函数传递时并没有被立即释放，而可以在回调执行时继续使用，这就是闭包为回调机制提供了支持。  </p><h2 id="循环创建闭包问题"><a href="#循环创建闭包问题" class="headerlink" title="循环创建闭包问题"></a>循环创建闭包问题</h2><p>在 ECMAScript 2015 引入 let 关键字之前，只有函数作用域和全局作用域，函数作用域中又可以继续嵌套函数作用域，在 for 并未具备局部作用域，于是有一个常见的闭包创建问题：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> coun <span class="token operator">=</span> <span class="token function">counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>coun<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3 3 3</span><span class="token punctuation">&#125;</span></code></pre><h3 id="解决方法一：使用匿名函数新建函数作用域"><a href="#解决方法一：使用匿名函数新建函数作用域" class="headerlink" title="解决方法一：使用匿名函数新建函数作用域"></a>解决方法一：使用匿名函数新建函数作用域</h3><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">i</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> i<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> coun <span class="token operator">=</span> <span class="token function">counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>coun<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0 1 2</span><span class="token punctuation">&#125;</span></code></pre><h3 id="解决方法二：使用-let-关键字"><a href="#解决方法二：使用-let-关键字" class="headerlink" title="解决方法二：使用 let 关键字"></a>解决方法二：使用 let 关键字</h3><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> coun <span class="token operator">=</span> <span class="token function">counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>coun<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0 1 2</span><span class="token punctuation">&#125;</span></code></pre><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>内存泄露是指你用不到（访问不到）的变量，依然占据着内存空间，不能被再次利用起来。<br>闭包引用的变量应该是需要使用的，不应该属于内存泄漏，但是在 IE8 浏览器中 JScript.dll 引擎使用会出现一些问题，造成内存泄漏。  </p><h2 id="性能考量"><a href="#性能考量" class="headerlink" title="性能考量"></a>性能考量</h2><p>如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。<br>在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用时，方法都会被重新赋值一次。  </p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>匿名函数与自执行函数</title>
      <link href="2020/09/08/anonymousFunction/"/>
      <url>2020/09/08/anonymousFunction/</url>
      
        <content type="html"><![CDATA[<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>匿名函数就是指的没有名字的函数，即定义函数对象时不定义函数体名字，但是必须将匿名函数作为表达式赋予一定操作，比如将其作为变量值或者让其自执行，否则这次定义将无意义，解释器也会抛出异常。<br>函数表达式中的 <code>function</code> 则不会出现函数提升（但是赋予的变量会提升）。经由 JS 解释器逐行解释，到了这一句才会赋值函数表达式。因此如果调用在函数表达式之前，则会调用失败。  </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 定义匿名函数 函数表达式</span><span class="token keyword">var</span> <span class="token function-variable function">s</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="自执行函数"><a href="#自执行函数" class="headerlink" title="自执行函数"></a>自执行函数</h2><p>自执行即函数定义与创建合用为一体，创建完成即调用。</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span></code></pre><p><strong>包围函数的第一段括号返回一个匿名函数，随后第二个括号将其调用。</strong>这种方式可以缩小作用域，ES6 之前 JS 仅有全局作用域与函数作用域，显然将所有变量交予全局作用域是不合适的，而定义函数再调用再销毁函数操作了三步，使用自执行匿名函数可以将上述三步操作定义后即完成。</p><h3 id="常用的自执行方式"><a href="#常用的自执行方式" class="headerlink" title="常用的自执行方式"></a>常用的自执行方式</h3><p>只要能够将匿名函数作为一个表达式出现，在后边加入 <code>()</code> 就能够将其自执行</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 这种经常用来构建沙箱模式</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 常用方式 传参操作</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">i</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>由于括号 <code>()</code> 和 JS 的 <code>&amp;&amp;</code> 、异或、逗号等操作符在函数表达式和函数声明上是没有歧义的，所以一旦解析器知道其中一个已经是表达式了，其它的也都默认为表达式了  </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> <span class="token function-variable function">i</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token boolean">true</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token boolean">false</span> <span class="token operator">||</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如果你不在意返回值，或者不怕难以阅读，甚至可以在 <code>function</code> 前面加一元操作符号  </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token operator">!</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">~</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">-</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>使用 new 关键字</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">new</span> <span class="token class-name">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">new</span> <span class="token class-name">function</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 中的变量提升</title>
      <link href="2020/09/07/hoistedVariablesInJs/"/>
      <url>2020/09/07/hoistedVariablesInJs/</url>
      
        <content type="html"><![CDATA[<p>JavaScript 中的一切声明 ( <code>var</code> , <code>let</code> , <code>const</code> , <code>function</code> , <code>function*</code> , <code>class</code> ) 均存在变量提升 (hoisted)。<br>下面的例子中，变量 a 的声明被隐式提升到作用域最顶端并被初始化为 <code>undefined</code> ， <code>a</code> 并未抛出异常，而未声明的变量 <code>b</code> 抛出 <code>ReferenceError</code> 异常。  </p><pre class="language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ReferenceError: b is not defined</span></code></pre><p><code>var</code> / <code>function</code> / <code>function*</code> 与 <code>let</code> / <code>const</code> / <code>class</code> 的不同在于是否初始化。  </p><p><code>var</code> 、 <code>let</code> 和 <code>const</code> 的「创建」过程都被提升了，但是 <code>let</code> 和 <code>const</code> 并没有初始化， <code>var</code> 被初始化为 <code>undefined</code> 。<br>因此访问 <code>var</code> 声明的变量时，不会报 <code>ReferenceError</code> 异常，而使用 <code>let</code> , <code>const</code> , <code>class</code> 声明的变量，被提升后不会被初始化，这些变量所处的状态被称为暂时性死区 (Temporal Dead Zone, TDZ)，此时如果访问这些变量会抛出 <code>ReferenceError</code> 异常，看上去就像没被提升一样。</p><pre class="language-js" data-language="js"><code class="language-js">x <span class="token operator">=</span> y <span class="token operator">=</span> <span class="token string">"global"</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    x<span class="token punctuation">;</span> <span class="token comment">// undefined</span>    y<span class="token punctuation">;</span> <span class="token comment">// Reference error: y is not defined</span>    <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token string">"local"</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token string">"local"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="函数声明提升"><a href="#函数声明提升" class="headerlink" title="函数声明提升"></a>函数声明提升</h2><h3 id="定义函数-声明式"><a href="#定义函数-声明式" class="headerlink" title="定义函数 声明式"></a>定义函数 声明式</h3><p>声明式会导致函数提升，function 会被解释器优先编译。即我们用声明式写函数，可以在任何区域声明，不会影响我们调用<br>函数声明会将声明和赋值都提前，也就是整个函数体都会被提升到作用域顶部：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token function">s</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span><span class="token keyword">function</span> <span class="token function">s</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="定义匿名函数-函数表达式"><a href="#定义匿名函数-函数表达式" class="headerlink" title="定义匿名函数 函数表达式"></a>定义匿名函数 函数表达式</h3><p>函数表达式中的 function 则不会出现函数提升（但是赋予的变量会提升）。经由 JS 解释器逐行解释，到了这一句才会赋值函数表达式。因此如果调用在函数表达式之前，则会调用失败。</p><pre class="language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span><span class="token keyword">var</span> <span class="token function-variable function">s</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">s</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// f s()&#123;console.log(1);&#125;</span></code></pre><p>对于上述定义方式调用 s() 并无区别，但是定义函数会存在函数体的提升，而定义匿名函数时只会将定义变量提升，赋值部分不会提升。</p><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> <span class="token function-variable function">s</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">s</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">s</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0</span></code></pre><p>在 JS 引擎中的执行优先级是 <code>变量声明--&gt;函数声明--&gt;变量赋值</code></p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> s<span class="token punctuation">;</span> <span class="token comment">// 变量声明</span><span class="token keyword">function</span> <span class="token function">s</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//函数声明</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function-variable function">s</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 变量赋值</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">s</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apply(), Call(), Bind() 的区别</title>
      <link href="2020/09/06/differenceBetweenApplyCallBind/"/>
      <url>2020/09/06/differenceBetweenApplyCallBind/</url>
      
        <content type="html"><![CDATA[<p>每个 <code>Function</code> 对象都存在 <code>apply()</code> , <code>call()</code> , <code>bind()</code> 方法，其作用都是可以在特定的作用域中调用函数，等于设置函数体内 <code>this</code> 对象的值，以扩充函数赖以运行的作用域。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p><code>apply()</code> , <code>call()</code> , <code>bind()</code> 都能改变函数对象的 <code>this</code> 指向：</p><pre class="language-js" data-language="js"><code class="language-js">window<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"A"</span><span class="token punctuation">;</span> <span class="token comment">//挂载到 window 对象的 name</span>document<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"B"</span><span class="token punctuation">;</span> <span class="token comment">//挂载到 document 对象的 name</span><span class="token keyword">const</span> s <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 自定义一个对象 s</span>    name<span class="token punctuation">:</span> <span class="token string">"C"</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> rollCall <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    name<span class="token punctuation">:</span> <span class="token string">"Teacher"</span><span class="token punctuation">,</span>    <span class="token function-variable function">sayName</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>rollCall<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Teacher</span><span class="token comment">// apply</span>rollCall<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//A //不传参默认绑定 window</span>rollCall<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//A //绑定 window 对象</span>rollCall<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//B //绑定 document 对象</span>rollCall<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//C //绑定自定义对象</span><span class="token comment">// call</span>rollCall<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//A //不传参默认绑定 window</span>rollCall<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//A //绑定 window 对象</span>rollCall<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//B //绑定 document 对象</span>rollCall<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//C //绑定自定义对象</span><span class="token comment">// bind //最后一个 () 是为让其执行</span>rollCall<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//A //不传参默认绑定 window</span>rollCall<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//A //绑定 window 对象</span>rollCall<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//B //绑定 document 对象</span>rollCall<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//C //绑定自定义对象</span></code></pre><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>虽然 apply()、call()、bind() 都能够达到改变 this 指针的目的，但是其使用还是有区别的。</p><pre class="language-js" data-language="js"><code class="language-js">window<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Teacher"</span><span class="token punctuation">;</span><span class="token keyword">var</span> rollCall <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token function-variable function">sayAllName</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        args<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>apply 与 call 传参方式不同，apply 将参数作为一个数组传递：</p><pre class="language-js" data-language="js"><code class="language-js">rollCall<span class="token punctuation">.</span><span class="token function">sayAllName</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"A"</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Teacher A B C</span></code></pre><p>call 将参数直接传递，使用逗号分隔：</p><pre class="language-js" data-language="js"><code class="language-js">rollCall<span class="token punctuation">.</span><span class="token function">sayAllName</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> <span class="token string">"A"</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Teacher A B C</span></code></pre><p>bind 仅将对象绑定，并不立即执行，其返回值是一个<strong>函数</strong>，传参方式与 call 相同：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> convertThis <span class="token operator">=</span> rollCall<span class="token punctuation">.</span><span class="token function">sayAllName</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> <span class="token string">"A"</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">convertThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Teacher A B C</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型与原型链</title>
      <link href="2020/09/05/prototypeInJS/"/>
      <url>2020/09/05/prototypeInJS/</url>
      
        <content type="html"><![CDATA[<p><code>JavaScript</code> 常被描述为一种基于原型的语言 (prototype-based language)——每个对象拥有一个<strong>原型对象</strong>，对象以其原型为模板、从原型继承方法和属性。<br>原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为<strong>原型链</strong> (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。  </p><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p><code>JavaScript</code> 有七种基本类型 <code>String</code> 、 <code>Number</code> 、 <code>Boolean</code> 、 <code>Null</code> 、 <code>Undefined</code> 、 <code>Symbol</code> 、 <code>Object</code> ，前六种为基本数据类型， <code>Object</code> 为引用类型。函数本质上是 <code>Object</code> 类型， <code>Object</code> 继承自己， <code>Function</code> 继承自己，并且相互继承对方，即 <code>Object</code> 和 <code>Function</code> 既是函数也是对象。  </p><pre class="language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Function <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object <span class="token keyword">instanceof</span> <span class="token class-name">Function</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></code></pre><p><code>Object</code> 是 <code>Function</code> 的实例，而 <code>Function</code> 是它自己的实例。  </p><pre class="language-js" data-language="js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ƒ () &#123; [native code] &#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Object</span></code></pre><h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p>每个函数对象都会有一个 <code>prototype</code> 属性， <code>prototype</code> 就是调用构造函数所创建的那个实例对象的原型， <code>prototype</code> 可以让所有对象实例共享它所包含的属性和方法。  </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token class-name">Student</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">from</span><span class="token punctuation">:</span> <span class="token string">"sdust"</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> stu1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> stu2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stu1<span class="token punctuation">.</span>from<span class="token punctuation">)</span> <span class="token comment">// sdust</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stu2<span class="token punctuation">.</span>from<span class="token punctuation">)</span> <span class="token comment">// sdust</span></code></pre><p>JS 中所有的对象，都有一个 <code>__proto__</code> 属性，指向实例对象的构造函数原型。  </p><h2 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h2><p><code>__proto__</code> 是原型链查询中实际用到的，它总是指向 <code>prototype</code> ，就是指向构造函数 <code>Student</code> 的原型对象 <code>prototype</code> 。例如实例化的 <code>stu</code> 会使用 <code>__proto__</code> 向 <code>Student</code> 的 <code>prototype</code> 寻找方法或属性。若 <code>stu</code> 寻找到了调用的方法或属性，则不会使用 <code>__proto__</code> 寻找原型对象。  </p><h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>每个原型都有一个 <code>constructor</code> 属性指向关联的构造函数 <code>Student</code> ，实例的 <code>constructor</code> 指向构造函数 <code>Student</code></p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> stu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Student</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Student<span class="token punctuation">)</span> <span class="token comment">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stu<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Student<span class="token punctuation">)</span> <span class="token comment">// true</span></code></pre><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>原型链可以简单理解为将原型连成一条链， <code>js</code> 每一次获取对象中的属性都是一次查询过程，如果在自有属性中找不到就会去原型对象中查找，如果原型对象中还查不到，就回去原型对象的原型中查找，也就是按照原型链查找，直到查找到原型链的顶端，也就是 <code>Object</code> 的原型。</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>parentInfo <span class="token operator">=</span> <span class="token string">"parent"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getParentInfo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>parentInfo<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>childInfo <span class="token operator">=</span> <span class="token string">"child"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>parent<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getChildInfo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>childInfo<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>child<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span><span class="token function">getChildInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// child</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span><span class="token function">getParentInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// parent</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>parentInfo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// parent</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> child<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> parent<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span><span class="token comment">// function student()&#123;&#125;</span><span class="token comment">// console.log(student.__proto__ === Function.prototype) // true</span><span class="token comment">// console.log(Function.__proto__ === Function.prototype) // true</span><span class="token comment">// console.log(Object.__proto__ === Function.prototype) // true</span><span class="token comment">// console.log(Object.prototype.__proto__ === null) // true</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Map 与 WeakMap</title>
      <link href="2020/09/04/mapAndWeakmap/"/>
      <url>2020/09/04/mapAndWeakmap/</url>
      
        <content type="html"><![CDATA[<p><code>Map</code> 对象用来保存键值对，并且能够记住键的原始插入顺序，任何对象或者原始值都可以作为键或者是值。<br><code>WeakMap</code> 对象同样用来保存键值对，对于键是弱引用的而且必须为一个对象，而值可以是任意的对象或者原始值。  </p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><code>Map</code> 对象类似于一个普通的键值对的 <code>Object</code> 对象，也是键值对的集合，但是他们之间有一些重要的区别：<br>| 描述 | Map | Object |<br>|——-|——-|——–|<br>| 意外的键 | <code>Map</code> 默认情况不包含任何键，只包含显式插入的键。 | 一个 <code>Object</code> 有一个原型，原型链上的键名有可能和在对象上的设置的键名产生冲突。 |<br>| 键的类型 | 一个 <code>Map</code> 的键可以是任意值，包括函数、对象或任意基本类型。 | 一个 <code>Object</code> 的键必须是一个 <code>String</code> 或是 <code>Symbol。</code> |<br>| 键的顺序 | <code>Map</code> 中的 <code>key</code> 是有序的，当迭代的时候，一个 <code>Map</code> 对象以插入的顺序返回键值。| 一个 <code>Object</code> 的键的迭代顺序需要通过键的类型与创建的顺序来确定。 |<br>| 键值数量 | <code>Map</code> 的键值对个数可以轻易地通过 <code>size</code> 属性获取。| <code>Object</code> 的键值对个数只能手动计算。 |<br>| 迭代 | <code>Map</code> 是 <code>iterable</code> 的，所以可以直接被迭代。 | 迭代一个 <code>Object</code> 需要以某种方式获取它的键然后才能迭代。 |<br>| 性能 | <code>Map</code> 在频繁增删键值对的场景下表现更好。 | <code>Object</code> 在频繁添加和删除键值对的场景下未作出优化。 |<br>注：关于一个 <code>Object</code> 的键的迭代顺序问题，在 ES6 以后，对象保留了 <code>String</code> 与 <code>Symbol</code> 的创建顺序，当创建的对象仅有 <code>String</code> 或者 <code>Symbol</code> 时，迭代顺序与创建顺序相同，当对象中两种类型都存在时， <code>String</code> 总是在前，当 <code>String</code> 可以被转换为 <code>Number</code> 时，这些键在迭代时处于最前，且会按照数字的顺序进行迭代。</p><h3 id="属性与方法"><a href="#属性与方法" class="headerlink" title="属性与方法"></a>属性与方法</h3><table><thead><tr><th>属性和方法</th><th>描述</th></tr></thead><tbody><tr><td><code>Map.prototype.constructor</code></td><td>返回构造函数</td></tr><tr><td><code>Map.prototype.size</code></td><td>返回 <code>Map</code> 对象的键值对的数量。</td></tr><tr><td><code>Map.prototype.clear()</code></td><td>移除 <code>Map</code> 对象的所有键值对 。</td></tr><tr><td><code>Map.prototype.delete(key)</code></td><td>如果 <code>Map</code> 对象中存在该元素，则移除它并返回 <code>true</code> ，否则如果该元素不存在则返回 <code>false</code> 。</td></tr><tr><td><code>Map.prototype.entries()</code></td><td>返回一个新的 <code>Iterator</code> 对象，它按插入顺序包含了 <code>Map</code> 对象中每个元素的 <code>[key, value]</code> 数组。</td></tr><tr><td><code>Map.prototype.forEach(callback[, thisArg])</code></td><td>按插入顺序，为 <code>Map</code> 对象里的每一键值对调用一次 <code>callback</code> 函数，如果为 <code>forEach</code> 提供了 <code>thisArg</code> ，它将在每次回调中作为 <code>this</code> 值。</td></tr><tr><td><code>Map.prototype.get(key)</code></td><td>返回键对应的值，如果不存在，则返回 <code>undefined</code> 。</td></tr><tr><td><code>Map.prototype.has(key)</code></td><td>返回一个布尔值，表示 <code>Map</code> 实例是否包含键对应的值。</td></tr><tr><td><code>Map.prototype.keys()</code></td><td>返回一个新的 <code>Iterator</code> 对象，它按插入顺序包含了 <code>Map</code> 对象中每个元素的键。</td></tr><tr><td><code>Map.prototype.set(key, value)</code></td><td>设置 <code>Map</code> 对象中键的值，返回该 <code>Map</code> 对象。</td></tr><tr><td><code>Map.prototype.values()</code></td><td>返回一个新的 <code>Iterator</code> 对象，它按插入顺序包含了 <code>Map</code> 对象中每个元素的值。</td></tr><tr><td><code>Map.prototype[@@iterator]()</code></td><td>返回一个新的 <code>Iterator</code> 对象，它按插入顺序包含了 <code>Map</code> 对象中每个元素的 <code>[key, value]</code> 数组。</td></tr></tbody></table><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> stringKey <span class="token operator">=</span> <span class="token string">"s"</span><span class="token punctuation">;</span><span class="token keyword">const</span> objectKey <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>m<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>stringKey<span class="token punctuation">,</span> <span class="token string">"stringValue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>objectKey<span class="token punctuation">,</span> <span class="token string">"objectValue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>stringKey<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// stringValue</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>objectKey<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// objectValue</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span> value<span class="token punctuation">]</span> <span class="token keyword">of</span> m<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* s stringValue &#123;&#125; objectValue*/</span><span class="token keyword">const</span> m2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span>    <span class="token punctuation">[</span><span class="token string">"stringKey"</span><span class="token punctuation">,</span> <span class="token string">"stringValue"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">"objectValue"</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Map(2) &#123;"stringKey" => "stringValue", &#123;…&#125; => "objectValue"&#125;</span><span class="token keyword">const</span> m3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span>    <span class="token operator">...</span>m<span class="token punctuation">,</span>    <span class="token operator">...</span>m2<span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token string">"stringKey"</span><span class="token punctuation">,</span> <span class="token string">"coverStringValue"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">"&#123;&#125; !== &#123;&#125;"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">NaN</span><span class="token punctuation">,</span> <span class="token string">"NaN !== NaN But key(NaN) === key(NaN)"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Map(6) &#123;"s" => "stringValue", &#123;…&#125; => "objectValue", "stringKey" => "coverStringValue", &#123;…&#125; => "objectValue", &#123;…&#125; => "&#123;&#125; !== &#123;&#125;", NaN => "NaN !== NaN But key(NaN) === key(NaN)"&#125;</span></code></pre><h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p><code>WeakMap</code> 的 <code>key</code> 只能是 <code>Object</code> 类型，原始数据类型不能作为 <code>key</code> 。 <code>WeakMap</code> 持有的是每个键对象的弱引用，这意味着在没有其他引用存在时垃圾回收能正确进行， <code>WeakMap</code> 用于映射的 <code>key</code> 只有在其没有被回收时才是有效的，正由于弱引用， <code>WeakMap</code> 的 <code>key</code> 是不可枚举的，没有方法能给出所有的 <code>key</code> 。 简单来说，有时需要在某个对象上面存放一些对象，但是这会形成对于这个对象的引用，一旦不再需要这个对象，我们就必须手动删除这个引用，否则垃圾回收机制无法释放对象占用的内存， <code>WeakMap</code> 的设计就是解决这个问题的，它的键所引用的对象都是弱引用，垃圾回收机制不将该引用考虑在内，因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存，此时 <code>WeakMap</code> 里边所对应的键值都会消失，不需要手动删除引用。如果需要在对象上添加对象而又不想干扰垃圾回收机制的话，就可以使用 <code>WeakMap</code> 。</p><h3 id="属性与方法-1"><a href="#属性与方法-1" class="headerlink" title="属性与方法"></a>属性与方法</h3><table><thead><tr><th>属性和方法</th><th>描述</th></tr></thead><tbody><tr><td><code>WeakMap.prototype.constructor</code></td><td>返回构造函数。</td></tr><tr><td><code>WeakMap.prototype.delete(key)</code></td><td>移除 key 的关联对象。</td></tr><tr><td><code>WeakMap.prototype.get(key)</code></td><td>返回 <code>key</code> 关联对象，没有 <code>key</code> 关联对象时返回 <code>undefined</code> 。</td></tr><tr><td><code>WeakMap.prototype.has(key)</code></td><td>根据是否有 <code>key</code> 关联对象返回一个 <code>Boolean</code> 值。</td></tr><tr><td><code>WeakMap.prototype.set(key, value)</code></td><td>在 <code>WeakMap</code> 中设置一组 <code>key</code> 关联对象，返回这个 <code>WeakMap</code> 对象。</td></tr></tbody></table><h3 id="内存回收实例"><a href="#内存回收实例" class="headerlink" title="内存回收实例"></a>内存回收实例</h3><h4 id="WeakMap-示例代码"><a href="#WeakMap-示例代码" class="headerlink" title="WeakMap 示例代码"></a>WeakMap 示例代码</h4><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> wm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> key <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>wm<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">6</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 存放一个大数组</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>wm<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// (6291456) [empty × 6291456]</span>key <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>wm<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span></code></pre><h4 id="WeakMap-内存回收实例"><a href="#WeakMap-内存回收实例" class="headerlink" title="WeakMap 内存回收实例"></a>WeakMap 内存回收实例</h4><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">/** node --expose-gc **/</span> <span class="token comment">// 启动 node 环境 手动调用垃圾回收机制</span>global<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 首先调用一次垃圾回收</span>process<span class="token punctuation">.</span><span class="token function">memoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 查看内存占用 heapUsed 约 3M</span><span class="token comment">/*&#123;  rss: 24076288,  heapTotal: 5222400,  heapUsed: 3027360,  external: 1568683,  arrayBuffers: 99508&#125;*/</span><span class="token keyword">const</span> wm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> key <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>wm<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">6</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 存放一个大数组</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>wm<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// (6291456) [empty × 6291456]</span>process<span class="token punctuation">.</span><span class="token function">memoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// heapUsed 约 53M</span><span class="token comment">/*&#123;  rss: 75124736,  heapTotal: 55558144,  heapUsed: 53937808,  external: 1568930,  arrayBuffers: 140675&#125;*/</span>global<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 手动执行一次垃圾回收</span>process<span class="token punctuation">.</span><span class="token function">memoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// heapUsed 约 53M</span><span class="token comment">/*&#123;  rss: 74907648,  heapTotal: 55558144,  heapUsed: 53360392,  external: 1568810,  arrayBuffers: 156939&#125;*/</span>key <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 解除引用</span>global<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 执行垃圾回收</span>process<span class="token punctuation">.</span><span class="token function">memoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// heapUsed 约 3M 内存已回收</span><span class="token comment">/*&#123;  rss: 24391680,  heapTotal: 4960256,  heapUsed: 2960104,  external: 1568814,  arrayBuffers: 181519&#125;*/</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>wm<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span></code></pre><h4 id="Map-内存回收实例"><a href="#Map-内存回收实例" class="headerlink" title="Map 内存回收实例"></a>Map 内存回收实例</h4><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">/** node --expose-gc **/</span> <span class="token comment">// 启动 node 环境 手动调用垃圾回收机制</span>global<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 首先调用一次垃圾回收</span>process<span class="token punctuation">.</span><span class="token function">memoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 查看内存占用 heapUsed 约 2.6M</span><span class="token comment">/*&#123;  rss: 23097344,  heapTotal: 8052736,  heapUsed: 2672504,  external: 1531483,  arrayBuffers: 34073&#125;*/</span><span class="token keyword">const</span> m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> key <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>m<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">6</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 存放一个大数组</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// (6291456) [empty × 6291456]</span>process<span class="token punctuation">.</span><span class="token function">memoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// heapUsed 约 53M</span><span class="token comment">/*&#123;  rss: 73863168,  heapTotal: 55558144,  heapUsed: 53622640,  external: 1531615,  arrayBuffers: 75125&#125;*/</span>global<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 手动执行一次垃圾回收</span>process<span class="token punctuation">.</span><span class="token function">memoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// heapUsed 约 53M</span><span class="token comment">/*&#123;  rss: 73506816,  heapTotal: 55558144,  heapUsed: 53239920,  external: 1531505,  arrayBuffers: 91399&#125;*/</span>key <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 解除引用</span>global<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 执行垃圾回收</span>process<span class="token punctuation">.</span><span class="token function">memoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// heapUsed 约 53M 内存未回收</span><span class="token comment">/*&#123;  rss: 73465856,  heapTotal: 55296000,  heapUsed: 53143568,  external: 1531510,  arrayBuffers: 115980&#125;*/</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined // 此处是 undefined，这是因为 key 值的改变，而在这个 Map 实例对象中依然存在 &#123;&#125; => Array 的键值对，且键值对为强引用，内存未回收</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Map(1) &#123;&#123;…&#125; => Array(6291456)&#125;</span>m<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 回收内存</span>global<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 执行垃圾回收</span>process<span class="token punctuation">.</span><span class="token function">memoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// heapUsed 约 2.8M 内存已回收</span><span class="token comment">/*&#123;  rss: 23887872,  heapTotal: 4960256,  heapUsed: 2883592,  external: 1560363,  arrayBuffers: 156853&#125;*/</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Map(0) &#123;&#125;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Set 与 WeakSet</title>
      <link href="2020/09/02/setAndWeakset/"/>
      <url>2020/09/02/setAndWeakset/</url>
      
        <content type="html"><![CDATA[<p><code>Set</code> 对象允许存储任何类型的唯一值，无论是原始值或者是对象引用， <code>Set</code> 对象中的值不会重复。<br><code>WeakSet</code> 对象允许存储对象弱引用的唯一值， <code>WeakSet</code> 对象中的值同样不会重复，且只能保存对象的弱引用。  </p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><code>Set</code> 对象是值的集合，可以按照<strong>插入的顺序</strong>迭代它的元素， <code>Set</code> 中的元素只会出现一次，即 <code>Set</code> 中的元素是唯一的，常用来作数组去重。</p><h3 id="属性与方法"><a href="#属性与方法" class="headerlink" title="属性与方法"></a>属性与方法</h3><table><thead><tr><th>属性和方法</th><th>功能</th></tr></thead><tbody><tr><td><code>Set.prototype.constructor</code></td><td>返回构造函数。</td></tr><tr><td><code>Set.prototype.size</code></td><td>返回 <code>Set</code> 对象的值的个数。</td></tr><tr><td><code>Set.prototype.add(value)</code></td><td>在 <code>Set</code> 对象尾部添加一个元素，返回该 <code>Set</code> 对象。</td></tr><tr><td><code>Set.prototype.clear()</code></td><td>移除 <code>Set</code> 对象内的所有元素。</td></tr><tr><td><code>Set.prototype.delete(value)</code></td><td>移除 <code>Set</code> 的中与这个值相等的元素。</td></tr><tr><td><code>Set.prototype.entries()</code></td><td>返回一个新的迭代器对象，该对象包含 <code>Set</code> 对象中的按插入顺序排列的所有元素的值的 <code>[value, value]</code> 数组，为了使这个方法和 <code>Map</code> 对象保持相似， 每个值的键和值相等。</td></tr><tr><td><code>Set.prototype.forEach(callbackFn[, thisArg])</code></td><td>按照插入顺序，为 <code>Set</code> 对象中的每一个值调用一次 <code>callback</code> ，如果提供了 <code>thisArg</code> 参数，回调中的 <code>this</code> 会是这个参数。</td></tr><tr><td><code>Set.prototype.has(value)</code></td><td>返回一个布尔值，表示该值在 <code>Set</code> 中存在与否。</td></tr><tr><td><code>Set.prototype.keys()</code></td><td>返回一个新的迭代器对象，该对象包含 <code>Set</code> 对象中的按插入顺序排列的所有元素的值。</td></tr><tr><td><code>Set.prototype[@@iterator]()</code></td><td>返回一个新的迭代器对象，该对象包含 <code>Set</code> 对象中的按插入顺序排列的所有元素的值。</td></tr></tbody></table><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Set(3) &#123;3, 2, 1&#125;</span>s<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Set(3) &#123;3, 2, 1&#125;</span><span class="token keyword">const</span> setIterator <span class="token operator">=</span> s<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>setIterator<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// SetIterator &#123;3, 2, 1&#125;</span><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>new <span class="token class-name">Set</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 去重</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// (3) [3, 2, 1]</span></code></pre><h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p><code>WeakSet</code> 的值只能是 <code>Object</code> 类型，持有的是 <code>Object</code> 弱引用，原始数据类型不能作为值。 <code>WeakSet</code> 持有的是对象的弱引用，这意味着在没有其他引用存在时垃圾回收能正确进行， <code>WeakSet</code> 用于存储的对象引用只有在其没有被回收时才是有效的，正由于弱引用， <code>WeakSet</code> 是不可枚举的。<br>简单来说，有时需要在某个数组上面存放一些对象，但是这会形成对于这个对象的引用，一旦不再需要这个对象，我们就必须手动删除这个引用，否则垃圾回收机制无法释放对象占用的内存， <code>WeakSet</code> 的设计就是解决这个问题的，其所引用的对象都是弱引用，垃圾回收机制不将该引用考虑在内，因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存，此时 <code>WeakSet</code> 里边所对应的对象引用会消失，不需要手动删除引用。如果需要在数组上添加对象而又不想干扰垃圾回收机制的话，就可以使用 <code>WeakSet</code> ，此外 <code>WeakSet</code> 非常适合于对象引用的跟踪，尤其是在涉及大量对象时。</p><h3 id="属性与方法-1"><a href="#属性与方法-1" class="headerlink" title="属性与方法"></a>属性与方法</h3><table><thead><tr><th>属性和方法</th><th>功能</th></tr></thead><tbody><tr><td><code>WeakSet.prototype.constructor</code></td><td>返回构造函数。</td></tr><tr><td><code>WeakSet.prototype.add(value)</code></td><td>在该 <code>WeakSet</code> 对象中添加一个新元素 <code>value</code> 。</td></tr><tr><td><code>WeakSet.prototype.delete(value)</code></td><td>从该 <code>WeakSet</code> 对象中删除 <code>value</code> 这个元素。</td></tr><tr><td><code>WeakSet.prototype.has(value)</code></td><td>返回一个布尔值，表示给定的值 <code>value</code> 是否存在于这个 <code>WeakSet</code> 中。</td></tr></tbody></table><h3 id="内存回收实例"><a href="#内存回收实例" class="headerlink" title="内存回收实例"></a>内存回收实例</h3><h4 id="WeakSet-示例"><a href="#WeakSet-示例" class="headerlink" title="WeakSet 示例"></a>WeakSet 示例</h4><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> ws <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">6</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 开辟一个大数组</span>ws<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ws<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>value <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 解除应用</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ws<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span></code></pre><h4 id="WeakSet-内存回收"><a href="#WeakSet-内存回收" class="headerlink" title="WeakSet 内存回收"></a>WeakSet 内存回收</h4><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">/** node --expose-gc **/</span> <span class="token comment">// 启动 node 环境 手动调用垃圾回收机制</span>global<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 首先调用一次垃圾回收</span>process<span class="token punctuation">.</span><span class="token function">memoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 查看内存占用 heapUsed 约 3M</span><span class="token comment">/*&#123;  rss: 24272896,  heapTotal: 5222400,  heapUsed: 3124632,  external: 1568727,  arrayBuffers: 140472&#125;*/</span><span class="token keyword">const</span> ws <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">6</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 开辟一个大数组 </span>ws<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ws<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>process<span class="token punctuation">.</span><span class="token function">memoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// heapUsed 约 53M</span><span class="token comment">/*&#123;  rss: 75153408,  heapTotal: 55558144,  heapUsed: 53554632,  external: 1568730,  arrayBuffers: 337083&#125;*/</span>global<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 手动执行一次垃圾回收</span>process<span class="token punctuation">.</span><span class="token function">memoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// heapUsed 约 53M</span><span class="token comment">/*&#123;  rss: 75390976,  heapTotal: 55558144,  heapUsed: 53376552,  external: 1568728,  arrayBuffers: 378041&#125;*/</span>value <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 解除引用</span>global<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 执行垃圾回收</span>process<span class="token punctuation">.</span><span class="token function">memoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// heapUsed 约 3M 内存已回收</span><span class="token comment">/*&#123;  rss: 25178112,  heapTotal: 5222400,  heapUsed: 3063152,  external: 1568731,  arrayBuffers: 435388&#125;*/</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ws<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span></code></pre><h4 id="Set-示例"><a href="#Set-示例" class="headerlink" title="Set 示例"></a>Set 示例</h4><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">6</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 开辟一个大数组 </span>s<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>value <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 解除引用</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Set(1) &#123;Array(6291456)&#125;</span>s<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 回收内存</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Set(0) &#123;&#125;</span></code></pre><h4 id="Set-内存回收"><a href="#Set-内存回收" class="headerlink" title="Set 内存回收"></a>Set 内存回收</h4><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">/** node --expose-gc **/</span> <span class="token comment">// 启动 node 环境 手动调用垃圾回收机制</span>global<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 首先调用一次垃圾回收</span>process<span class="token punctuation">.</span><span class="token function">memoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 查看内存占用 heapUsed 约 3M</span><span class="token comment">/*&#123;  rss: 24641536,  heapTotal: 5222400,  heapUsed: 3475568,  external: 1568695,  arrayBuffers: 115904&#125;*/</span><span class="token keyword">const</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">6</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 开辟一个大数组 </span>s<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>process<span class="token punctuation">.</span><span class="token function">memoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// heapUsed 约 53M</span><span class="token comment">/*&#123;  rss: 75141120,  heapTotal: 55558144,  heapUsed: 53454992,  external: 1568730,  arrayBuffers: 304315&#125;*/</span>global<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 手动执行一次垃圾回收</span>process<span class="token punctuation">.</span><span class="token function">memoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// heapUsed 约 53M</span><span class="token comment">/*&#123;  rss: 75235328,  heapTotal: 55558144,  heapUsed: 53384240,  external: 1568728,  arrayBuffers: 320697&#125;*/</span>value <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 解除引用</span>global<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 执行垃圾回收</span>process<span class="token punctuation">.</span><span class="token function">memoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// heapUsed 仍为 53M 内存未回收</span><span class="token comment">/*&#123;  rss: 75243520,  heapTotal: 55558144,  heapUsed: 53461528,  external: 1568737,  arrayBuffers: 369858&#125;*/</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false // 此处为 false，这是因为 value 值的改变，而在这个 Set 实例对象中依然存在对 Array 的强引用，内存未回收</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Set(1) &#123;Array(6291456)&#125;</span>s<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 回收内存</span>global<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 执行垃圾回收</span>process<span class="token punctuation">.</span><span class="token function">memoryUsage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// heapUsed 约 2M 内存已回收</span><span class="token comment">/*&#123;  rss: 25055232,  heapTotal: 5222400,  heapUsed: 3167016,  external: 1568737,  arrayBuffers: 541890&#125;*/</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Set(0) &#123;&#125;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax</title>
      <link href="2020/09/01/ajax/"/>
      <url>2020/09/01/ajax/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Ajax (Asynchronous JavaScript and XML)</code> 主要用来加载数据，避免刷新整个页面。<br><code>XMLHttpRequest</code> 是 <code>Ajax</code> 的基础。所有现代浏览器均支持 <code>XMLHttpRequest</code> 对象（IE5 和 IE6 使用 <code>ActiveXObject</code> ）。  </p><h3 id="创建-XMLHttpRequest-对象"><a href="#创建-XMLHttpRequest-对象" class="headerlink" title="创建 XMLHttpRequest 对象"></a>创建 XMLHttpRequest 对象</h3><pre class="language-js" data-language="js"><code class="language-js">myAjax <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><p><code>XMLHttpRequest</code> 对象进行 HTTP 请求前必须通过 <code>open</code> 初始化， <code>open</code> 接受五个参数，分别为请求方法、请求链接、异步标识、账号和密码用以服务端验证  </p><pre class="language-js" data-language="js"><code class="language-js">myAjax<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>Method<span class="token punctuation">,</span> <span class="token constant">URL</span><span class="token punctuation">,</span> Asynchronous<span class="token punctuation">,</span> UserName<span class="token punctuation">,</span> Password<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li><code>method</code> ：请求的类型；GET 或 POST。</li><li><code>url</code> ：文件在服务器上的位置。</li><li><code>async</code> ：true（异步）或 false（同步）。</li></ul><p>在成功初始化请求之后， <code>XMLHttpRequest</code> 对象的 <code>setRequestHeader</code> 方法可以用来设置请求头：</p><pre class="language-js" data-language="js"><code class="language-js">myAjax<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>调用 <code>open</code> 方法后，就可以通过调用 <code>send</code> 方法按照 <code>open</code> 方法设定的参数将请求进行发送  </p><pre class="language-js" data-language="js"><code class="language-js">myAjax<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>当 <code>open</code> 方法设定发送的方式为异步请求时， <code>onreadystatechange</code> 事件监听器将自动在 <code>XMLHttpRequest</code> 对象的 <code>readyState</code> 属性改变时被触发</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">switch</span> <span class="token punctuation">(</span>readyState<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span>        <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">//当 open 方法被成功调用，readyState 为 1</span>    <span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">:</span>        <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">//当 send 方法被调用，readyState 属性被置为 2</span>    <span class="token keyword">case</span> <span class="token number">3</span><span class="token punctuation">:</span>        <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">//HTTP 响应内容开始加载，readyState 属性被置为 3</span>    <span class="token keyword">case</span> <span class="token number">4</span><span class="token punctuation">:</span>        <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">//HTTP 响应内容结束加载，readyState 属性被置为 4</span><span class="token punctuation">&#125;</span></code></pre><p>如果 <code>XMLHttpRequest</code> 对象的 <code>readyState</code> 属性还没有变成 4， <code>abort</code> 可以终止请求。这个方法可以确保异步请求中的回调不被执行。  </p><pre class="language-js" data-language="js"><code class="language-js">myAjax<span class="token punctuation">.</span><span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">ajax</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> method <span class="token operator">=</span> <span class="token string">"GET"</span><span class="token punctuation">,</span> data <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> async <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 声明 XMLHttpRequest </span>    <span class="token comment">// 在 IE5 和 IE6 中需要使用 ActiveXObject</span>    <span class="token keyword">const</span> <span class="token constant">XHR</span> <span class="token operator">=</span> XMLHttpRequest<span class="token punctuation">;</span>    <span class="token comment">// 创建 XMLHttqRequest</span>    <span class="token constant">XHR</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// 设置请求状态改变时执行的函数</span>    <span class="token constant">XHR</span><span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">XHR</span><span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token number">4</span><span class="token punctuation">)</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">响应状态：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token constant">XHR</span><span class="token punctuation">.</span>status<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token template-punctuation string">`</span></span> <span class="token punctuation">,</span> <span class="token string">"FINISH"</span><span class="token punctuation">)</span> <span class="token comment">//XHR.responseText 为响应体</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 初始化请求参数</span>    <span class="token constant">XHR</span><span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> url<span class="token punctuation">,</span> async<span class="token punctuation">)</span>    <span class="token comment">// 发起请求</span>    <span class="token constant">XHR</span><span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token string">"https://www.baidu.com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token string">"https://www.baidu.com"</span><span class="token punctuation">,</span> <span class="token string">"POST"</span><span class="token punctuation">,</span> <span class="token string">"s=str"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h3><p>使用 <code>XMLHttpRequest</code> 对象的 <code>responseText</code> 或 <code>responseXML</code> 属性获取响应数据。  </p><ul><li><code>responseText</code> ：获得字符串形式的响应数据。</li><li><code>responseXML</code> ：获得 XML 形式的响应数据。</li></ul><p>当服务端的响应不是 XML 时，使用 <code>responseText</code> 属性。</p><pre class="language-js" data-language="js"><code class="language-js">document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>inndeHTML <span class="token operator">=</span> myAjax<span class="token punctuation">.</span>responseText<span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCC Toolset 的安装和使用</title>
      <link href="2020/08/25/InstallGCCToolset/"/>
      <url>2020/08/25/InstallGCCToolset/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>常用的 Linux 发行版一般不会自带最新的 GCC 等编译工具，如果我们想体验最新的 C++ 语法特性，就免不了要自己编译 GCC 或者下载预编译版本，这无疑使比较麻烦的。尤其时考虑到许多配套的编译和调试工具也需要升级，如 make、GDB 等，就更让人头大了。好在 RedHat 官方提供了  GCC Toolset 软件包，提供了便捷的安装使用体验，让你只需几条命令就可以用上最新的 GCC 版本。</p><h2 id="安装-GCC-Toolset"><a href="#安装-GCC-Toolset" class="headerlink" title="安装 GCC Toolset"></a>安装 GCC Toolset</h2><p>RedHat 从 RHEL 8 开始推出了 GCC Toolset，它是包括了最新开发工具和性能分析工具的一个软件集合，目前最新版本是 GCC Toolset 9，包括了以下工具：</p><table><thead><tr><th>名称</th><th>版本</th><th>简介</th></tr></thead><tbody><tr><td>GCC</td><td>9.2.1</td><td>A portable compiler suite with support for C, C++, and Fortran.</td></tr><tr><td>GDB</td><td>8.3</td><td>A command-line debugger for programs written in C, C++, and Fortran.</td></tr><tr><td>Valgrind</td><td>3.15.0</td><td>An instrumentation framework and a number of tools to profile applications in order to detect memory errors, identify memory management problems, and report any use of improper arguments in system calls.</td></tr><tr><td>SystemTap</td><td>4.1</td><td>A tracing and probing tool to monitor the activities of the entire system without the need to instrument, recompile, install, and reboot.</td></tr><tr><td>Dyninst</td><td>10.1.0</td><td>A library for instrumenting and working with user-space executables during their execution.</td></tr><tr><td>binutils</td><td>2.32</td><td>A collection of binary tools and other utilities to inspect and manipulate object files and binaries.</td></tr><tr><td>elfutils</td><td>0.176</td><td>A collection of binary tools and other utilities to inspect and manipulate ELF files.</td></tr><tr><td>dwz</td><td>0.12</td><td>A tool to optimize DWARF debugging information contained in ELF shared libraries and ELF executables for size.</td></tr><tr><td>make</td><td>4.2.1</td><td>A dependency-tracking build automation tool.</td></tr><tr><td>strace</td><td>5.1</td><td>A debugging tool to monitor system calls that a program uses and signals it receives.</td></tr><tr><td>ltrace</td><td>0.7.91</td><td>A debugging tool to display calls to dynamic libraries that a program makes. It can also monitor system calls executed by programs.</td></tr><tr><td>annobin</td><td>9.08</td><td>A build security checking tool.</td></tr></tbody></table><p>GCC Toolset 在 RadHat 和 CentOS 都可以下载，使用下面的命令安装所有工具：</p><pre class="language-bash" data-language="bash"><code class="language-bash">yum <span class="token function">install</span> gcc-toolset-9</code></pre><p>你也可以只安装其中的某些工具，列出可用的软件包：</p><pre class="language-bash" data-language="bash"><code class="language-bash">yum list available gcc-toolset-9-<span class="token punctuation">\</span>*</code></pre><p>然后安装其中的某些软件：</p><pre class="language-bash" data-language="bash"><code class="language-bash">yum <span class="token function">install</span> package_name</code></pre><h2 id="使用-GCC-Toolset"><a href="#使用-GCC-Toolset" class="headerlink" title="使用 GCC Toolset"></a>使用 GCC Toolset</h2><p>如果你想使用 GCC Toolset 中的某个工具，可以使用下面的命令：</p><pre class="language-bash" data-language="bash"><code class="language-bash">scl <span class="token builtin class-name">enable</span> gcc-toolset-9 ToolName</code></pre><p>如果你想在一个 Shell 中全部使用 GCC Toolset 中的新版本而不是系统预装的旧版本，你可以使用下面的命令启动一个新的 Shell :</p><pre class="language-bash" data-language="bash"><code class="language-bash">scl <span class="token builtin class-name">enable</span> gcc-toolset-9 <span class="token function">bash</span></code></pre><p>在这个 Shell 下直接输入命令就可以执行新版本的编译工具，而不需要 <code>scl</code> 命令。  </p><h2 id="卸载-GCC-Toolset"><a href="#卸载-GCC-Toolset" class="headerlink" title="卸载 GCC Toolset"></a>卸载 GCC Toolset</h2><p>就像卸载普通软件包一样，执行下面的命令即可全部卸载：</p><pre class="language-bash" data-language="bash"><code class="language-bash">yum remove gcc-toolset-N<span class="token punctuation">\</span>*</code></pre>]]></content>
      
      
      <categories>
          
          <category> Ops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gcc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fetch API</title>
      <link href="2020/08/12/fetch/"/>
      <url>2020/08/12/fetch/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>fetch()</code> 方法定义在 <code>Window</code> 对象以及 <code>WorkerGlobalScope</code> 对象上，用于发起获取资源的请求，其返回一个 <code>Promise</code> 对象，这个 <code>Promise</code> 对象会在请求响应后被 <code>resolve</code> ，并传回 <code>Response</code> 对象。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p> <code>Promise&lt;Response&gt; fetch(input[, init])</code></p><h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><p>定义要获取的资源，其值可以是：</p><ul><li>一个字符串，包含要获取资源的 <code>URL</code> ，一些浏览器会接受 <code>blob</code> 和 <code>data</code> 作为 <code>schemes</code> 。</li><li>一个 <code>Request</code> 对象。  </li></ul><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p>一个配置项对象，包括所有对请求的设置。可选的参数有：</p><ul><li><code>method</code> : 请求使用的方法，如 <code>GET</code> 、 <code>POST</code> 。</li><li><code>headers</code> : 请求的头信息，形式为 <code>Headers</code> 的对象或包含 <code>ByteString</code> 值的对象字面量。</li><li><code>body</code> : 请求的 <code>body</code> 信息：可能是一个 <code>Blob</code> 、 <code>BufferSource</code> 、 <code>FormData</code> 、 <code>URLSearchParams</code> 或者 <code>USVString</code> 对象，注意 <code>GET</code> 或 <code>HEAD</code> 方法的请求不能包含 <code>body</code> 信息。</li><li><code>mode</code> : 请求的模式，如 <code>cors</code> 、 <code>no-cors</code> 或者 <code>same-origin</code> 。</li><li><code>credentials</code> : 请求的 <code>credentials</code> ，如 <code>omit</code> 、 <code>same-origin</code> 或者 <code>include</code> ，为了在当前域名内自动发送 <code>cookie</code> ，必须提供这个选项。</li><li><code>cache</code> : 请求的 <code>cache</code> 模式： <code>default</code> 、 <code>no-store</code> 、 <code>reload</code> 、 <code>no-cache</code> 、 <code>force-cache</code> 或者 <code>only-if-cached</code> 。</li><li><code>redirect</code> : 可用的 <code>redirect</code> 模式： <code>follow</code> 自动重定向， <code>error</code> 如果产生重定向将自动终止并且抛出一个错误，或者 <code>manual</code> 手动处理重定向。</li><li><code>referrer</code> : 一个 <code>USVString</code> 可以是 <code>no-referrer</code> 、 <code>client</code> 或一个 <code>URL</code> ，默认是 <code>client</code> 。</li><li><code>referrerPolicy</code> : 指定了 HTTP 头部 <code>referer</code> 字段的值，可能为以下值之一： <code>no-referrer</code> 、 <code>no-referrer-when-downgrade</code> 、 <code>origin</code> 、 <code>origin-when-cross-origin</code> 、 <code>unsafe-url</code> 。</li><li><code>integrity</code> : 包括请求的 <code>subresource integrity</code> 值，例如： <code>sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=</code> 。</li></ul><p>返回一个 <code>Promise</code> ， <code>resolve</code> 时回传 <code>Response</code> 对象。</p><h2 id="fetch-与-jQuery-ajax-区别"><a href="#fetch-与-jQuery-ajax-区别" class="headerlink" title="fetch 与 jQuery.ajax 区别"></a>fetch 与 jQuery.ajax 区别</h2><ul><li>当接收到一个代表错误的 <code>HTTP</code> 状态码时，从 <code>fetch()</code> 返回的 <code>Promise</code> 不会被标记为 <code>reject</code> ，即使响应的 <code>HTTP</code> 状态码是 <code>404</code> 或 <code>500</code> ，其会将 <code>Promise</code> 状态标记为 <code>resolve</code> ，但是返回的 <code>Promise</code> 会将 <code>resolve</code> 的返回值的 <code>ok</code> 属性设置为 <code>false</code> ，仅当网络故障时或请求被阻止时，才会标记为 <code>reject</code> 。</li><li><code>fetch()</code> 不会接受跨域 <code>cookies</code> ，你也不能使用 <code>fetch()</code> 建立起跨域会话，其他域的 <code>Set-Cookie</code> 头部字段将会被无视。</li><li><code>fetch()</code> 不会发送 <code>cookies</code> ，除非使用了 <code>credentials</code> 的初始化选项。</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h3><p>发起一个简单的资源请求，对于 <code>fetch</code> 请求返回一个 <code>Promise</code> 对象，这个 <code>Promise</code> 对象会在请求响应后被 <code>resolve</code> ，并传回 <code>Response</code> 对象。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">window<span class="token punctuation">.</span><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">"/search.xml"</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h3 id="设置参数"><a href="#设置参数" class="headerlink" title="设置参数"></a>设置参数</h3><p>通过 <code>init</code> 配置对象设置参数，可以设置 <code>method</code> 、 <code>headers</code> 、 <code>body</code> 、 <code>mode</code> 、 <code>credentials</code> 、 <code>cache</code> 、 <code>redirect</code> 、 <code>referrer</code> 、 <code>referrerPolicy</code> 、 <code>integrity</code> 。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> headers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Headers</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span>    <span class="token string">"accept"</span><span class="token punctuation">:</span> <span class="token string">"application/javascript"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>headers<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"accept"</span><span class="token punctuation">,</span> <span class="token string">"application/xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>headers<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"user-agent"</span><span class="token punctuation">,</span> <span class="token string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:80.0) Gecko/20100101 Firefox/80.0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>window<span class="token punctuation">.</span><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">"/search.xml"</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>        method<span class="token punctuation">:</span> <span class="token string">"GET"</span><span class="token punctuation">,</span>        headers<span class="token punctuation">:</span> headers<span class="token punctuation">,</span>        cache<span class="token punctuation">:</span> <span class="token string">'no-cache'</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h4 id="Headers-对象"><a href="#Headers-对象" class="headerlink" title="Headers 对象"></a>Headers 对象</h4><ul><li><code>Headers.append()</code> : 给现有的 <code>header</code> 添加一个值，或者添加一个未存在的 <code>header</code> 并赋值。</li><li><code>Headers.delete()</code> : 从 <code>Headers</code> 对象中删除指定 <code>header</code> 。</li><li><code>Headers.entries()</code> : 以迭代器的形式返回 <code>Headers</code> 对象中所有的键值对。</li><li><code>Headers.get()</code> : 以 <code>ByteString</code> 的形式从 <code>Headers</code> 对象中返回指定 header 的全部值。</li><li><code>Headers.has()</code> : 以布尔值的形式从 <code>Headers</code> 对象中返回是否存在指定的 <code>header</code> 。</li><li><code>Headers.keys()</code> : 以迭代器的形式返回 <code>Headers</code> 对象中所有存在的 <code>header</code> 名。</li><li><code>Headers.set()</code> : 替换现有的 <code>header</code> 的值，或者添加一个未存在的 <code>header</code> 并赋值。</li><li><code>Headers.values()</code> : 以迭代器的形式返回 <code>Headers</code> 对象中所有存在的 <code>header</code> 的值。</li></ul><h3 id="响应处理"><a href="#响应处理" class="headerlink" title="响应处理"></a>响应处理</h3><p>通过 <code>Response</code> 对象对响应的数据作处理，包括获取响应状态以及响应体的处理等操作。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript">window<span class="token punctuation">.</span><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">"/search.xml"</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=></span> res<span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h4 id="Response-对象"><a href="#Response-对象" class="headerlink" title="Response 对象"></a>Response 对象</h4><p><code>Response</code> 对象的相关属性与方法：</p><ul><li><code>Response.headers</code> : 只读，包含此 <code>Response</code> 所关联的 <code>Headers</code> 对象。</li><li><code>Response.ok</code> : 只读，包含了一个布尔值，标示该 <code>Response</code> 成功， <code>HTTP</code> 状态码的范围在 <code>200-299</code> 。</li><li><code>Response.redirected</code> : 只读，表示该 <code>Response</code> 是否来自一个重定向，如果是的话，它的 <code>URL</code> 列表将会有多个条目。</li><li><code>Response.status</code> : 只读，包含 <code>Response</code> 的状态码。</li><li><code>Response.statusText</code> : 只读，包含了与该 <code>Response</code> 状态码一致的状态信息。</li><li><code>Response.type</code> : 只读，包含 <code>Response</code> 的类型，例如 <code>basic</code> 、 <code>cors</code> 。</li><li><code>Response.url</code> : 只读，包含 <code>Response</code> 的 <code>URL</code> 。</li><li><code>Response.useFinalURL</code> : 包含了一个布尔值，来标示这是否是该 <code>Response</code> 的最终 <code>URL</code> 。</li><li><code>Response.clone()</code> : 创建一个 <code>Response</code> 对象的克隆。</li><li><code>Response.error()</code> : 返回一个绑定了网络错误的新的 <code>Response</code> 对象。</li><li><code>Response.redirect()</code> : 用另一个 <code>URL</code> 创建一个新的 <code>Response</code> 。</li></ul><p><code>Response</code> 实现了 <code>Body</code> 接口，相关属性与方法可以直接使用：</p><ul><li><code>Body.body</code> : 只读，一个简单的 <code>getter</code> ，用于暴露一个 <code>ReadableStream</code> 类型的 <code>body</code> 内容。</li><li><code>Body.bodyUsed</code> : 只读，包含了一个布尔值来标示该 <code>Response</code> 是否读取过 <code>Body</code> 。</li><li><code>Body.arrayBuffer()</code> : 读取 <code>Response</code> 对象并且将它设置为已读，并返回一个被解析为 <code>ArrayBuffer</code> 格式的 <code>Promise</code> 对象， <code>Responses</code> 对象被设置为了 <code>stream</code> 的方式，所以它们只能被读取一次。</li><li><code>Body.blob()</code> : 读取 <code>Response</code> 对象并且将它设置为已读，并返回一个被解析为 <code>Blob</code> 格式的 <code>Promise</code> 对象。</li><li><code>Body.formData()</code> : 读取 <code>Response</code> 对象并且将它设置为已读，并返回一个被解析为 <code>FormData</code> 格式的 <code>Promise</code> 对象。</li><li><code>Body.json()</code> : 读取 <code>Response</code> 对象并且将它设置为已读，并返回一个被解析为 <code>JSON</code> 格式的 <code>Promise</code> 对象。</li><li><code>Body.text()</code> : 读取 <code>Response</code> 对象并且将它设置为已读，并返回一个被解析为 <code>USVString</code> 格式的 <code>Promise</code> 对象。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 导出表格</title>
      <link href="2020/08/05/JavaScriptExportSheet/"/>
      <url>2020/08/05/JavaScriptExportSheet/</url>
      
        <content type="html"><![CDATA[<h2 id="导出-CSV"><a href="#导出-CSV" class="headerlink" title="导出 CSV"></a>导出 CSV</h2><p>JavaScript 导出 CSV 比较简单，只需要根据 CSV 的格式进行逗号分隔和换行，最后将文本保存成 CSV 文件即可。<br>需要注意的是，Excel 默认使用 ANSI 编码来打开 CSV 文件，如果 CSV 文件使用 UTF-8 编码，使用 Excel 打开就会乱码，解决方法是使用 Excel 中 <code>数据</code> - <code>导入自文件</code> 向导来导入 UTF-8 编码的 CSV 文件，这样就可以正常显示 Unicode 字符了。但这相比直接打开麻烦了很多，另一个办法是将 CSV 文件保存成 UTF-8 BOM 编码，这样 Excel 就会以 UTF-8 编码读取文件，不会出现乱码了。</p><blockquote><p>BOM (<a href="https://en.wikipedia.org/wiki/Byte_order_mark">Byte Order Mark</a>) 是一段特定的十六进制序列，在 UTF-16 和 UTF-32 中用来标识该字节流的字节序，是高位在前还是低位在前，在 UTF-8 中 BOM 一般用来标识文件采用 UTF-8 编码，但并不是必要的。  </p></blockquote><p>UTF-8 的 BOM 的十六进制表示为 <code>EF BB BF</code> ，也可以用一个 Unicode 字符表示： <code>U+FEFF</code> 。所以我们只要在 CSV 文件开头加入 BOM 就可以将文件保存为 UTF-8 BOM 格式。可以直接在 <code>Buffer</code> 中先加入 <code>\xEF\xBB\xBF</code> 作为开头 ，也可以在字符串开头加入 <code>\uFEFF</code> 这个 Unicode 字符。  </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">writeCSV</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> csvContent <span class="token operator">=</span> <span class="token string">'\uFEFF'</span><span class="token punctuation">;</span>    csvContent <span class="token operator">=</span> csvContent<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">"布洛妮娅萌"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    fs<span class="token punctuation">.</span><span class="token function">writeFileSync</span><span class="token punctuation">(</span><span class="token string">'konata.csv'</span><span class="token punctuation">,</span> csvContent<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="导出-xls-和-xlsx"><a href="#导出-xls-和-xlsx" class="headerlink" title="导出 xls 和 xlsx"></a>导出 xls 和 xlsx</h2><p>导出 xls 和 xlsx，肯定要使用库了，目前比较好用的是 <a href="https://github.com/sheetjs/sheetjs">SheetJS</a>，它分为专业版和社区版，专业版主要增加了样式设置、插入图片图表的功能，据说价格很贵，一般情况下社区版足够使用了。社区版也叫做 js-xlsx，支持数据读取、解析处理、数据导出，同时支持浏览器端和 Node 端。</p><h3 id="SheetJS-常用-API"><a href="#SheetJS-常用-API" class="headerlink" title="SheetJS 常用 API"></a>SheetJS 常用 API</h3><h4 id="workbook-和-worksheet"><a href="#workbook-和-worksheet" class="headerlink" title="workbook 和 worksheet"></a>workbook 和 worksheet</h4><p>首先要明确的两个概念是 <code>workbook</code> 和 <code>worksheet</code> , 这两个对象分别对应了整个文件（工作簿）和一个文件中的一个表格（工作表）。</p><h5 id="workbook"><a href="#workbook" class="headerlink" title="workbook"></a>workbook</h5><p><code>workbook</code> 有两种方式来获取：</p><ul><li>读取已有的文件，返回一个 <code>workbook</code> 对象。</li><li>通过 <code>XLSX.utils.book_new ()</code> 创建空白的 <code>workbook</code> 对象。</li></ul><p>常用到的 <code>workbook</code> 的属性有两个：</p><ul><li><p><code>Sheets</code> ：文件中的表格列表。</p></li><li><p><code>SheetNames</code> ：文件中的表格名列表，表现为数组。</p><p>需要获取 <code>workbook</code> 中的某个表格时，可以这样获取：</p></li></ul><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> sheetname <span class="token operator">=</span> workbook<span class="token punctuation">.</span>SheetNames<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> worksheet <span class="token operator">=</span> workbook<span class="token punctuation">.</span>Sheets<span class="token punctuation">[</span>sheetname<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><h5 id="worksheet"><a href="#worksheet" class="headerlink" title="worksheet"></a>worksheet</h5><p><code>worksheet</code> 对象代表文件中的一个表格，可以通过下标的形式访问表格中任意一小格的值：</p><pre class="language-js" data-language="js"><code class="language-js">worksheet<span class="token punctuation">[</span><span class="token string">'A1'</span><span class="token punctuation">]</span></code></pre><p>其返回值为一个对象，一般具有两个属性：</p><ul><li><code>v</code> ：当前小格的值。</li><li><code>t</code> ：当前小格值的类型。</li></ul><h4 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h4><p>SheetJS 通过两种方式读取文件内容：</p><ul><li><p><code>XLSX.read (data, read_options)</code> ：读取 <code>data</code> 并解析。</p></li><li><p><code>XLSX.readFile (filename, read_options)</code> ：读取 <code>filename</code> 文件并解析。</p><p>有关 <code>read_options</code> 的内容详见 <a href="https://github.com/SheetJS/sheetjs#parsing-options">read_options</a>。</p></li></ul><h4 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h4><p>SheetJS 通过三种方法写入数据，这两种方法均会对数字、字符串、 <code>null</code> 和 <code>undefined</code> 、日期等类型进行自动解析：</p><ul><li><p><code>XLSX.writeFile (workbook, filename [, write_options])</code> ：按照 <code>workbook</code> 对象生成文件。若在浏览器端，会自动下载该文件。在 Node 端，会自动生成该文件并保存到本地</p></li><li><p><code>XLSX.writeFileAsync (filename, workbook, o, cb)</code> : 按照 <code>workbook</code> 对象生成文件。当 <code>o</code> 执行完毕后，调用 <code>cb</code> 回调函数。</p><p>有关 <code>read_options</code> 的内容详见 <a href="https://github.com/SheetJS/sheetjs#parsing-options">read_options</a>。</p></li></ul><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// XLSX.writeFile</span><span class="token comment">// 第一个参数为一个 workbook 对象，第二个参数为所要生成文件的文件名</span><span class="token constant">XLSX</span><span class="token punctuation">.</span><span class="token function">writeFile</span><span class="token punctuation">(</span>workbook<span class="token punctuation">,</span> <span class="token string">'out.xlsb'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// XLSX.write</span><span class="token comment">// 第一个参数为一个 workbook 对象，第二个参数是对生成文件格式的一些设置</span><span class="token comment">// 在本例中，生成格式为 xlsx 的文件，编码为 base64</span><span class="token constant">XLSX</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>workbook<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>    bookType<span class="token punctuation">:</span> <span class="token string">'xlsx'</span><span class="token punctuation">,</span>    bookSST<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    type<span class="token punctuation">:</span> <span class="token string">'base64'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">// 由于其不生成文件，而只是返回组成文件的数据，所以很适合一些需要通过异步请求来修改服务器上的文件等场景</span></code></pre><h4 id="转换数据格式"><a href="#转换数据格式" class="headerlink" title="转换数据格式"></a>转换数据格式</h4><p>SheetJS 支持读取文件并把数据导出成任意格式，可通过以下几个 API 完成，传入的参数均是一个 worksheet 对象</p><ul><li><code>XLSX.utils.sheet_to_csv (worksheet)</code> ：将表格数据转化为 CSV 格式。</li><li><code>XLSX.utils.sheet_to_txt (worksheet)</code> ：将表格数据转化为生成由 UTF-16 编码的 txt 格式。</li><li><code>XLSX.utils.sheet_to_html (worksheet)</code> ：将表格转化为 html 文件。</li><li><code>XLSX.utils.sheet_to_json (worksheet)</code> : 将表格数据转化为 json 格式。</li></ul><h4 id="表格操作"><a href="#表格操作" class="headerlink" title="表格操作"></a>表格操作</h4><ul><li><code>XLSX.utils.aoa_to_sheet (Array [][])</code> ：将二维数组转化为 <code>worksheet</code> 对象。</li><li><code>XLSX.utils.json_to_sheet (Object)</code> ：将 js 对象转化为 <code>worksheet</code> 对象。</li><li><code>XLSX.utils.table_to_sheet (HTML)</code> ：将 DOM 节点转化为 <code>worksheet</code> 对象（一般为 <code>table</code> 元素、 <code>tr</code> 元素和 <code>th</code> 元素）。</li><li><code>XLSX.utils.sheet_add_aoa (worksheet, Array [][])</code> ：将二维数组中的数据添加到已有的 <code>worksheet</code> 中。</li><li><code>XLSX.utils.sheet_add_json (worksheet, Object)</code> ：将 js 对象中的数据添加到已有的 <code>worksheet</code> 中。</li><li><code>XLSX.utils.book_append_sheet (workbook, worksheet, sheetname)</code> ：将 <code>worksheet</code> 对象添加到 <code>workbook</code> 中，并命名为 <code>sheetname</code> 。</li></ul><h3 id="将网页中的-table-元素转换成-xlsx-并下载"><a href="#将网页中的-table-元素转换成-xlsx-并下载" class="headerlink" title="将网页中的 table 元素转换成 xlsx 并下载"></a>将网页中的 table 元素转换成 xlsx 并下载</h3><p>引入 SheetJS：</p><pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dist/xlsx.full.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>JavaScript:</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">exportExcel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> sheet <span class="token operator">=</span> <span class="token constant">XLSX</span><span class="token punctuation">.</span>utils<span class="token punctuation">.</span><span class="token function">table_to_sheet</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">"table"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将网页中第一个 table 元素转换为工作表对象</span>    <span class="token keyword">let</span> filename <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"table-title"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerText<span class="token punctuation">;</span> <span class="token comment">// 得到文件名</span>    <span class="token function">openDownloadDialog</span><span class="token punctuation">(</span><span class="token function">sheet2blob</span><span class="token punctuation">(</span>sheet<span class="token punctuation">)</span><span class="token punctuation">,</span> filename <span class="token operator">+</span> <span class="token string">'.xlsx'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 文件下载</span><span class="token punctuation">&#125;</span><span class="token comment">// 将一个 sheet 转成最终的 excel 文件的 blob 对象，然后利用 URL.createObjectURL 下载</span><span class="token keyword">function</span> <span class="token function">sheet2blob</span><span class="token punctuation">(</span><span class="token parameter">sheet<span class="token punctuation">,</span> sheetName</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> workbook <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        SheetNames<span class="token punctuation">:</span> <span class="token punctuation">[</span>sheetName<span class="token punctuation">]</span><span class="token punctuation">,</span>        Sheets<span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    workbook<span class="token punctuation">.</span>Sheets<span class="token punctuation">[</span>sheetName<span class="token punctuation">]</span> <span class="token operator">=</span> sheet<span class="token punctuation">;</span>    <span class="token comment">// 生成 excel 的配置项</span>    <span class="token keyword">const</span> wopts <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        bookType<span class="token punctuation">:</span> <span class="token string">'xlsx'</span><span class="token punctuation">,</span> <span class="token comment">// 要生成的文件类型</span>        bookSST<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment">// 是否生成 Shared String Table，官方解释是，如果开启生成速度会下降，但在低版本 IOS 设备上有更好的兼容性</span>        type<span class="token punctuation">:</span> <span class="token string">'binary'</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> wbout <span class="token operator">=</span> <span class="token constant">XLSX</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>workbook<span class="token punctuation">,</span> wopts<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> blob <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Blob</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">s2ab</span><span class="token punctuation">(</span>wbout<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>        type<span class="token punctuation">:</span> <span class="token string">"application/octet-stream"</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 字符串转 ArrayBuffer</span>    <span class="token keyword">function</span> <span class="token function">s2ab</span><span class="token punctuation">(</span><span class="token parameter">s</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> buf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBuffer</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> view <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Uint8Array</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> view<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xFF</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> buf<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> blob<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 通用的打开下载对话框方法，没有测试过具体兼容性 * @param url 下载地址，也可以是一个 blob 对象，必选 * @param saveName 保存文件名，可选 */</span><span class="token keyword">function</span> <span class="token function">openDownloadDialog</span><span class="token punctuation">(</span><span class="token parameter">url<span class="token punctuation">,</span> saveName</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> url <span class="token operator">==</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> url <span class="token keyword">instanceof</span> <span class="token class-name">Blob</span><span class="token punctuation">)</span>        url <span class="token operator">=</span> <span class="token constant">URL</span><span class="token punctuation">.</span><span class="token function">createObjectURL</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建 blob 地址</span>    <span class="token keyword">const</span> aLink <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    aLink<span class="token punctuation">.</span>href <span class="token operator">=</span> url<span class="token punctuation">;</span>    aLink<span class="token punctuation">.</span>download <span class="token operator">=</span> saveName <span class="token operator">||</span> <span class="token string">''</span><span class="token punctuation">;</span> <span class="token comment">// HTML5 新增的属性，指定保存文件名，可以不要后缀，注意，file:///模式下不会生效</span>    <span class="token keyword">let</span> event<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">.</span>MouseEvent<span class="token punctuation">)</span> event <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MouseEvent</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        event <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createEvent</span><span class="token punctuation">(</span><span class="token string">'MouseEvents'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        event<span class="token punctuation">.</span><span class="token function">initMouseEvent</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> window<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    aLink<span class="token punctuation">.</span><span class="token function">dispatchEvent</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>HTML:</p><pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>button is-link margin-btn<span class="token punctuation">"</span></span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>exportExcel()<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    导出 Excel<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 选择器性能优化</title>
      <link href="2020/08/02/CSSPerformance/"/>
      <url>2020/08/02/CSSPerformance/</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器计算样式的规则"><a href="#浏览器计算样式的规则" class="headerlink" title="浏览器计算样式的规则"></a>浏览器计算样式的规则</h2><p>通常来说，计算样式的第一步是创建一组匹配选择器，即浏览器计算出给指定元素应用哪些类、伪选择器和 ID；第二步涉及到从匹配选择器中获取所有样式规则，并计算出此元素的最终样式。</p><p>浏览器读取 CSS 选择器遵循从右到左的顺序，例如下面的 CSS 选择器：</p><pre class="language-css" data-language="css"><code class="language-css"><span class="token selector">.box:nth-last-child(-n+1) h1 .title</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/* styles */</span><span class="token punctuation">&#125;</span></code></pre><p>那么浏览器要做的事情是：</p><ol><li>寻找所有包含 <code>title</code> 类的元素</li><li>在这些元素中，筛选出其父元素是 <code>&lt;h1&gt;</code> 标签的元素</li><li>接着再筛选出父元素是其父元素中第奇数个子元素的元素</li><li>对经过筛选后的元素应用样式</li></ol><h2 id="CSS-选择器性能排行"><a href="#CSS-选择器性能排行" class="headerlink" title="CSS 选择器性能排行"></a>CSS 选择器性能排行</h2><p>Steve Souders（Google Web 工程师，曾经写过三本 Web 性能为主题的 O’Reilly）曾于 2009 年总结了 CSS 选择器性能排行：</p><ol><li>ID 选择器（ <code>#id</code> ）</li><li>类选择器（ <code>.className</code> ）</li><li>标签选择器（ <code>div</code>  <code>h1</code>  <code>p</code> ）</li><li>相邻选择器（ <code>h1+p</code> ）</li><li>子选择器（ <code>ul &gt; li</code> ）</li><li>后代选择器（ <code>li a</code> ）</li><li>通配符选择器（ <code>*</code> ）</li><li>属性选择器（ <code>a[rel=&quot;external&quot;]</code> ）</li><li>伪类选择器（ <code>a:hover</code>  <code>li:nth-child</code> ）</li></ol><p>由于从右往左匹配，因此即使是同一类型的选择器之间的性能也有差异 —— 后代选择器中，最右侧是 ID 的选择器的性能就优于最右侧是类的选择器。</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Performance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 中各种遍历方法对比</title>
      <link href="2020/07/25/LoopMethodInJavaScript/"/>
      <url>2020/07/25/LoopMethodInJavaScript/</url>
      
        <content type="html"><![CDATA[<p>原文：<a href="https://thecodebarbarian.com/for-vs-for-each-vs-for-in-vs-for-of-in-javascript.html">For vs forEach() vs for/in vs for/of in JavaScript</a>  </p><p>在 JavaScript 中有许多方法来遍历一个对象或者数组，他们之间的差别是一个令许多人人困惑的 <a href="https://stackoverflow.com/questions/9329446/for-each-over-an-array-in-javascript">问题</a>。<br>一些编码 <a href="https://airbnb.io/javascript/#iterators--nope">规范</a> 甚至禁止使用某些方法遍历。<br>在这篇文章中，我将解释以下 4 种方法遍历一个数组的不同：  </p><ul><li><code>for (let i = 0; i &lt; arr.length; ++i)</code></li><li><code>arr.forEach((v, i) =&gt; &#123; /* ... */ &#125;)</code></li><li><code>for (let i in arr)</code></li><li><code>for (const v of arr)</code></li></ul><p>我将使用几种不同的边界情况概述这些循环结构之间的区别。我还将提供相关的 ESLint 规则链接，以便在你的项目中使用循环结构的最佳实践。  </p><h2 id="语法概述"><a href="#语法概述" class="headerlink" title="语法概述"></a>语法概述</h2><p><code>for</code> 和 <code>for/in</code> 结构让你可以得到数组索引，但不是真正的元素。例如，假设你想打印出下面这个数组中存储的内容：  </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>使用 <code>for</code> 或者 <code>for/in</code> ，你需要打印 <code>arr[i]</code> ：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token keyword">in</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>使用另外两种方法， <code>forEach()</code> 和 <code>for/of</code> ，你可以得到元素本身。 <code>forEach()</code> 也可以得到元素索引，但 <code>for/of</code> 不可以。</p><pre class="language-js" data-language="js"><code class="language-js">arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">v<span class="token punctuation">,</span> i</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> v <span class="token keyword">of</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="非数值属性"><a href="#非数值属性" class="headerlink" title="非数值属性"></a>非数值属性</h2><p>JavaScript 中的数组也是对象。这意味着你不仅可以添加数字，也可以添加字符串属性到数组内。</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">typeof</span> arr<span class="token punctuation">;</span> <span class="token comment">// 'object'</span><span class="token comment">// Assign to a non-numeric property</span>arr<span class="token punctuation">.</span>test <span class="token operator">=</span> <span class="token string">'bad'</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span>test<span class="token punctuation">;</span> <span class="token comment">// 'bad'</span>arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">===</span> arr<span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// true, JavaScript arrays are just special objects</span></code></pre><p>四种方法中的三种都忽视了非数值属性。只有 <code>for/in</code> 可以打印出’bad’：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span>test <span class="token operator">=</span> <span class="token string">'bad'</span><span class="token punctuation">;</span><span class="token comment">// Prints "a, b, c, bad"</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token keyword">in</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>这就是为什么 <a href="https://stackoverflow.com/questions/500504/why-is-using-for-in-for-array-iteration-a-bad-idea">使用 <code>for/in</code> 来遍历一个数组一般不是一个好主意的原因</a>。其他的遍历方法都正确的忽视了非数值属性：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span>test <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token punctuation">;</span><span class="token comment">// Prints "a, b, c"</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// Prints "a, b, c"</span>arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> i</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> el<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Prints "a, b, c"</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> el <span class="token keyword">of</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>重点：</strong> 避免在数组中使用 <code>for/in</code> 循环，除非你清楚你想要遍历非数值键和继承的键。使用 <a href="https://eslint.org/docs/rules/guard-for-in">ESLint 规则</a> <code>guard-for-in</code> 来禁止使用 <code>for/in</code> 。</p><h2 id="空元素"><a href="#空元素" class="headerlink" title="空元素"></a>空元素</h2><p>JavaScript 数组允许 <a href="https://stackoverflow.com/questions/281264/remove-empty-elements-from-an-array-in-javascript">空元素</a>。下面这个数组是语法正确的，而且长度为 3：</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">// 3</span></code></pre><p>让人更困惑的是不同循环结构对待 <code>[&#39;a&#39;,, &#39;c&#39;]</code> 和 <code>[&#39;a&#39;, undefined, &#39;c&#39;]</code> 不同。下面是四种循环结构如何对待像 <code>[&#39;a&#39;,, &#39;c&#39;]</code> 这样有一个空元素的方式。 <code>for/in</code> 和 <code>for/each</code> 跳过了空元素， <code>for</code> 和 <code>for/of</code> 并没有。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// Prints "a, undefined, c"</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// Prints "a, c"</span>arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">v</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Prints "a, c"</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token keyword">in</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// Prints "a, undefined, c"</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> v <span class="token keyword">of</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>如果你想知道的话，对于 <code>[&#39;a&#39;, undefined, &#39;c&#39;]</code> 四种方法都会打印出 “a, undefined, c”。<br>这里有另外一种向数组中添加空元素的方法：</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// Equivalent to `['a', 'b', 'c',, 'e']`</span><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'e'</span><span class="token punctuation">;</span></code></pre><p><code>forEach()</code> 和 <code>for/in</code> 跳过了数组中的空元素，但 <code>for</code> 和 <code>for/of</code> 没有。 <code>forEach()</code> 的行为可能会导致一些问题，然而，JavaScript 数组中的空元素一般是很罕见的，因为它们不被 JSON 支持：</p><pre class="language-none"><code class="language-none">$ node&gt; JSON.parse(&#39;&#123;&quot;arr&quot;:[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]&#125;&#39;)&#123; arr: [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ] &#125;&gt; JSON.parse(&#39;&#123;&quot;arr&quot;:[&quot;a&quot;,null,&quot;c&quot;]&#125;&#39;)&#123; arr: [ &#39;a&#39;, null, &#39;c&#39; ] &#125;&gt; JSON.parse(&#39;&#123;&quot;arr&quot;:[&quot;a&quot;,,&quot;c&quot;]&#125;&#39;)SyntaxError: Unexpected token , in JSON at position 12</code></pre><p>所以你不必担心用户数据中的空元素，除非你给了用户完全访问 JavaScript 运行时的权限。</p><p><strong>重点：</strong> <code>for/in</code> 和 <code>forEach()</code> 跳过了数组中的空元素，也被称作 <a href="http://2ality.com/2013/07/array-iteration-holes.html">“holes”</a>。很少有情况将空元素视为特殊情况而不是 <code>undefined</code> 。如果你关心空元素的特殊情况，下面是一个 <code>.eslintrc.yml</code> 的例子来禁止调用 <code>forEach()</code> 。</p><pre class="language-none"><code class="language-none">parserOptions:  ecmaVersion: 2018rules:  no-restricted-syntax:    - error    - selector: CallExpression[callee.property.name&#x3D;&quot;forEach&quot;]      message: Do not use &#96;forEach()&#96; , use &#96;for&#x2F;of&#96; instead</code></pre><h2 id="函数上下文-Function-Context"><a href="#函数上下文-Function-Context" class="headerlink" title="函数上下文 (Function Context)"></a>函数上下文 (Function Context)</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this#Function_context">Function context</a> 是一个很好的用来表示 this 所指对象的方法。 <code>for</code> 、 <code>for/in</code> 和 <code>for/of</code> 中的 this 保持了和外面一样的指向，但 <code>forEach()</code> 回调将会有一个不同的 this，<strong>除非</strong>你使用 <a href="https://medium.freecodecamp.org/learn-es6-the-dope-way-part-ii-arrow-functions-and-the-this-keyword-381ac7a32881">箭头函数</a>。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token string">'use strict'</span><span class="token punctuation">;</span><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// Prints "undefined"</span>arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>重点：</strong> 使用 <code>forEach()</code> 时使用箭头函数。使用 <a href="https://eslint.org/docs/rules/prefer-arrow-callback"> <code>no-arrow-callback</code> ESLint rule</a> 来对不使用 this 的回调函数要求使用箭头函数。</p><h2 id="Async-Await-和-生成器-Generators"><a href="#Async-Await-和-生成器-Generators" class="headerlink" title="Async/Await 和 生成器 (Generators)"></a>Async/Await 和 生成器 (Generators)</h2><p>另一种使用 <code>forEach()</code> 的边界情况是它 <a href="https://thecodebarbarian.com/basic-functional-programming-with-async-await.html">不能与 async/await</a> 或者 <a href="http://es2015generators.com/">generators</a> 使用。如果你的 <code>forEach()</code> 回调是同步的，那没问题，但你不能在 <code>forEach()</code> 回调中使用 <code>await</code> ：</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">el</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token comment">// SyntaxError</span>        <span class="token keyword">await</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>你也不能使用 <code>yield</code> ：</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">el</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token comment">// SyntaxError</span>        <span class="token keyword">yield</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>上面的例子在 <code>for/of</code> 下是正常的：</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">asyncFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> el <span class="token keyword">of</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">await</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">generatorFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> el <span class="token keyword">of</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">yield</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>即使你在 <code>forEach()</code> 回调上标记了 <code>async</code> ，在尝试让异步 <code>forEach()</code> 顺序执行时，会感到非常头疼。例如，下面的程序将会将 0-9 用相反的顺序打印出来。</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Wait 1 second before printing 0, 0.9 seconds before printing 1, etc.</span>    <span class="token keyword">await</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span> <span class="token operator">-</span> n <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Will usually print 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 but order is not strictly</span>    <span class="token comment">// guaranteed.</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>print<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>重点：</strong> 如果你使用 <a href="http://asyncawait.net/">async/await</a> 或者 <a href="http://es2015generators.com/">generators</a>，记住 <code>forEach()</code> 是语法糖。它应该小心的使用并且不要将它用于所有情况。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一般来说， <code>for/of</code> 是用来遍历数组的方法中最健壮的。它比传统的 <code>for</code> 循环更加简洁，也没有像 <code>for/in</code> 和 <code>forEach()</code> 那样多的边界情况。 <code>for/of</code> 的主要缺点是需要使用额外的手段来得到索引<sup>[1]</sup> ，也不能像 <code>forEach()</code> 一样链式使用。使用 <code>forEach()</code> 有许多需要注意的地方，它应该被谨慎的使用，但在很多情况下它能让代码变得更简洁。</p><hr><p>[1] 要在 <code>for/of</code> 循环中得到当前数组的索引，可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries"> <code>Array.entries()</code> 函数</a>.</p><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token punctuation">[</span>i<span class="token punctuation">,</span> v<span class="token punctuation">]</span> <span class="token keyword">of</span> arr<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Prints "0 a", "1 b", "2 c"</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>遍历数组时使用异步方法</title>
      <link href="2020/07/25/UsingAsyncWithForEach/"/>
      <url>2020/07/25/UsingAsyncWithForEach/</url>
      
        <content type="html"><![CDATA[<p>在遍历数组时，如果在对每个元素的回调中使用异步方法，<b>不能使用 <code>forEach()</code> 遍历</b>。<br><b style="color: red">错误</b>的例子：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">walkPath</span><span class="token punctuation">(</span><span class="token parameter">path</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> fileList <span class="token operator">=</span> <span class="token keyword">await</span> fsPromises<span class="token punctuation">.</span><span class="token function">readdir</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span>fileList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">dirent</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>            <span class="token keyword">await</span> <span class="token function">lookIntoFile</span><span class="token punctuation">(</span>dirent<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><p><b style="color: green">正确</b>的例子：<br>可以使用 <code>map()</code> 来代替 <code>forEach()</code> ：  </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">walkPath</span><span class="token punctuation">(</span><span class="token parameter">path</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> fileList <span class="token operator">=</span> <span class="token keyword">await</span> fsPromises<span class="token punctuation">.</span><span class="token function">readdir</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span>fileList<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">dirent</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>            <span class="token keyword">await</span> <span class="token function">lookIntoFile</span><span class="token punctuation">(</span>dirent<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><p>也可以使用 <code>for ... of</code> 遍历：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">walkPath</span><span class="token punctuation">(</span><span class="token parameter">path</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> fileList <span class="token operator">=</span> <span class="token keyword">await</span> fsPromises<span class="token punctuation">.</span><span class="token function">readdir</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> dirent <span class="token keyword">of</span> fileList<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">await</span> <span class="token function">lookIntoFile</span><span class="token punctuation">(</span>dirent<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><p>以上两种方法，经过简单测试就能发现，第一种使用 map 遍历比下面使用 <code>for ... of</code> 遍历快得多。原因在于<br><code>Promise.all()</code> 中的对象是异步执行的，但它们的返回顺序还是按照 <code>Promise.all()</code> 中的顺序返回的。而第二种方法是同步执行，遍历完成一个才会遍历下一个，可以根据情况选择这两种方法。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES2017 </tag>
            
            <tag> ES2018 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 常用命令</title>
      <link href="2020/07/24/GitCheatSheet/"/>
      <url>2020/07/24/GitCheatSheet/</url>
      
        <content type="html"><![CDATA[<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><code>git init</code> 创建本地仓库<br><code>git remote add origin https://github.com/user/repo.git</code> 关联远程仓库<br><code>git push -u origin master</code> 关联远程仓库之后的首次推送命令</p><h2 id="一般提交流程"><a href="#一般提交流程" class="headerlink" title="一般提交流程"></a>一般提交流程</h2><p><code>git add .</code> 将文件添加到暂存区<br><code>git commit -m &quot;说明&quot;</code> 将缓存区内容添加到仓库<br><code>git push</code> 将本地仓库同步到远程仓库</p><h2 id="查看修改情况"><a href="#查看修改情况" class="headerlink" title="查看修改情况"></a>查看修改情况</h2><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><p><code>git status</code> 以查看在你上次提交之后是否有修改。  </p><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><p>执行 <code>git diff</code> 来查看具体的文件修改。  </p><ul><li>尚未缓存的改动： <code>git diff</code></li><li>查看已缓存的改动： <code>git diff --cached</code></li><li>查看已缓存的与未缓存的所有改动： <code>git diff HEAD</code></li><li>显示摘要而非整个 diff： <code>git diff --stat</code></li></ul><h2 id="分支的创建和管理"><a href="#分支的创建和管理" class="headerlink" title="分支的创建和管理"></a>分支的创建和管理</h2><ul><li>创建分支 <code>git branch test</code></li><li>切换分支 <code>git checkout test</code></li><li>合并分支 <code>git merge test</code></li><li>删除分支 <code>git branch -d test</code></li><li>新分支提交到原创仓库 <code>git push origin test:test</code></li></ul><h2 id="撤销提交"><a href="#撤销提交" class="headerlink" title="撤销提交"></a>撤销提交</h2><h3 id="查看提交记录"><a href="#查看提交记录" class="headerlink" title="查看提交记录"></a>查看提交记录</h3><p> <code>git log</code></p><h3 id="选择撤销记录"><a href="#选择撤销记录" class="headerlink" title="选择撤销记录"></a>选择撤销记录</h3><ul><li><code>git reset --soft commitID</code> 本地文件不会回滚，不撤销 <code>git add</code></li><li><code>git reset commitID</code> 本地文件不会回滚，同时撤销 <code>git add</code></li><li><code>git reset --hard commitID</code> 本地文件也会回滚，可能造成数据丢失  </li></ul><h3 id="强制推送到远程仓库"><a href="#强制推送到远程仓库" class="headerlink" title="强制推送到远程仓库"></a>强制推送到远程仓库</h3><p>如果还没有推送到远程仓库，就不必执行这一步。<br><code>git push origin master -f</code> 不加 <code>-f</code> 会报错，因为版本低于远端，无法直接提交。</p><h2 id="gitignore"><a href="#gitignore" class="headerlink" title="gitignore"></a>gitignore</h2><p>如果某些文件已经被纳入了版本管理中，之后再将其加入 <code>.gitignore</code> 会不起作用的，这时候需要把本地缓存删除，再进行 git add，这样就不会出现忽略的文件了。<br>git 清除本地缓存：<br> <code>git rm -r --cached .</code></p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6 Module 语法</title>
      <link href="2020/07/23/ES6Module/"/>
      <url>2020/07/23/ES6Module/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>ES6 之前用于 JavaScript 的模块加载方案，是一些社区提供的，主要有 <code>CommonJS</code> 和 <code>AMD</code> 两种，前者用于<strong>服务器</strong>，后者用于<strong>浏览器</strong>。<br>ES6 提供了模块的实现，使用 <code>export</code> 命令对外暴露接口，使用 <code>import</code> 命令输入其他模块暴露的接口。   </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// CommonJS 模块</span><span class="token keyword">let</span> <span class="token punctuation">&#123;</span>    stat<span class="token punctuation">,</span>    exists<span class="token punctuation">,</span>    readFire<span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// ES6 模块</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span>    stat<span class="token punctuation">,</span>    exists<span class="token punctuation">,</span>    readFire<span class="token punctuation">&#125;</span> <span class="token operator">=</span> <span class="token keyword">from</span> <span class="token string">'fs'</span><span class="token punctuation">;</span></code></pre><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>ES6 模块自动采用严格模式，无论模块头部是否有 <code>&quot;use strict&quot;</code> 。<br><strong>严格模式有以下限制</strong>：   </p><ul><li>变量必须<strong>声明后再使用</strong></li><li>函数的参数<strong>不能有同名属性</strong>，否则报错</li><li>不能使用 <code>with</code> 语句</li><li>不能对只读属性赋值，否则报错</li><li>不能使用前缀 0 表示八进制数，否则报错</li><li>不能删除不可删除的属性，否则报错</li><li>不能删除变量 <code>delete prop</code> ，会报错，只能删除属性 <code>delete * global[prop]</code></li><li><code>eval</code> 不会在它的外层作用域引入变量</li><li><code>eval</code> 和 <code>arguments</code> 不能被重新赋值</li><li><code>arguments</code> 不会自动反映函数参数的变化</li><li>不能使用 <code>arguments.callee</code></li><li>不能使用 <code>arguments.caller</code></li><li>禁止 <code>this</code> 指向全局对象</li><li>不能使用 <code>fn.caller</code> 和 <code>fn.arguments</code> 获取函数调用的堆栈</li><li>增加了保留字（比如 <code>protected</code> 、 <code>static</code> 和 <code>interface</code> ）</li></ul><p>特别是，ES6 中顶层 <code>this</code> 指向 <code>undefined</code> ，即不应该在顶层代码使用 <code>this</code> 。  </p><h2 id="export-命令"><a href="#export-命令" class="headerlink" title="export 命令"></a>export 命令</h2><p>使用 <code>export</code> 向模块外暴露接口，可以是方法，也可以是变量。   </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 1. 变量</span><span class="token keyword">export</span> <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token string">'leo'</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token comment">// 还可以</span><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token string">'leo'</span><span class="token punctuation">;</span><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token punctuation">&#123;</span>    a<span class="token punctuation">,</span>    b<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 2. 方法</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 还可以</span><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">...</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">...</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token punctuation">&#123;</span>    a1 <span class="token keyword">as</span> f1<span class="token punctuation">,</span>    a2 <span class="token keyword">as</span> f2<span class="token punctuation">&#125;</span></code></pre><p>可以使用 <code>as</code> 重命名函数的对外接口。<br><strong>特别注意</strong>：<br><code>export</code> 暴露的必须是接口，不能是值。  </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 错误</span><span class="token keyword">export</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">export</span> a<span class="token punctuation">;</span> <span class="token comment">// 报错</span><span class="token comment">// 正确</span><span class="token keyword">export</span> <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 正确</span><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token punctuation">&#123;</span>    a<span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 正确</span><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token punctuation">&#123;</span>    a <span class="token keyword">as</span> b<span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 正确</span></code></pre><p>暴露方法也是一样：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 错误</span><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">...</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">export</span> f<span class="token punctuation">;</span><span class="token comment">// 正确</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">...</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">...</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token punctuation">&#123;</span>    f<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h3 id="16-4-import-命令"><a href="#16-4-import-命令" class="headerlink" title="16.4 import 命令"></a>16.4 import 命令</h3><p>加载 <code>export</code> 暴露的接口，输出为变量。   </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span>    a<span class="token punctuation">,</span>    b<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'/a.js'</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p><code>import</code> 后大括号指定变量名，需要与 <code>export</code> 的模块暴露的名称一致。<br>也可以使用 <code>as</code> 为输入的变量重命名。   </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">&#123;</span>    a <span class="token keyword">as</span> leo<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'./a.js'</span><span class="token punctuation">;</span></code></pre><p><code>import</code> 不能直接修改输入变量的值，因为输入变量只读只是个接口，但是如果是个对象，可以修改它的属性。  </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 错误</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span>    a<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'./f.js'</span><span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span><span class="token comment">// 正确</span>a<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token string">'leo'</span><span class="token punctuation">;</span> <span class="token comment">// 不报错</span></code></pre><p><code>import</code> 命令具有提升效果，会提升到整个模块头部最先执行，且多次执行相同 <code>import</code> 只会执行一次。</p><h2 id="模块的整体加载"><a href="#模块的整体加载" class="headerlink" title="模块的整体加载"></a>模块的整体加载</h2><p>当一个模块暴露多个方法和变量，引用时可以用 <code>*</code> 整体加载。   </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// a.js</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">...</span><span class="token punctuation">&#125;</span><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">...</span><span class="token punctuation">&#125;</span><span class="token comment">// b.js</span><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> obj <span class="token keyword">from</span> <span class="token string">'/a.js'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>但是，不允许运行时改变：   </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> obj <span class="token keyword">from</span> <span class="token string">'/a.js'</span><span class="token punctuation">;</span><span class="token comment">// 不允许</span>obj<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token string">'leo'</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span><span class="token function-variable function">b</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">...</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><h2 id="export-default-命令"><a href="#export-default-命令" class="headerlink" title="export default 命令"></a>export default 命令</h2><p>使用 <code>export default</code> 命令，为模块指定默认输出，引用的时候直接指定任意名称即可。  </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// a.js</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'leo'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// b.js</span><span class="token keyword">import</span> leo <span class="token keyword">from</span> <span class="token string">'./a.js'</span><span class="token punctuation">;</span><span class="token function">leo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'leo'</span></code></pre><p><code>export default</code> 暴露有函数名的函数时，在调用时相当于匿名函数。   </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// a.js</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'leo'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 或者</span><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'leo'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> f<span class="token punctuation">;</span><span class="token comment">// b.js</span><span class="token keyword">import</span> leo <span class="token keyword">from</span> <span class="token string">'./a.js'</span><span class="token punctuation">;</span></code></pre><p><code>export default</code> 其实是输出一个名字叫 <code>default</code> 的变量，所以后面不能跟变量赋值语句。  </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 正确</span><span class="token keyword">export</span> <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> a<span class="token punctuation">;</span><span class="token comment">// 错误</span><span class="token keyword">export</span> <span class="token keyword">default</span><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre><p><code>export default</code> 命令的本质是将后面的值，赋给 <code>default</code> 变量，所以可以直接将一个值写在 <code>export default</code> 之后。   </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 正确</span><span class="token keyword">export</span> detault <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// 错误</span><span class="token keyword">export</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre><h2 id="export-和-import-复合写法"><a href="#export-和-import-复合写法" class="headerlink" title="export 和 import 复合写法"></a>export 和 import 复合写法</h2><p>常常在先输入后输出同一个模块使用，即转发接口，将两者写在一起。   </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">export</span> <span class="token punctuation">&#123;</span>    a<span class="token punctuation">,</span>    b<span class="token punctuation">&#125;</span><span class="token keyword">from</span> <span class="token string">'./leo.js'</span><span class="token punctuation">;</span><span class="token comment">// 理解为</span><span class="token keyword">import</span> <span class="token punctuation">&#123;</span>    a<span class="token punctuation">,</span>    b<span class="token punctuation">&#125;</span> <span class="token keyword">from</span> <span class="token string">'./leo.js'</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token punctuation">&#123;</span>    a<span class="token punctuation">,</span>    b<span class="token punctuation">&#125;</span></code></pre><p>常见的写法还有：   </p><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">// 接口改名</span><span class="token keyword">export</span> <span class="token punctuation">&#123;</span>    a <span class="token keyword">as</span> b<span class="token punctuation">&#125;</span><span class="token keyword">from</span> <span class="token string">'./leo.js'</span><span class="token punctuation">;</span><span class="token comment">// 整体输出</span><span class="token keyword">export</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token string">'./leo.js'</span><span class="token punctuation">;</span><span class="token comment">// 默认接口改名</span><span class="token keyword">export</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">default</span> <span class="token keyword">as</span> a<span class="token punctuation">&#125;</span><span class="token keyword">from</span> <span class="token string">'./leo.js'</span><span class="token punctuation">;</span></code></pre><p><strong>常常用在模块继承</strong>。  </p><h2 id="在浏览器中使用"><a href="#在浏览器中使用" class="headerlink" title="在浏览器中使用"></a>在浏览器中使用</h2><p>ES6 中，可以在浏览器使用 <code>&lt;script&gt;</code> 标签，需要加入 <code>type=&quot;module&quot;</code> 属性，并且这些都是异步加载，避免浏览器阻塞，即等到整个页面渲染完，再执行模块脚本，等同于打开了 <code>&lt;script&gt;</code> 标签的 <code>defer</code> 属性。   </p><pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>module<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./a.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>另外，ES6 模块也可以内嵌到网页，语法与外部加载脚本一致：   </p><pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>module<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript">    <span class="token keyword">import</span> a <span class="token keyword">from</span> <span class="token string">'./a.js'</span><span class="token punctuation">;</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><h2 id="在-Node-中使用"><a href="#在-Node-中使用" class="headerlink" title="在 Node 中使用"></a>在 Node 中使用</h2><p>安装最新版本的 Node，在 Node 13.2.0 之后，不需要使用 <code>--experimental-modules</code> 运行参数。  </p><p>两种方法：  </p><ol><li>在 <code>package.json</code> 中添加 <code>&quot;type&quot;: &quot;module&quot;</code> 。使用这种方法，所有的 <code>.js</code> 和 <code>.mjs</code> 文件都被解释为 ES 模块。如果想要将其解释为 CommonJS，则必须使用 <code>.cjs</code> 扩展名。  </li><li>不在 <code>package.json</code> 中设置类型， <code>.js</code> 文件会被当作 CommonJS 对待，但可以使用扩展名 <code>.mjs</code> 来让 Node 知道它是一个 ES6 模块。  </li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li><li>模块脚本自动采用严格模式，不管有没有声明 <code>use strict</code> 。</li><li>模块之中，可以使用 <code>import</code> 命令加载其他模块（ <code>.js</code> 后缀不可省略，需要提供 <code>绝对 UR</code> L 或 <code>相对 UR</code> L），也可以使用 <code>export</code> 命令输出对外接口。</li><li>模块之中，顶层的 <code>this</code> 关键字返回 <code>undefined</code> ，而不是指向 <code>window</code> 。也就是说，在模块顶层使用 <code>this</code> 关键字，是无意义的。</li><li>同一个模块如果加载多次，将只执行一次。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 javaScript 获取教务系统成绩并推送</title>
      <link href="2020/07/17/jsCheckGrade/"/>
      <url>2020/07/17/jsCheckGrade/</url>
      
        <content type="html"><![CDATA[<p><strong>适用于强智教务系统，不保证各个大学通用。</strong>  </p><p><a href="https://github.com/Konata09/GradeCheck">GitHub</a></p><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>通过教务系统成绩查询网页或者 api，使用 javaScript 脚本定时（默认定是 20 分钟）执行查询动作。<br>得到成绩后将所有成绩保存到文件，之后每次检查时进行比对，如果有新增的成绩就进行推送。<br>推送方案有多种选择，如方糖、Telegram Bot、邮件提醒、Bark 等。这里使用 <a href="https://github.com/Finb/Bark">Bark</a> 进行推送。Bark 是一个十分简洁的 iOS 推送 App，利用 Apple 统一的推送通道，延迟很小，但不支持 Android 系统。Bark 也可以自已部署服务端，能保证隐私不被泄露。<br>网页登录好像有定时强制注销用户的设定，即使一直访问也会出现需要登录的情况，出现 session 失效的情况可以在网页端重新登录一次，SessionId 不需要修改。</p><h2 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h2><p>以 Linux 系统为例</p><h3 id="安装-nodeJS-环境"><a href="#安装-nodeJS-环境" class="headerlink" title="安装 nodeJS 环境"></a>安装 nodeJS 环境</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://nodejs.org/dist/v12.18.2/node-v12.18.2-linux-x64.tar.xz<span class="token function">sudo</span> <span class="token function">mkdir</span> -p /usr/local/lib/nodejs<span class="token function">sudo</span> <span class="token function">tar</span> -xJvf node-v12.18.2-linux-x64.tar.xz -C /usr/local/lib/nodejs</code></pre><p>执行 <code>vim /etc/profile</code> ，在文件最后加上以下内容：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span>/usr/local/lib/nodejs/node-v12.18.2-linux-x64/bin:<span class="token environment constant">$PATH</span><span class="token builtin class-name">export</span> <span class="token assign-left variable">NODE_PATH</span><span class="token operator">=</span>/usr/local/lib/nodejs/node-v12.18.2-linux-x64/lib/node_modules</code></pre><h3 id="安装-nodeJS-模块"><a href="#安装-nodeJS-模块" class="headerlink" title="安装 nodeJS 模块"></a>安装 nodeJS 模块</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> -g pm2 cheerio node-schedule iconv-lite axios socks-proxy-agent</code></pre><h3 id="下载脚本"><a href="#下载脚本" class="headerlink" title="下载脚本"></a>下载脚本</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/Konata09/GradeCheck.git<span class="token builtin class-name">cd</span> GradeCheck</code></pre><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>打开 <code>config.json</code> 文件<br>填写示例如下：</p><pre class="language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"api"</span><span class="token punctuation">,</span>    <span class="token property">"site"</span><span class="token operator">:</span> <span class="token string">"jwgl.xxxx.edu.cn"</span><span class="token punctuation">,</span>    <span class="token property">"xh"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>    <span class="token property">"password"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>    <span class="token property">"JSESSIONID"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>    <span class="token property">"pushUrl"</span><span class="token operator">:</span> <span class="token string">"https://xxx/xxx/"</span><span class="token punctuation">,</span>    <span class="token property">"proxy"</span><span class="token operator">:</span> <span class="token string">"socks5://127.0.0.1:1080"</span><span class="token punctuation">&#125;</span></code></pre><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>可选 <code>web</code> 或者 <code>api</code> 。<br>代表成绩查询方法， <code>web</code> 代表从网页获取， <code>api</code> 代表从接口获取。  </p><p>从网页获取成绩不需要学号和密码，只需填写 <code>JSESSIONID</code> ，但可能会有 session 过期的问题。<br>从接口获取成绩不需要 <code>JSESSIONID</code> ，需要填写学号和密码，相比从网页获取更加稳定。  </p><h4 id="site"><a href="#site" class="headerlink" title="site"></a>site</h4><p>教务管理系统网址，不需要 http 前缀。</p><h4 id="xh"><a href="#xh" class="headerlink" title="xh"></a>xh</h4><p>学号，当 <code>type</code> 为 <code>web</code> 时，此项不必填写。</p><h4 id="password"><a href="#password" class="headerlink" title="password"></a>password</h4><p>教务管理系统密码，当 <code>type</code> 为 <code>web</code> 时，此项不必填写。</p><h4 id="JSESSIONID"><a href="#JSESSIONID" class="headerlink" title="JSESSIONID"></a>JSESSIONID</h4><p>用浏览器登录教务管理系统，将浏览器 Cookie 中的 <code>JSESSIONID=</code> 的后边内容填入。当 <code>type</code> 为 <code>api</code> 时，此项不必填写。</p><h4 id="pushUrl"><a href="#pushUrl" class="headerlink" title="pushUrl"></a>pushUrl</h4><p>Bark 的推送地址。<br>从 App Store 安装 Bark，即可得到推送地址，当然也可以是自己部署的服务端地址。</p><h4 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h4><p>对教务系统进行代理访问的代理服务器地址，支持 Socks4 和 Socks5 代理。不使用留空即可。</p><h3 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h3><pre class="language-bash" data-language="bash"><code class="language-bash">pm2 start gradeCheck.js</code></pre><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><pre class="language-bash" data-language="bash"><code class="language-bash">pm2 logs gradeCheck</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Filter 和 Listener</title>
      <link href="2020/06/19/FilterAndListener/"/>
      <url>2020/06/19/FilterAndListener/</url>
      
        <content type="html"><![CDATA[<h2 id="Filter-过滤器"><a href="#Filter-过滤器" class="headerlink" title="Filter 过滤器"></a>Filter 过滤器</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。</li><li>过滤器的作用：<ul><li>一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤。..</li></ul></li></ul><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><ol><li>定义一个类，实现接口 Filter</li><li>复写方法</li><li>配置拦截路径<ol><li>web.xml</li><li>注解</li></ol></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@WebFilter</span><span class="token punctuation">(</span><span class="token string">"/*"</span><span class="token punctuation">)</span><span class="token comment">//访问所有资源之前，都会执行该过滤器</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FilterDemo1</span> <span class="token keyword">implements</span> <span class="token class-name">Filter</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token class-name">FilterConfig</span> filterConfig<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doFilter</span><span class="token punctuation">(</span><span class="token class-name">ServletRequest</span> servletRequest<span class="token punctuation">,</span> <span class="token class-name">ServletResponse</span> servletResponse<span class="token punctuation">,</span> <span class="token class-name">FilterChain</span> filterChain<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ServletException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"filterDemo1 被执行了。..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">/</span><span class="token operator">/</span>放行        filterChain<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>servletRequest<span class="token punctuation">,</span>servletResponse<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="过滤器细节"><a href="#过滤器细节" class="headerlink" title="过滤器细节"></a>过滤器细节</h3><h4 id="web-xml-配置"><a href="#web-xml-配置" class="headerlink" title="web.xml 配置"></a>web.xml 配置</h4><pre class="language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">></span></span>demo1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-class</span><span class="token punctuation">></span></span>cn.itcast.web.filter.FilterDemo1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-class</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-mapping</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">></span></span>demo1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">></span></span>    <span class="token comment">&lt;!-- 拦截路径 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-mapping</span><span class="token punctuation">></span></span></code></pre><h4 id="过滤器执行流程"><a href="#过滤器执行流程" class="headerlink" title="过滤器执行流程"></a>过滤器执行流程</h4><ol><li>执行过滤器</li><li>执行放行后的资源</li><li>回来执行过滤器放行代码下边的代码</li></ol><h3 id="过滤器生命周期"><a href="#过滤器生命周期" class="headerlink" title="过滤器生命周期"></a>过滤器生命周期</h3><ol><li>init: 在服务器启动后，会创建 Filter 对象，然后调用 init 方法。只执行一次，用于加载资源。</li><li>doFilter: 每一次请求被拦截资源时都会执行。执行多次。</li><li>destroy: 在服务器关闭后，Filter 对象被销毁。如果服务器是正常关闭，则会执行 destroy 方法。只执行一次，一般用于释放资源。</li></ol><h4 id="过滤器配置详解"><a href="#过滤器配置详解" class="headerlink" title="过滤器配置详解"></a>过滤器配置详解</h4><ul><li>拦截路径配置：<ol><li>具体资源路径： <code>/index.jsp</code> 只有访问 index.jsp 资源时，过滤器才会被执行</li><li>拦截目录： <code>/user/*</code> 访问/user 下的所有资源时，过滤器都会被执行</li><li>后缀名拦截： <code>*.jsp</code> 访问所有后缀名为 jsp 资源时，过滤器都会被执行</li><li>拦截所有资源： <code>/*</code> 访问所有资源时，过滤器都会被执行</li></ol></li><li>拦截方式配置：资源被访问的方式<ul><li>注解配置：<ul><li>设置 <code>dispatcherTypes</code> 属性<pre><code>  1. `REQUEST` ：默认值。浏览器直接请求资源  2. `FORWARD` ：转发访问资源  3. `INCLUDE` ：包含访问资源  4. `ERROR` ：错误跳转资源  5. `ASYNC` ：异步访问资源</code></pre></li></ul></li><li>web.xml 配置<ul><li>设置 <code>&lt;dispatcher&gt;&lt;/dispatcher&gt;</code> 标签即可</li></ul></li></ul></li></ul><h3 id="过滤器链（配置多个过滤器）"><a href="#过滤器链（配置多个过滤器）" class="headerlink" title="过滤器链（配置多个过滤器）"></a>过滤器链（配置多个过滤器）</h3><ul><li><p>执行顺序：如果有两个过滤器：过滤器 1 和过滤器 2</p><ol><li>过滤器 1</li><li>过滤器 2</li><li>资源执行</li><li>过滤器 2</li><li>过滤器 1</li></ol></li><li><p>过滤器先后顺序问题：</p><ol><li>注解配置：按照类名的字符串比较规则比较，值小的先执行<ul><li>如： AFilter 和 BFilter，AFilter 就先执行了。</li></ul></li><li>web.xml 配置： <code>&lt;filter-mapping&gt;</code> 谁定义在上边，谁先执行</li></ol></li></ul><h2 id="Listener-监听器"><a href="#Listener-监听器" class="headerlink" title="Listener 监听器"></a>Listener 监听器</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>web 的三大组件之一</p><h3 id="事件监听机制"><a href="#事件监听机制" class="headerlink" title="事件监听机制"></a>事件监听机制</h3><ul><li><p>事件 ：一件事情</p></li><li><p>事件源 ：事件发生的地方</p></li><li><p>监听器 ：一个对象</p></li><li><p>注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码</p></li><li><p>ServletContextListener: 监听 ServletContext 对象的创建和销毁</p></li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p> <code>void contextDestroyed(ServletContextEvent sce)</code><br>ServletContext 对象被销毁之前会调用该方法<br> <code>void contextInitialized(ServletContextEvent sce)</code><br>ServletContext 对象创建后会调用该方法</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>定义一个类，实现 <code>ServletContextListener</code> 接口</li><li>复写方法</li><li>配置 web.xml</li></ol><pre class="language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>listener</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>listener-class</span><span class="token punctuation">></span></span>cn.itcast.web.listener.ContextLoaderListener<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>listener-class</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>listener</span><span class="token punctuation">></span></span></code></pre><ul><li>指定初始化参数 <code>&lt;context-param&gt;</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EL 表达式和 JSTL</title>
      <link href="2020/06/19/ELAndJSTL/"/>
      <url>2020/06/19/ELAndJSTL/</url>
      
        <content type="html"><![CDATA[<h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>用于配置 JSP 页面，导入资源文件</p><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><p> <code>&lt;%@ 指令名称 属性名 1=属性值 1 属性名 2=属性值 2 ... %&gt;</code></p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><h5 id="page"><a href="#page" class="headerlink" title="page"></a>page</h5><p>配置 JSP 页面</p><ul><li><code>contentType</code> ：等同于 <code>response.setContentType()</code><ol><li>设置响应体的 mime 类型以及字符集</li><li>设置当前 jsp 页面的编码（只能是高级的 IDE 才能生效，如果使用低级工具，则需要设置 pageEncoding 属性设置当前页面的字符集）</li></ol></li><li><code>import</code> ：导包</li><li><code>errorPage</code> ：当前页面发生异常后，会自动跳转到指定的错误页面</li><li><code>isErrorPage</code> ：标识当前也是是否是错误页面。<ul><li>true：是，可以使用内置对象 exception</li><li>false：否。默认值。不可以使用内置对象 exception</li></ul></li></ul><h4 id="include"><a href="#include" class="headerlink" title="include"></a>include</h4><p>页面包含的。导入页面的资源文件<br> <code>&lt;%@include file=&quot;top.jsp&quot;%&gt;</code></p><h4 id="taglib"><a href="#taglib" class="headerlink" title="taglib"></a>taglib</h4><p>导入资源<br> <code>&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</code></p><ul><li>prefix：前缀，自定义的</li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ol><li>html 注释：</li></ol><p><code>&lt;!-- --&gt;</code> : 只能注释 html 代码片段</p><ol start="2"><li>jsp 注释：推荐使用</li></ol><p><code>&lt;%-- --%&gt;</code> ：可以注释所有</p><h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><ul><li><p>在 jsp 页面中不需要创建，直接使用的对象  </p></li><li><p>一共有 9 个：</p><table><thead><tr><th>变量名</th><th>真实类型</th><th>作用</th></tr></thead><tbody><tr><td>pageContext</td><td>PageContext</td><td>当前页面共享数据，还可以获取其他八个内置对象</td></tr><tr><td>request</td><td>HttpServletRequest</td><td>一次请求访问的多个资源（转发）</td></tr><tr><td>session</td><td>HttpSession</td><td>一次会话的多个请求间</td></tr><tr><td>application</td><td>ServletContext</td><td>所有用户间共享数据</td></tr><tr><td>response</td><td>HttpServletResponse</td><td>响应对象</td></tr><tr><td>page</td><td>Object</td><td>当前页面 (Servlet) 的对象  this</td></tr><tr><td>out</td><td>JspWriter</td><td>输出对象，数据输出到页面上</td></tr><tr><td>config</td><td>ServletConfig</td><td>Servlet 的配置对象</td></tr><tr><td>exception</td><td>Throwable</td><td>异常对象</td></tr></tbody></table></li></ul><h2 id="EL-表达式"><a href="#EL-表达式" class="headerlink" title="EL 表达式"></a>EL 表达式</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Expression Language 表达式语言</p><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>替换和简化 jsp 页面中 java 代码的编写</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p> <code>$&#123;表达式&#125;</code></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>jsp 默认支持 el 表达式，如果要忽略 el 表达式</p><ol><li>设置 jsp 中 page 指令中： <code>isELIgnored=&quot;true&quot;</code> 忽略当前 jsp 页面中所有的 el 表达式</li><li><code>\$&#123;表达式&#125;</code> ：忽略当前这个 el 表达式</li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><ol><li>算数运算符： <code>+ - * /(div) %(mod)</code></li><li>比较运算符： <code>&gt; &lt; &gt;= &lt;= == !=</code></li><li>逻辑运算符： <code>&amp;&amp;(and) ||(or) !(not)</code></li><li>空运算符： <code>empty</code><ul><li>功能：用于判断字符串、集合、数组对象是否为 null 或者长度是否为 0</li><li><code>$&#123;empty list&#125;</code> : 判断字符串、集合、数组对象是否为 null 或者长度为 0</li><li><code>$&#123;not empty str&#125;</code> : 表示判断字符串、集合、数组对象是否不为 null 并且 长度&gt;0</li></ul></li></ol><h4 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h4><ul><li>el 表达式只能从域对象中获取值</li></ul><ol><li><p><code>$&#123;域名称。键名&#125;</code> ：从指定域中获取指定键的值</p><ul><li>域名称：<ol><li>pageScope  –&gt; pageContext</li><li>requestScope  –&gt; request</li><li>sessionScope  –&gt; session</li><li>applicationScope –&gt; application（ServletContext）</li></ol></li><li>举例：在 request 域中存储了 name=张三</li><li>获取： <code>$&#123;requestScope.name&#125;</code></li></ul></li><li><p><code>$&#123;键名&#125;</code> ：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。</p></li><li><p>获取对象、List 集合、Map 集合的值</p><ol><li><p>对象： <code>$&#123;域名称。键名。属性名&#125;</code></p><ul><li>本质上会去调用对象的 getter 方法</li></ul></li><li><p>List 集合：${域名称。键名 [索引]}</p></li><li><p>Map 集合：</p><ul><li><code>$&#123;域名称。键名。key 名称&#125;</code></li><li><code>$&#123;域名称。键名 [&quot;key 名称&quot;]&#125;</code></li></ul></li></ol></li></ol><h4 id="隐式对象"><a href="#隐式对象" class="headerlink" title="隐式对象"></a>隐式对象</h4><ul><li>EL 表达式中有 11 个隐式对象</li><li><code>pageContext</code> :<ul><li>获取 jsp 其他八个内置对象<ul><li><code>$&#123;pageContext.request.contextPath&#125;</code> ：动态获取虚拟目录</li></ul></li></ul></li></ul><h2 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>JavaServer Pages Tag Library  JSP 标准标签库<br>是由 Apache 组织提供的开源的免费的 jsp 标签  &lt;标签&gt;</p><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p>用于简化和替换 jsp 页面上的 java 代码  </p><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol><li>导入 jstl 相关 jar 包</li><li>引入标签库：taglib 指令： <code>&lt;%@ taglib %&gt;</code></li><li>使用标签</li></ol><h3 id="常用的-JSTL-标签"><a href="#常用的-JSTL-标签" class="headerlink" title="常用的 JSTL 标签"></a>常用的 JSTL 标签</h3><ol><li><p><code>if</code> : 相当于 java 代码的 if 语句</p><ol><li>属性：<ul><li>test 必须属性，接受 boolean 表达式<ul><li>如果表达式为 true，则显示 if 标签体内容，如果为 false，则不显示标签体内容</li><li>一般情况下，test 属性值会结合 el 表达式一起使用</li></ul></li></ul></li><li>注意：<ul><li>c:if 标签没有 else 情况，想要 else 情况，则可以在定义一个 c:if 标签</li></ul></li></ol></li><li><p><code>choose</code> : 相当于 java 代码的 switch 语句</p><ol><li><p>使用 choose 标签声明</p><p>相当于 switch 声明</p></li><li><p>使用 when 标签做判断</p><p>相当于 case</p></li><li><p>使用 otherwise 标签做其他情况的声明</p><p>相当于 default</p></li></ol></li><li><p><code>foreach</code> : 相当于 java 代码的 for 语句</p></li></ol><h2 id="MVC-开发模式"><a href="#MVC-开发模式" class="headerlink" title="MVC 开发模式"></a>MVC 开发模式</h2><h3 id="jsp-演变历史"><a href="#jsp-演变历史" class="headerlink" title="jsp 演变历史"></a>jsp 演变历史</h3><ol><li>早期只有 servlet，只能使用 response 输出标签数据，非常麻烦</li><li>后来又 jsp，简化了 Servlet 的开发，如果过度使用 jsp，在 jsp 中即写大量的 java 代码，有写 html 表，造成难于维护，难于分工协作</li><li>再后来，java 的 web 开发，借鉴 MVC 开发模式，使得程序的设计更加合理性</li></ol><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p><img src="/images/2020-06-19T130251.png" alt="MVC 开发模式"></p><ol><li>M：Model，模型。JavaBean<ul><li>完成具体的业务操作，如：查询数据库，封装对象</li></ul></li><li>V：View，视图。JSP<ul><li>展示数据</li></ul></li><li>C：Controller，控制器。Servlet<ul><li>获取用户的输入</li><li>调用模型</li><li>将数据交给视图进行展示</li></ul></li></ol><ul><li><p>优缺点：</p><ol><li><p>优点：</p><ol><li>耦合性低，方便维护，可以利于分工协作</li><li>重用性高</li></ol></li><li><p>缺点：</p><ol><li>使得项目架构变得复杂，对开发人员要求高</li></ol></li></ol></li></ul><h3 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h3><p><img src="/images/2020-06-19T131333.png" alt=""></p><ol><li>界面层（表示层）：用户看的得界面。用户可以通过界面上的组件和服务器进行交互</li><li>业务逻辑层：处理业务逻辑的。</li><li>数据访问层：操作数据存储文件。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cookie 和 Session</title>
      <link href="2020/06/18/CookieAndSession/"/>
      <url>2020/06/18/CookieAndSession/</url>
      
        <content type="html"><![CDATA[<h2 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h2><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>一次会话中包含多次请求和响应。</p><ul><li>一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止</li></ul><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>在一次会话的范围内的多次请求间，共享数据</p><h3 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h3><ol><li>客户端会话技术：Cookie</li><li>服务器端会话技术：Session</li></ol><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>客户端会话技术，将数据保存到客户端</p><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><ol><li><p>创建 Cookie 对象，绑定数据  </p><p><code>new Cookie(String name, String value)</code></p></li><li><p>发送 Cookie 对象  </p><p><code>response.addCookie(Cookie cookie)</code></p></li><li><p>获取 Cookie，拿到数据  </p><p><code>Cookie[]  request.getCookies()</code></p></li></ol><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>基于响应头 set-cookie 和请求头 cookie 实现</p><h3 id="cookie-的细节"><a href="#cookie-的细节" class="headerlink" title="cookie 的细节"></a>cookie 的细节</h3><h4 id="一次可不可以发送多个-cookie"><a href="#一次可不可以发送多个-cookie" class="headerlink" title="一次可不可以发送多个 cookie"></a>一次可不可以发送多个 cookie</h4><ul><li>可以</li><li>可以创建多个 Cookie 对象，使用 response 调用多次 addCookie 方法发送 cookie 即可。</li></ul><h4 id="cookie-在浏览器中保存多长时间"><a href="#cookie-在浏览器中保存多长时间" class="headerlink" title="cookie 在浏览器中保存多长时间"></a>cookie 在浏览器中保存多长时间</h4><ol><li><p>默认情况下，当浏览器关闭后，Cookie 数据被销毁</p></li><li><p>持久化存储：  </p><p><code>setMaxAge(int seconds)</code></p><ol><li>正数：将 Cookie 数据写到硬盘的文件中。持久化存储。并指定 cookie 存活时间，时间到后，cookie 文件自动失效</li><li>负数：默认值</li><li>零：删除 cookie 信息</li></ol></li></ol><h4 id="cookie-能不能存中文"><a href="#cookie-能不能存中文" class="headerlink" title="cookie 能不能存中文"></a>cookie 能不能存中文</h4><ul><li>在 tomcat 8 之前 cookie 中不能直接存储中文数据。需要将中文数据转码—一般采用 URL 编码 (%E3)</li><li>在 tomcat 8 之后，cookie 支持中文数据。特殊字符还是不支持，建议使用 URL 编码存储，URL 解码解析</li></ul><h4 id="cookie-共享问题"><a href="#cookie-共享问题" class="headerlink" title="cookie 共享问题"></a>cookie 共享问题</h4><ol><li><p>假设在一个 tomcat 服务器中，部署了多个 web 项目，那么在这些 web 项目中 cookie 能不能共享？</p><ul><li><p>默认情况下 cookie 不能共享</p></li><li><p><code>setPath(String path)</code> : 设置 cookie 的获取范围。默认情况下，设置当前的虚拟目录  </p><p>如果要共享，则可以将 path 设置为”/“</p></li></ul></li><li><p>不同的 tomcat 服务器间 cookie 共享问题？</p><ul><li><code>setDomain(String path)</code> : 如果设置一级域名相同，那么多个服务器之间 cookie 可以共享  </li></ul></li></ol><p><code>setDomain(&quot;.baidu.com&quot;)</code> , 那么 tieba.baidu.com 和 news.baidu.com 中 cookie 可以共享</p><h3 id="Cookie-的特点和作用"><a href="#Cookie-的特点和作用" class="headerlink" title="Cookie 的特点和作用"></a>Cookie 的特点和作用</h3><ol><li>cookie 存储数据在客户端浏览器</li><li>浏览器对于单个 cookie 的大小有限制 (4kb) 以及 对同一个域名下的总 cookie 数量也有限制 (20 个）</li></ol><ul><li>作用：<ol><li>cookie 一般用于存出少量的不太敏感的数据</li><li>在不登录的情况下，完成服务器对客户端的身份识别</li></ol></li></ul><h2 id="JSP-入门"><a href="#JSP-入门" class="headerlink" title="JSP 入门"></a>JSP 入门</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li>Java Server Pages： java 服务器端页面<ul><li>可以理解为：一个特殊的页面，其中既可以指定定义 html 标签，又可以定义 java 代码</li><li>用于简化书写！！！</li></ul></li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>JSP 本质上就是一个 Servlet<br><img src="/images/2020-06-19T001909.png" alt=""></p><h3 id="JSP-的脚本"><a href="#JSP-的脚本" class="headerlink" title="JSP 的脚本"></a>JSP 的脚本</h3><p>JSP 定义 Java 代码的方式</p><ol><li><code>&lt;%  代码 %&gt;</code> ：定义的 java 代码，在 service 方法中。service 方法中可以定义什么，该脚本中就可以定义什么。</li><li><code>&lt;%! 代码 %&gt;</code> ：定义的 java 代码，在 jsp 转换后的 java 类的成员位置。</li><li><code>&lt;%= 代码 %&gt;</code> ：定义的 java 代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。</li></ol><h3 id="JSP-的内置对象"><a href="#JSP-的内置对象" class="headerlink" title="JSP 的内置对象"></a>JSP 的内置对象</h3><ul><li><p>在 jsp 页面中不需要获取和创建，可以直接使用的对象</p></li><li><p>jsp 一共有 9 个内置对象</p><ul><li><p>request</p></li><li><p>response</p></li><li><p>out：字符输出流对象。可以将数据输出到页面上。和 <code>response.getWriter()</code> 类似</p><blockquote><p><code>response.getWriter()</code> 和 <code>out.write()</code> 的区别：  </p><ul><li>在 tomcat 服务器真正给客户端做出响应之前，会先找 response 缓冲区数据，再找 out 缓冲区数据。</li><li><code>response.getWriter()</code> 数据输出永远在 <code>out.write()</code> 之前</li></ul></blockquote></li></ul></li></ul><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession</p><h3 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h3><ol><li><p>获取 HttpSession 对象：  </p><p><code>HttpSession session = request.getSession();</code></p></li><li><p>使用 HttpSession 对象：  </p><p><code>Object getAttribute(String name)</code><br><code>void setAttribute(String name, Object value)</code><br><code>void removeAttribute(String name)</code></p></li><li><p>原理</p></li></ol><p>Session 的实现是依赖于 Cookie 的。</p><p><img src="/images/2020-06-19T002012.png" alt="2020-06-19T002012"></p><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><h4 id="当客户端关闭后，服务器不关闭，两次获取-session-是否为同一个"><a href="#当客户端关闭后，服务器不关闭，两次获取-session-是否为同一个" class="headerlink" title="当客户端关闭后，服务器不关闭，两次获取 session 是否为同一个"></a>当客户端关闭后，服务器不关闭，两次获取 session 是否为同一个</h4><ul><li>默认情况下。不是。</li><li>如果需要相同，则可以创建 Cookie, 键为 JSESSIONID，设置最大存活时间，让 cookie 持久化保存。</li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Cookie</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cookie</span><span class="token punctuation">(</span><span class="token string">"JSESSIONID"</span><span class="token punctuation">,</span>session<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>c<span class="token punctuation">.</span><span class="token function">setMaxAge</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token operator">*</span><span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>response<span class="token punctuation">.</span><span class="token function">addCookie</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="客户端不关闭，服务器关闭后，两次获取的-session-是同一个吗"><a href="#客户端不关闭，服务器关闭后，两次获取的-session-是同一个吗" class="headerlink" title="客户端不关闭，服务器关闭后，两次获取的 session 是同一个吗"></a>客户端不关闭，服务器关闭后，两次获取的 session 是同一个吗</h4><ul><li>不是同一个，但是要确保数据不丢失。tomcat 自动完成以下工作<ul><li>session 的钝化：<ul><li>在服务器正常关闭之前，将 session 对象系列化到硬盘上</li></ul></li><li>session 的活化：<ul><li>在服务器启动后，将 session 文件转化为内存中的 session 对象即可。</li></ul></li></ul></li></ul><h4 id="session-什么时候被销毁"><a href="#session-什么时候被销毁" class="headerlink" title="session 什么时候被销毁"></a>session 什么时候被销毁</h4><ol><li><p>服务器关闭</p></li><li><p>session 对象调用 <code>invalidate()</code> 。</p></li><li><p>session 默认失效时间 30 分钟</p><p> 选择性配置修改</p></li></ol><pre class="language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>session-config</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>session-timeout</span><span class="token punctuation">></span></span>30<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>session-timeout</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>session-config</span><span class="token punctuation">></span></span></code></pre><h4 id="session-的特点"><a href="#session-的特点" class="headerlink" title="session 的特点"></a>session 的特点</h4><ol><li>session 用于存储一次会话的多次请求的数据，存在服务器端</li><li>session 可以存储任意类型，任意大小的数据</li></ol><h4 id="session-与-Cookie-的区别"><a href="#session-与-Cookie-的区别" class="headerlink" title="session 与 Cookie 的区别"></a>session 与 Cookie 的区别</h4><ol><li>session 存储数据在服务器端，Cookie 在客户端</li><li>session 没有数据大小限制，Cookie 有</li><li>session 数据安全，Cookie 相对于不安全</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Response 对象</title>
      <link href="2020/06/18/ResponseObj/"/>
      <url>2020/06/18/ResponseObj/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/2020-06-18T235353.png" alt="request&amp;response 对象原理"></p><h2 id="HTTP-响应消息"><a href="#HTTP-响应消息" class="headerlink" title="HTTP 响应消息"></a>HTTP 响应消息</h2><h3 id="响应行"><a href="#响应行" class="headerlink" title="响应行"></a>响应行</h3><ol><li>组成：协议/版本 响应状态码 状态码描述</li><li>响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。<ul><li>1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送 1xx 多状态码</li><li>2xx：成功。代表：200</li><li>3xx：重定向。代表：302（重定向），304（访问缓存）</li><li>4xx：客户端错误。<ul><li>404（请求路径没有对应的资源）</li><li>405 请求方式没有对应的 doXxx 方法</li></ul></li><li>5xx：服务器端错误。代表：500（服务器内部出现异常）</li></ul></li></ol><h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><ol><li>格式： <code>头名称：值</code></li><li>常见的响应头：<ol><li><code>Content-Type</code> ：服务器告诉客户端本次响应体数据格式以及编码格式</li><li><code>Content-disposition</code> ：服务器告诉客户端以什么格式打开响应体数据<ul><li><code>in-line</code> : 默认值，在当前页面内打开</li><li><code>attachment;filename=xxx</code> ：以附件形式打开响应体。文件下载</li></ul></li></ol></li></ol><h3 id="响应空行"><a href="#响应空行" class="headerlink" title="响应空行"></a>响应空行</h3><h3 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h3><p>传输的数据</p><h3 id="响应字符串格式"><a href="#响应字符串格式" class="headerlink" title="响应字符串格式"></a>响应字符串格式</h3><pre class="language-html" data-language="html"><code class="language-html">HTTP/1.1 200 OKContent-Type: text/html;charset=UTF-8Content-Length: 101Date: Wed, 06 Jun 2018 07:08:42 GMT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>$Title$<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    hello , response<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><h2 id="response-对象"><a href="#response-对象" class="headerlink" title="response 对象"></a>response 对象</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><h4 id="设置响应消息"><a href="#设置响应消息" class="headerlink" title="设置响应消息"></a>设置响应消息</h4><ol><li>设置响应行<ol><li>格式： <code>HTTP/1.1 200 OK</code></li><li>设置状态码： <code>setStatus(int sc)</code></li></ol></li><li>设置响应头： <code>setHeader(String name, String value)</code></li><li>设置响应体：<ol><li>获取输出流<ul><li>字符输出流： <code>PrintWriter getWriter()</code></li><li>字节输出流： <code>ServletOutputStream getOutputStream()</code></li></ul></li><li>使用输出流，将数据输出到客户端浏览器</li></ol></li></ol><h4 id="完成重定向"><a href="#完成重定向" class="headerlink" title="完成重定向"></a>完成重定向</h4><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//1. 设置状态码为 302</span>response<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span><span class="token number">302</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//2. 设置响应头 location</span>response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">"location"</span><span class="token punctuation">,</span><span class="token string">"/day15/responseDemo2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//简单的重定向方法</span>response<span class="token punctuation">.</span><span class="token function">sendRedirect</span><span class="token punctuation">(</span><span class="token string">"/day15/responseDemo2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="forward-和-redirect-区别"><a href="#forward-和-redirect-区别" class="headerlink" title="forward 和  redirect 区别"></a>forward 和  redirect 区别</h3><ul><li>重定向的特点：redirect<ol><li>地址栏发生变化</li><li>重定向可以访问其他站点（服务器）的资源</li><li>重定向是两次请求。不能使用 request 对象来共享数据</li></ol></li><li>转发的特点：forward<ol><li>转发地址栏路径不变</li><li>转发只能访问当前服务器下的资源</li><li>转发是一次请求，可以使用 request 对象来共享数据</li></ol></li></ul><ul><li>服务器输出字符数据到浏览器<ul><li>步骤：<pre><code>1. 获取字符输出流2. 输出数据</code></pre></li><li>乱码问题：<pre><code>1. `PrintWriter pw = response.getWriter();` 获取的流的默认编码是 ISO-8859-12. 设置该流的默认编码3. 告诉浏览器响应体使用的编码</code></pre></li></ul></li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//简单的形式，设置编码，是在获取流之前设置</span>response<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">"text/html;charset=utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="ServletContext-对象"><a href="#ServletContext-对象" class="headerlink" title="ServletContext 对象"></a>ServletContext 对象</h2><p>代表整个 web 应用，可以和程序的容器（服务器）来通信</p><h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><ol><li><p>通过 request 对象获取  </p><p><code>request.getServletContext();</code></p></li><li><p>通过 HttpServlet 获取  </p><p><code>this.getServletContext();</code></p></li></ol><h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><ol><li><p>获取 MIME 类型：</p><p><code>String getMimeType(String file)</code></p></li><li><p>域对象：共享数据</p><ol><li><code>setAttribute(String name,Object value)</code></li><li><code>getAttribute(String name)</code></li><li><code>removeAttribute(String name)</code><blockquote><p>ServletContext 对象范围：所有用户所有请求的数据</p></blockquote></li></ol></li><li><p>获取文件的真实（服务器）路径 <code>String getRealPath(String path)</code></p></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> b <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getRealPath</span><span class="token punctuation">(</span><span class="token string">"/b.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//web 目录下资源访问</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> c <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getRealPath</span><span class="token punctuation">(</span><span class="token string">"/WEB-INF/c.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//WEB-INF 目录下的资源访问</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> a <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getRealPath</span><span class="token punctuation">(</span><span class="token string">"/WEB-INF/classes/a.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//src 目录下的资源访问</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Request 对象</title>
      <link href="2020/06/18/RequestObj/"/>
      <url>2020/06/18/RequestObj/</url>
      
        <content type="html"><![CDATA[<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h3 id="Servlet-的体系结构"><a href="#Servlet-的体系结构" class="headerlink" title="Servlet 的体系结构"></a>Servlet 的体系结构</h3><pre class="language-none"><code class="language-none">Servlet -- 接口    |GenericServlet -- 抽象类    |HttpServlet  -- 抽象类</code></pre><h3 id="GenericServlet"><a href="#GenericServlet" class="headerlink" title="GenericServlet"></a>GenericServlet</h3><p>将 Servlet 接口中其他的方法做了默认空实现，只将 service() 方法作为抽象。<br>将来定义 Servlet 类时，可以继承 GenericServlet，实现 service() 方法即可</p><h4 id="HttpServlet"><a href="#HttpServlet" class="headerlink" title="HttpServlet"></a>HttpServlet</h4><p>对 http 协议的一种封装，简化操作</p><ol><li>定义类继承 HttpServlet</li><li>复写 doGet/doPost 方法</li></ol><h3 id="Servlet-相关配置"><a href="#Servlet-相关配置" class="headerlink" title="Servlet 相关配置"></a>Servlet 相关配置</h3><p><code>urlpartten</code> : Servlet 访问路径  </p><ul><li><p>一个 Servlet 可以定义多个访问路径：</p><p><code>@WebServlet(&#123;&quot;/d4&quot;,&quot;/dd4&quot;,&quot;/ddd4&quot;&#125;)</code></p></li><li><p>路径定义规则：</p><ol><li><code>/xxx</code> ：路径匹配</li><li><code>/xxx/xxx</code> : 多层路径，目录结构</li><li><code>*.do</code> ：扩展名匹配</li></ol></li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h3><p>HTTP 协议有 7 中请求方式，常用的有 2 种</p><ul><li>GET：<ol><li>请求参数在请求行中，在 url 后。</li><li>请求的 url 长度有限制的</li><li>不太安全</li></ol></li><li>POST：<ol><li>请求参数在请求体中</li><li>请求的 url 长度没有限制的</li><li>相对安全</li></ol></li></ul><h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><p>客户端浏览器告诉服务器一些信息<br>请求头名称：请求头值<br>常见的请求头：</p><ol><li><p>User-Agent：浏览器版本信息</p><ul><li>可以在服务器端获取该头的信息，解决浏览器的兼容性问题</li></ul></li><li><p>Referer：<a href="http://localhost/login.html">http://localhost/login.html</a></p><ol><li>防盗链</li><li>统计工作</li></ol></li><li><p>请求空行  </p><p> 空行，就是用于分割 POST 请求的请求头，和请求体的。</p></li><li><p>请求体（正文）：</p><ul><li>封装 POST 请求消息的请求参数的</li></ul></li></ol><pre class="language-none"><code class="language-none">POST &#x2F;login.html HTTP&#x2F;1.1Host: localhostUser-Agent: Mozilla&#x2F;5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko&#x2F;20100101 Firefox&#x2F;60.0Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2Accept-Encoding: gzip, deflateReferer: http:&#x2F;&#x2F;localhost&#x2F;login.htmlConnection: keep-aliveUpgrade-Insecure-Requests: 1</code></pre><h2 id="Request-对象"><a href="#Request-对象" class="headerlink" title="Request 对象"></a>Request 对象</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol><li>request 和 response 对象是由服务器创建的。我们来使用它们</li><li>request 对象是来获取请求消息，response 对象是来设置响应消息</li></ol><h3 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a>继承结构</h3><pre class="language-none"><code class="language-none">ServletRequest  -- 接口    | 继承HttpServletRequest -- 接口    | 实现org.apache.catalina.connector.RequestFacade 类 (tomcat)</code></pre><h3 id="request-功能"><a href="#request-功能" class="headerlink" title="request 功能"></a>request 功能</h3><p> <code>GET /day14/demo1?name=zhangsan HTTP/1.1</code></p><ol><li><p>获取请求方式 ：GET</p><ul><li><code>String getMethod()</code></li></ul></li><li><p>获取虚拟目录：/day14</p><ul><li><code>String getContextPath()</code></li></ul></li><li><p>获取 Servlet 路径：/demo1</p><ul><li><code>String getServletPath()</code></li></ul></li><li><p>获取 get 方式请求参数：name=zhangsan</p><ul><li><code>String getQueryString()</code></li></ul></li><li><p>获取请求 URI：/day14/demo1</p><ul><li><code>String getRequestURI()</code> : <code>/day14/demo1</code></li><li><code>StringBuffer getRequestURL()</code> : <code>http://localhost/day14/demo1</code></li><li>URL: 统一资源定位符： <code>http://localhost/day14/demo1</code></li><li>URI：统一资源标识符： <code>/day14/demo1</code></li></ul></li><li><p>获取协议及版本：HTTP/1.1</p><ul><li><code>String getProtocol()</code></li></ul></li><li><p>获取客户机的 IP 地址：</p><ul><li><code>String getRemoteAddr()</code></li></ul></li><li><p>获取请求头数据</p><ul><li><code>String getHeader(String name)</code> : 通过请求头的名称获取请求头的值</li><li><code>Enumeration&lt;String&gt; getHeaderNames()</code> : 获取所有的请求头名称</li></ul></li><li><p>获取请求体数据：</p><ul><li>请求体：只有 POST 请求方式，才有请求体，在请求体中封装了 POST 请求的请求参数</li></ul><ol><li><p>获取流对象</p><ul><li><code>BufferedReader getReader()</code> ：获取字符输入流，只能操作字符数据</li><li><code>ServletInputStream getInputStream()</code> ：获取字节输入流，可以操作所有类型数据</li></ul></li><li><p>再从流对象中拿数据</p></li></ol></li></ol><h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><h4 id="获取请求参数通用方式"><a href="#获取请求参数通用方式" class="headerlink" title="获取请求参数通用方式"></a>获取请求参数通用方式</h4><p>不论 get 还是 post 请求方式都可以使用下列方法来获取请求参数</p><ol><li><p><code>String getParameter(String name)</code> : 根据参数名称获取参数值  </p><p> username=zs&amp;password=123</p></li><li><p><code>String[] getParameterValues(String name)</code> : 根据参数名称获取参数值的数组  </p><p> hobby=xx&amp;hobby=game</p></li><li><p><code>Enumeration&lt;String&gt; getParameterNames()</code> : 获取所有请求的参数名称</p></li><li><p><code>Map&lt;String,String[]&gt; getParameterMap()</code> : 获取所有参数的 map 集合</p></li></ol><ul><li><p>中文乱码问题：</p><ul><li>get 方式：tomcat 8 已经将 get 方式乱码问题解决了</li><li>post 方式：在获取参数前，设置 request 的编码  </li></ul><p><code>request.setCharacterEncoding(&quot;utf-8&quot;);</code></p></li></ul><h4 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h4><p>一种在服务器内部的资源跳转方式</p><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ol><li><p>通过 <code>request</code> 对象获取请求转发器对象：  </p><p><code>RequestDispatcher getRequestDispatcher(String path)</code></p></li><li><p>使用 <code>RequestDispatcher</code> 对象来进行转发：</p><p><code>forward(ServletRequest request, ServletResponse response)</code></p></li></ol><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol><li>浏览器地址栏路径不发生变化</li><li>只能转发到当前服务器内部资源中。</li><li>转发是一次请求</li></ol><h4 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h4><ul><li>域对象：一个有作用范围的对象，可以在范围内共享数据</li><li>request 域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据</li><li>方法：<ol><li><code>void setAttribute(String name,Object obj)</code> : 存储数据</li><li><code>Object getAttitude(String name)</code> : 通过键获取值</li><li><code>void removeAttribute(String name)</code> : 通过键移除键值对</li></ol></li></ul><h4 id="获取-ServletContext"><a href="#获取-ServletContext" class="headerlink" title="获取 ServletContext"></a>获取 <code>ServletContext</code></h4><p> <code>ServletContext getServletContext()</code></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat 和 Servlet 基础</title>
      <link href="2020/06/18/TomcatServletBase/"/>
      <url>2020/06/18/TomcatServletBase/</url>
      
        <content type="html"><![CDATA[<h2 id="Web-相关概念"><a href="#Web-相关概念" class="headerlink" title="Web 相关概念"></a>Web 相关概念</h2><h3 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h3><ol><li>C/S：客户端/服务器端</li><li>B/S：浏览器/服务器端</li></ol><h3 id="资源分类"><a href="#资源分类" class="headerlink" title="资源分类"></a>资源分类</h3><ol><li>静态资源：所有用户访问后，得到的结果都是一样的，称为静态资源。静态资源可以直接被浏览器解析<ul><li>如： html,css,JavaScript</li></ul></li><li>动态资源：每个用户访问相同资源后，得到的结果可能不一样。称为动态资源。动态资源被访问后，需要先转换为静态资源，在返回给浏览器<ul><li>如：servlet/jsp,php,asp….</li></ul></li></ol><h2 id="Web-服务器软件"><a href="#Web-服务器软件" class="headerlink" title="Web 服务器软件"></a>Web 服务器软件</h2><p>常见的 java 相关的 web 服务器软件：</p><ul><li>webLogic：oracle 公司，大型的 JavaEE 服务器，支持所有的 JavaEE 规范，收费的。</li><li>webSphere：IBM 公司，大型的 JavaEE 服务器，支持所有的 JavaEE 规范，收费的。</li><li>JBOSS：JBOSS 公司的，大型的 JavaEE 服务器，支持所有的 JavaEE 规范，收费的。</li><li>Tomcat：Apache 基金组织，中小型的 JavaEE 服务器，仅仅支持少量的 JavaEE 规范 servlet/jsp。开源的，免费的。</li></ul><h4 id="JavaEE"><a href="#JavaEE" class="headerlink" title="JavaEE"></a>JavaEE</h4><p>Java 语言在企业级开发中使用的技术规范的总和，一共规定了 13 项大的规范</p><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><p>Web 服务器软件</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><a href="http://tomcat.apache.org/">http://tomcat.apache.org/</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>解压压缩包即可。  </p><blockquote><p>注意：安装目录建议不要有中文和空格</p></blockquote><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><ul><li>bin/startup.bat , 双击运行该文件即可</li><li>访问：浏览器输入：<a href="http://localhost:8080">http://localhost:8080</a></li></ul><h4 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h4><ol><li><p>黑窗口一闪而过：</p><ul><li>原因： 没有正确配置 JAVA_HOME 环境变量</li><li>解决方案：正确配置 JAVA_HOME 环境变量</li></ul></li><li><p>启动报错：</p><ol><li>暴力：找到占用的端口号，并且找到对应的进程，杀死该进程<ul><li><code>netstat -ano</code></li></ul></li><li>温柔：修改自身的端口号</li></ol><p><code>conf/server.xml</code></p></li></ol><pre class="language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Connector</span> <span class="token attr-name">port</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>8888<span class="token punctuation">"</span></span> <span class="token attr-name">protocol</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>HTTP/1.1<span class="token punctuation">"</span></span>    <span class="token attr-name">connectionTimeout</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>20000<span class="token punctuation">"</span></span>    <span class="token attr-name">redirectPort</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>8445<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre><h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><h4 id="正常关闭"><a href="#正常关闭" class="headerlink" title="正常关闭"></a>正常关闭</h4><ul><li>bin/shutdown.bat  </li><li>ctrl+c</li></ul><h4 id="强制关闭"><a href="#强制关闭" class="headerlink" title="强制关闭"></a>强制关闭</h4><p>点击启动窗口的×</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="部署项目的方式"><a href="#部署项目的方式" class="headerlink" title="部署项目的方式"></a>部署项目的方式</h4><ol><li><p>直接将项目放到 webapps 目录下即可。</p><ul><li>/hello：项目的访问路径–&gt;虚拟目录</li><li>简化部署：将项目打成一个 war 包，再将 war 包放置到 webapps 目录下。<ul><li>war 包会自动解压缩</li></ul></li></ul></li><li><p>配置 <code>conf/server.xml</code> 文件</p><p> 在 <code>&lt;Host&gt;</code> 标签体中配置</p><p><code>&lt;Context docBase=&quot;D:\hello&quot; path=&quot;/hehe&quot; /&gt;</code><br> *docBase: 项目存放的路径</p><ul><li>path：虚拟目录</li></ul></li><li><p>在 <code>conf\Catalina\localhost</code> 创建任意名称的 xml 文件。在文件中编写</p><p><code>&lt;Context docBase=&quot;D:\hello&quot; /&gt;</code></p><ul><li>虚拟目录：xml 文件的名称</li></ul></li></ol><h4 id="java-动态项目的目录结构"><a href="#java-动态项目的目录结构" class="headerlink" title="java 动态项目的目录结构"></a>java 动态项目的目录结构</h4><pre class="language-none"><code class="language-none">-- 项目的根目录    -- WEB-INF 目录：        -- web.xml：web 项目的核心配置文件        -- classes 目录：放置字节码文件的目录        -- lib 目录：放置依赖的 jar 包</code></pre><p><img src="/images/2020-06-18T221243.png" alt=""></p><h2 id="Servlet-Server-Applet"><a href="#Servlet-Server-Applet" class="headerlink" title="Servlet:  Server Applet"></a>Servlet:  Server Applet</h2><ul><li>概念：运行在服务器端的小程序</li><li>Servlet 就是一个接口，定义了 Java 类被浏览器访问到 (tomcat 识别）的规则。</li><li>将来我们自定义一个类，实现 Servlet 接口，复写方法。</li></ul><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><ol><li><p>创建 JavaEE 项目</p></li><li><p>定义一个类，实现 Servlet 接口  </p><p><code>public class ServletDemo1 implements Servlet</code></p></li><li><p>实现接口中的抽象方法</p></li><li><p>配置 Servlet  </p><p> 在 web.xml 中配置：</p></li></ol><pre class="language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--配置 Servlet --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>demo1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">></span></span>cn.itcast.web.servlet.ServletDemo1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>demo1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/demo1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">></span></span></code></pre><h3 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h3><ol><li>当服务器接受到客户端浏览器的请求后，会解析请求 URL 路径，获取访问的 Servlet 的资源路径</li><li>查找 web.xml 文件，是否有对应的 <code>&lt;url-pattern&gt;</code> 标签体内容。</li><li>如果有，则在找到对应的 <code>&lt;servlet-class&gt;</code> 全类名</li><li>tomcat 会将字节码文件加载进内存，并且创建其对象</li><li>调用其方法</li></ol><p><img src="/images/2020-06-18T223910.png" alt=""></p><h3 id="Servlet-生命周期"><a href="#Servlet-生命周期" class="headerlink" title="Servlet 生命周期"></a>Servlet 生命周期</h3><ol><li>被创建：执行 <code>init</code> 方法，只执行一次</li></ol><ul><li><p>Servlet 什么时候被创建？</p><ul><li>默认情况下，第一次被访问时，Servlet 被创建</li><li>可以配置执行 Servlet 的创建时机。<ul><li>在 <code>&lt;servlet&gt;</code> 标签下配置<ol><li>第一次被访问时，创建： <code>&lt;load-on-startup&gt;</code> 的值为负数</li><li>在服务器启动时，创建： <code>&lt;load-on-startup&gt;</code> 的值为 0 或正整数</li></ol></li></ul></li></ul></li><li><p>Servlet 的 <code>init</code> 方法，只执行一次，说明一个 Servlet 在内存中只存在一个对象，Servlet 是单例的</p><ul><li>多个用户同时访问时，可能存在线程安全问题。</li><li>解决：尽量不要在 Servlet 中定义成员变量。即使定义了成员变量，也不要对修改值</li></ul></li></ul><ol start="2"><li><p>提供服务：执行 <code>service</code> 方法，执行多次</p><ul><li>每次访问 Servlet 时，Service 方法都会被调用一次。</li></ul></li><li><p>被销毁：执行 <code>destroy</code> 方法，只执行一次</p><ul><li>Servlet 被销毁时执行。服务器关闭时，Servlet 被销毁</li><li>只有服务器正常关闭时，才会执行 destroy 方法。</li><li>destroy 方法在 Servlet 被销毁之前执行，一般用于释放资源</li></ul></li></ol><h3 id="Servlet-3-0"><a href="#Servlet-3-0" class="headerlink" title="Servlet 3.0"></a>Servlet 3.0</h3><p>支持注解配置。可以不需要 web.xml 了。</p><ol><li>创建 JavaEE 项目，选择 Servlet 的版本 3.0 以上，可以不创建 web.xml</li><li>定义一个类，实现 Servlet 接口</li><li>复写方法</li><li>在类上使用 <code>@WebServlet</code> 注解，进行配置</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@WebServlet</span><span class="token punctuation">(</span><span class="token string">"资源路径"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span>TYPE<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">WebServlet</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token comment">//相当于&lt;Servlet-name></span>    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//代表 urlPatterns() 属性配置</span>    <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">urlPatterns</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">//相当于&lt;url-pattern></span>    <span class="token keyword">int</span> <span class="token function">loadOnStartup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//相当于&lt;load-on-startup></span>    <span class="token class-name">WebInitParam</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">initParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">asyncSupported</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> <span class="token function">smallIcon</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> <span class="token function">largeIcon</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> <span class="token function">description</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> <span class="token function">displayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="2020/06/18/JDBC/"/>
      <url>2020/06/18/JDBC/</url>
      
        <content type="html"><![CDATA[<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Java DataBase Connectivity  Java 数据库连接， Java 语言操作数据库  </p><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>其实是官方（sun 公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动 jar 包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动 jar 包中的实现类。</p><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol><li>导入驱动 jar 包 mysql-connector-java-5.1.37-bin.jar<ol><li>复制 mysql-connector-java-5.1.37-bin.jar 到项目的 libs 目录下</li><li>右键–&gt;Add As Library</li></ol></li><li>注册驱动</li><li>获取数据库连接对象 Connection</li><li>定义 sql</li><li>获取执行 sql 语句的对象 Statement</li><li>执行 sql，接受返回结果</li><li>处理结果</li><li>释放资源</li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//1. 导入驱动 jar 包</span><span class="token comment">//2. 注册驱动</span><span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//3. 获取数据库连接对象</span><span class="token class-name">Connection</span> conn <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql://localhost:3306/db3"</span><span class="token punctuation">,</span> <span class="token string">"root"</span><span class="token punctuation">,</span> <span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//4. 定义 sql 语句</span><span class="token class-name">String</span> sql <span class="token operator">=</span> <span class="token string">"update account set balance = 500 where id = 1"</span><span class="token punctuation">;</span><span class="token comment">//5. 获取执行 sql 的对象 Statement</span><span class="token class-name">Statement</span> stmt <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//6. 执行 sql</span><span class="token keyword">int</span> count <span class="token operator">=</span> stmt<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//7. 处理结果</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//8. 释放资源</span>stmt<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>conn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="JDBC-各个对象"><a href="#JDBC-各个对象" class="headerlink" title="JDBC 各个对象"></a>JDBC 各个对象</h2><h3 id="DriverManager：驱动管理对象"><a href="#DriverManager：驱动管理对象" class="headerlink" title="DriverManager：驱动管理对象"></a>DriverManager：驱动管理对象</h3><ol><li>注册驱动：告诉程序该使用哪一个数据库驱动 jar  </li></ol><p><code>static void registerDriver(Driver driver)</code> : 注册与给定的驱动程序 DriverManager 。  </p><pre><code>写代码使用： `Class.forName(&quot;com.mysql.jdbc.Driver&quot;);`通过查看源码发现：在 `com.mysql.jdbc.Driver` 类中存在静态代码块</code></pre><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span><span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">registerDriver</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Driver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> <span class="token class-name">E</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"Can't register driver!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><pre><code>注意：mysql5 之后的驱动 jar 包可以省略注册驱动的步骤。</code></pre><ol start="2"><li>获取数据库连接：<ul><li>方法： <code>static Connection getConnection(String url, String user, String password)</code></li><li>参数：<ul><li>url：指定连接的路径<ul><li>语法：jdbc:mysql://ip 地址（域名）: 端口号/数据库名称</li><li>例子： <code>jdbc:mysql://localhost:3306/db3</code></li><li>细节：如果连接的是本机 mysql 服务器，并且 mysql 服务默认端口是 3306，则 url 可以简写为： <code>jdbc:mysql:///数据库名</code></li></ul></li><li>user：用户名</li><li>password：密码</li></ul></li></ul></li></ol><h3 id="Connection：数据库连接对象"><a href="#Connection：数据库连接对象" class="headerlink" title="Connection：数据库连接对象"></a>Connection：数据库连接对象</h3><ol><li>获取执行 sql 的对象<ul><li><code>Statement createStatement()</code></li><li><code>PreparedStatement prepareStatement(String sql)</code></li></ul></li><li>管理事务：<ul><li>开启事务： <code>setAutoCommit(boolean autoCommit)</code> ：调用该方法设置参数为 false，即开启事务</li><li>提交事务： <code>commit()</code></li><li>回滚事务： <code>rollback()</code></li></ul></li></ol><h3 id="Statement：执行-sql-的对象"><a href="#Statement：执行-sql-的对象" class="headerlink" title="Statement：执行 sql 的对象"></a>Statement：执行 sql 的对象</h3><ol><li>执行 sql<ol><li><code>boolean execute(String sql)</code> ：可以执行任意的 sql</li><li><code>int executeUpdate(String sql)</code> ：执行 DML（insert、update、delete）语句、DDL(create，alter、drop) 语句<ul><li>返回值：影响的行数，可以通过这个影响的行数判断 DML 语句是否执行成功 返回值&gt;0 的则执行成功，反之，则失败。</li></ul></li><li><code>ResultSet executeQuery(String sql)</code> ：执行 DQL（select) 语句</li></ol></li><li>练习：<ol><li>account 表 添加一条记录</li><li>account 表 修改记录</li><li>account 表 删除一条记录</li></ol></li></ol><pre class="language-java" data-language="java"><code class="language-java"><span class="token class-name">Statement</span> stmt <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token class-name">Connection</span> conn <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//1. 注册驱动</span>    <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.jdbc.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//2. 定义 sql</span>    <span class="token class-name">String</span> sql <span class="token operator">=</span> <span class="token string">"insert into account values(null,'王五',3000)"</span><span class="token punctuation">;</span>    <span class="token comment">//3. 获取 Connection 对象</span>    conn <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql:///db3"</span><span class="token punctuation">,</span> <span class="token string">"root"</span><span class="token punctuation">,</span> <span class="token string">"root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//4. 获取执行 sql 的对象 Statement</span>    stmt <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//5. 执行 sql</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> stmt<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//影响的行数</span>    <span class="token comment">//6. 处理结果</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"添加成功！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"添加失败！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//stmt.close();</span>    <span class="token comment">//7. 释放资源</span>    <span class="token comment">//避免空指针异常</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>stmt <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            stmt<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>conn <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            conn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="ResultSet：结果集对象，封装查询结果"><a href="#ResultSet：结果集对象，封装查询结果" class="headerlink" title="ResultSet：结果集对象，封装查询结果"></a>ResultSet：结果集对象，封装查询结果</h3><p><code>boolean next()</code> : 游标向下移动一行，判断当前行是否是最后一行末尾（是否有数据），如果是，则返回 false，如果不是则返回 true<br><code>getXxx（参数）</code> : 获取数据</p><ul><li>Xxx：代表数据类型   如： <code>int getInt()</code> , <code>String getString()</code></li><li>参数：<ol><li>int：代表列的编号，从 1 开始   如： <code>getString(1)</code></li><li>String：代表列名称。 如： <code>getDouble(&quot;balance&quot;)</code></li></ol></li><li>使用步骤：<ol><li>游标向下移动一行</li><li>判断是否有数据</li><li>获取数据</li></ol></li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">//循环判断游标是否是最后一行末尾。</span><span class="token keyword">while</span><span class="token punctuation">(</span>rs<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//获取数据</span>    <span class="token comment">//6.2 获取数据</span>    <span class="token keyword">int</span> id <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">String</span> name <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> balance <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getDouble</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>id <span class="token operator">+</span> <span class="token string">"---"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">"---"</span> <span class="token operator">+</span> balance<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="PreparedStatement：执行-sql-的对象"><a href="#PreparedStatement：执行-sql-的对象" class="headerlink" title="PreparedStatement：执行 sql 的对象"></a>PreparedStatement：执行 sql 的对象</h3><h4 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h4><p>在拼接 sql 时，有一些 sql 的特殊关键字参与字符串的拼接。会造成安全性问题</p><ol><li>输入用户随便，输入密码：a’ or ‘a’ = ‘a</li><li>sql： <code>select * from user where username = &#39;fhdsjkf&#39; and password = &#39;a&#39; or &#39;a&#39; = &#39;a&#39;</code></li></ol><h4 id="解决-sql-注入"><a href="#解决-sql-注入" class="headerlink" title="解决 sql 注入"></a>解决 sql 注入</h4><p>使用 PreparedStatement 对象来解决<br>预编译的 SQL：参数使用 ？作为占位符  </p><ul><li>步骤：</li></ul><ol><li>导入驱动 jar 包 mysql-connector-java-5.1.37-bin.jar</li><li>注册驱动</li><li>获取数据库连接对象 Connection</li><li>定义 sql<ul><li>注意：sql 的参数使用？作为占位符。 如： <code>select * from user where username = ? and password = ?;</code></li></ul></li><li>获取执行 sql 语句的对象 <code>PreparedStatement  Connection.prepareStatement(String sql)</code></li><li>给？赋值：<ul><li>方法： setXxx（参数 1, 参数 2)<ul><li>参数 1：？的位置编号 从 1 开始</li><li>参数 2：？的值</li></ul></li></ul></li><li>执行 sql，接受返回结果，不需要传递 sql 语句</li><li>处理结果</li><li>释放资源</li></ol><p>注意：后期都会使用 PreparedStatement 来完成增删改查的所有操作</p><ol><li>可以防止 SQL 注入</li><li>效率更高</li></ol><h2 id="JDBC-事务"><a href="#JDBC-事务" class="headerlink" title="JDBC 事务"></a>JDBC 事务</h2><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。  </p><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><ol><li>开启事务</li><li>提交事务</li><li>回滚事务</li></ol><h4 id="使用-Connection-对象来管理事务"><a href="#使用-Connection-对象来管理事务" class="headerlink" title="使用 Connection 对象来管理事务"></a>使用 Connection 对象来管理事务</h4><ul><li>开启事务： <code>setAutoCommit(boolean autoCommit)</code> ：调用该方法设置参数为 false，即开启事务<ul><li>在执行 sql 之前开启事务</li></ul></li><li>提交事务： <code>commit()</code><ul><li>当所有 sql 都执行完提交事务</li></ul></li><li>回滚事务： <code>rollback()</code><ul><li>在 catch 中回滚事务</li></ul></li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JDBCDemo10</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Connection</span> conn <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">PreparedStatement</span> pstmt1 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">PreparedStatement</span> pstmt2 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//1. 获取连接</span>            conn <span class="token operator">=</span> <span class="token class-name">JDBCUtils</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//开启事务</span>            conn<span class="token punctuation">.</span><span class="token function">setAutoCommit</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//2. 定义 sql</span>            <span class="token comment">//2.1 张三 - 500</span>            <span class="token class-name">String</span> sql1 <span class="token operator">=</span> <span class="token string">"update account set balance = balance - ? where id = ?"</span><span class="token punctuation">;</span>            <span class="token comment">//2.2 李四 + 500</span>            <span class="token class-name">String</span> sql2 <span class="token operator">=</span> <span class="token string">"update account set balance = balance + ? where id = ?"</span><span class="token punctuation">;</span>            <span class="token comment">//3. 获取执行 sql 对象</span>            pstmt1 <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql1<span class="token punctuation">)</span><span class="token punctuation">;</span>            pstmt2 <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>sql2<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//4. 设置参数</span>            pstmt1<span class="token punctuation">.</span><span class="token function">setDouble</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pstmt1<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pstmt2<span class="token punctuation">.</span><span class="token function">setDouble</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pstmt2<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//5. 执行 sql</span>            pstmt1<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 手动制造异常</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span>            pstmt2<span class="token punctuation">.</span><span class="token function">executeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//提交事务</span>            conn<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//事务回滚</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>conn <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    conn<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                e1<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">JDBCUtils</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span>pstmt1<span class="token punctuation">,</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">JDBCUtils</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span>pstmt2<span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库范式</title>
      <link href="2020/06/17/SQLNormalForm/"/>
      <url>2020/06/17/SQLNormalForm/</url>
      
        <content type="html"><![CDATA[<h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><h3 id="函数依赖-1"><a href="#函数依赖-1" class="headerlink" title="函数依赖"></a>函数依赖</h3><p>A–&gt;B, 如果通过 A 属性（属性组）的值，可以确定唯一 B 属性的值。则称 B 依赖于 A  </p><blockquote><p>例如：学号–&gt;姓名。  （学号，课程名称） –&gt; 分数</p></blockquote><h3 id="完全函数依赖"><a href="#完全函数依赖" class="headerlink" title="完全函数依赖"></a>完全函数依赖</h3><p>A–&gt;B， 如果 A 是一个属性组，则 B 属性值得确定需要依赖于 A 属性组中所有的属性值。  </p><blockquote><p>例如：（学号，课程名称） –&gt; 分数</p></blockquote><h3 id="部分函数依赖"><a href="#部分函数依赖" class="headerlink" title="部分函数依赖"></a>部分函数依赖</h3><p>A–&gt;B， 如果 A 是一个属性组，则 B 属性值得确定只需要依赖于 A 属性组中某一些值即可。  </p><blockquote><p>例如：（学号，课程名称） – &gt; 姓名</p></blockquote><h3 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h3><p>A–&gt;B, B – &gt;C . 如果通过 A 属性（属性组）的值，可以确定唯一 B 属性的值，在通过 B 属性（属性组）的值可以确定唯一 C 属性的值，则称 C 传递函数依赖于 A  </p><blockquote><p>例如：学号–&gt;系名，系名–&gt;系主任</p></blockquote><h3 id="码"><a href="#码" class="headerlink" title="码"></a>码</h3><p>如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性（属性组）为该表的码</p><blockquote><p>例如：该表中码为：（学号，课程名称）</p></blockquote><ul><li>主属性：码属性组中的所有属性</li><li>非主属性：除过码属性组的属性</li></ul><h2 id="什么是范式"><a href="#什么是范式" class="headerlink" title="什么是范式"></a>什么是范式</h2><p>好的数据库设计对数据的存储性能和后期的程序开发，都会产生重要的影响。建立科学的，规范的数据库就需要满足一些规则来优化数据的设计和存储，这些规则就称为范式。</p><h2 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h2><p>目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式 (4NF）和第五范式（5NF，又称完美范式）。<br>满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以次类推。一般说来，数据库只需满足第三范式 (3NF）就行了。</p><h3 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h3><p>第一范式（1NF）：数据库表的每一列都是不可分割的原子数据项，不能是集合、数组等非原子数据项。即表中的某个列有多个值时，必须拆分为不同的列。简而言之，第一范式每一列不可再拆分，称为原子性。</p><table><thead><tr><th>学号</th><th>姓名</th><th>班级</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>一年三班</td></tr><tr><td>2</td><td>李四</td><td>一年二班</td></tr><tr><td>3</td><td>王五</td><td>二年三班</td></tr></tbody></table><h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h3><p>第二范式（2NF）：在满足第一范式的前提下，表中的每一个字段都完全依赖于主键。<br>所谓完全依赖是指不能存在仅依赖主键一部分的列。简而言之，第二范式就是在第一范式的基础上所有列完全依赖于主键列。当存在一个复合主键包含多个主键列的时候，才会发生不符合第二范式的情况。比如有一个主键有两个列，不能存在这样的属性，它只依赖于其中一个列，这就是不符合第二范式。</p><ul><li>第二范式的特点：</li></ul><ol><li>一张表只描述一件事情。</li><li>表中的每一列都完全依赖于主键</li></ol><ul><li><p>不符合 2NF:  </p><table><thead><tr><th><font color="red">学生证号</font></th><th>学生证名称</th><th>学生证办理时间</th><th><font color="red">借书证号</font></th><th>借书证名称</th><th>借书证办理时间</th></tr></thead></table></li><li><p>符合 2NF，分成两张表：</p><table><thead><tr><th><font color="red">学生证号</font></th><th>学生证名称</th><th>学生证办理时间</th></tr></thead></table><table><thead><tr><th><font color="red">借书证号</font></th><th>借书证名称</th><th>借书证办理时间</th></tr></thead></table></li></ul><h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h3><p>第三范式（3NF）：在满足第二范式的前提下，表中的每一列都直接依赖于主键，而不是通过其它的列来间接依赖于主键。<br>简而言之，第三范式就是所有列不依赖于其它非主键列，也就是在满足 2NF 的基础上，任何非主列不得传递依赖于主键。所谓传递依赖，指的是如果存在”A-&gt;B-&gt;C”的决定关系，则 C 传递依赖于 A。因此，满足第三范式的数据库表应该不存在如下依赖关系：主键列 -&gt; 非主键列 x -&gt; 非主键列 y  </p><ul><li><p>不符合 3NF:  </p><table><thead><tr><th><font color="red">学号</font></th><th>姓名</th><th>年龄</th><th><font color="red">所在学院</font></th><th><font color="blue">学院地点</font></th></tr></thead></table><p>  存在传递的决定关系：<br>  学号-&gt;所在学院-&gt;学院地点</p></li><li><p>符合 3NF，分成两张表：  </p><table><thead><tr><th><font color="red">学号</font></th><th>姓名</th><th>年龄</th><th><font color="darkblue">所在学院的编号（外键）</font></th></tr></thead></table><table><thead><tr><th><font color="red">学院编号</font></th><th>所在学院</th><th>学院地点</th></tr></thead></table></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th>范式</th><th>特点</th></tr></thead><tbody><tr><td>1NF</td><td>原子性：表中每列不可再拆分。</td></tr><tr><td>2NF</td><td>不产生局部依赖，一张表只描述一件事情</td></tr><tr><td>3NF</td><td>不产生传递依赖，表中每一列都直接依赖于主键。而不是通过其它列间接依赖于主键。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA 反射与注解</title>
      <link href="2020/06/12/JSPBase/"/>
      <url>2020/06/12/JSPBase/</url>
      
        <content type="html"><![CDATA[<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>框架：半成品软件。可以在框架的基础上进行软件开发，简化编码<br>反射：将类的各个组成部分封装为其他对象<br>使用反射的好处：  </p><ol><li>可以在程序运行过程中，操作这些对象。</li><li>可以解耦，提高程序的可扩展性。</li></ol><h3 id="获取-Class-对象的方式"><a href="#获取-Class-对象的方式" class="headerlink" title="获取 Class 对象的方式"></a>获取 Class 对象的方式</h3><ol><li><code>Class.forName(&quot;全类名&quot;)</code> ：将字节码文件加载进内存，返回 Class 对象<ul><li>多用于配置文件，将类名定义在配置文件中。读取文件，加载类</li></ul></li><li><code>类名。class</code> ：通过类名的属性 class 获取<ul><li>多用于参数的传递</li></ul></li><li><code>对象。getClass()</code> ：getClass() 方法在 Object 类中定义。<ul><li>多用于对象的获取字节码的方式  </li></ul></li></ol><p>结论：<br>同一个字节码文件 (*.class) 在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的 Class 对象都是同一个。  </p><h3 id="Class-对象功能"><a href="#Class-对象功能" class="headerlink" title="Class 对象功能"></a>Class 对象功能</h3><ul><li><p>获取功能：  </p><ol><li><p>获取成员变量</p><ul><li><code>Field[] getFields()</code> 获取所有 public 修饰的成员变量</li><li><code>Field getField(String name)</code> 获取指定名称的 public 修饰的成员变量</li><li><code>Field[] getDeclaredFields()</code> 获取所有的成员变量，不考虑修饰符</li><li><code>Field getDeclaredField(String name)</code></li></ul></li><li><p>获取构造方法</p><ul><li><code>Constructor&lt;?&gt;[] getConstructors()</code></li><li><code>Constructor&lt;T&gt; getConstructor（类&lt;?&gt;... parameterTypes)</code></li><li><code>Constructor&lt;T&gt; getDeclaredConstructor（类&lt;?&gt;... parameterTypes)</code></li><li><code>Constructor&lt;?&gt;[] getDeclaredConstructors()</code></li></ul></li><li><p>获取成员方法</p><ul><li><code>Method[] getMethods()</code></li><li><code>Method getMethod(String name, 类&lt;?&gt;... parameterTypes)</code></li><li><code>Method[] getDeclaredMethods()</code></li><li><code>Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes)</code></li></ul></li><li><p>获取全类名  </p><ul><li><code>String getName()</code></li></ul></li></ol></li><li><p>Field：成员变量  </p></li><li><p>操作：</p><ol><li><p>设置值  </p><ul><li><code>void set(Object obj, Object value)</code></li></ul></li><li><p>获取值  </p><ul><li><code>get(Object obj)</code></li></ul></li><li><p>忽略访问权限修饰符的安全检查  </p><ul><li><code>setAccessible(true)</code> : 暴力反射</li></ul></li></ol></li><li><p>Constructor: 构造方法  </p></li><li><p>创建对象：</p><ul><li><code>T newInstance(Object... initargs)</code></li><li>如果使用空参数构造方法创建对象，操作可以简化：Class 对象的 <code>newInstance</code> 方法  </li></ul></li><li><p>Method：方法对象  </p></li><li><p>执行方法：  </p><ul><li><code>Object invoke(Object obj, Object... args)</code></li></ul></li><li><p>获取方法名称：</p><ul><li><code>String getName</code> : 获取方法名</li></ul></li></ul><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>注解：说明程序的。给计算机看的<br>注释：用文字描述程序的。给程序员看的  </p><blockquote><p>定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是 JDK1.5 及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。</p></blockquote><ul><li><p>概念描述：</p><ul><li>JDK1.5 之后的新特性</li><li>说明程序的</li><li>使用注解：@注解名称</li></ul></li><li><p>作用分类：  </p><ol><li>编写文档：通过代码里标识的注解生成文档【生成文档 doc 文档】</li><li>代码分析：通过代码里标识的注解对代码进行分析【使用反射】</li><li>编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】</li></ol></li><li><p>JDK 中预定义的一些注解</p><ul><li><code>@Override</code> ：检测被该注解标注的方法是否是继承自父类（接口）的</li><li><code>@Deprecated</code> ：该注解标注的内容，表示已过时</li><li><code>@SuppressWarnings</code> ：压制警告<ul><li>一般传递参数 all <code>@SuppressWarnings(&quot;all&quot;)</code></li></ul></li></ul></li></ul><ul><li>自定义注解格式：</li></ul><pre class="language-java" data-language="java"><code class="language-java">元注解<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> 注解名称<span class="token punctuation">&#123;</span>属性列表；<span class="token punctuation">&#125;</span></code></pre><ul><li>本质：注解本质上就是一个接口，该接口默认继承 Annotation 接口  </li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">MyAnno</span> <span class="token keyword">extends</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span><span class="token class-name">Annotation</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></code></pre><ul><li><p>属性：接口中的抽象方法</p><ul><li><p>要求：</p><ol><li><p>属性的返回值类型有下列取值</p><ul><li>基本数据类型</li><li>String</li><li>枚举</li><li>注解</li><li>以上类型的数组</li></ul></li><li><p>定义了属性，在使用时需要给属性赋值</p><ol><li>如果定义属性时，使用 default 关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。</li><li>如果只有一个属性需要赋值，并且属性的名称是 value，则 value 可以省略，直接定义值即可。</li><li>数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略</li></ol></li></ol></li></ul></li><li><p>元注解：用于描述注解的注解</p><ul><li><code>@Target</code> ：描述注解能够作用的位置</li><li>ElementType 取值：<ul><li><code>TYPE</code> ：可以作用于类上</li><li><code>METHOD</code> ：可以作用于方法上</li><li><code>FIELD</code> ：可以作用于成员变量上</li></ul></li><li><code>@Retention</code> ：描述注解被保留的阶段</li><li><code>@Retention(RetentionPolicy. RUNTIME)</code> ：当前被描述的注解，会保留到 class 字节码文件中，并被 JVM 读取到</li><li><code>@Documented</code> ：描述注解是否被抽取到 api 文档中</li><li><code>@Inherited</code> ：描述注解是否被子类继承</li></ul></li><li><p>在程序使用（解析）注解：获取注解中定义的属性值</p><ol><li>获取注解定义的位置的对象  （Class,Method,Field）</li><li>获取指定的注解</li></ol><ul><li><code>getAnnotation(Class)</code><br>//其实就是在内存中生成了一个该注解接口的子类实现对象</li></ul></li></ul><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Pro</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">className</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">"cn.itcast.annotation.Demo1"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">methodName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">"show"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><ol start="3"><li>调用注解中的抽象方法获取配置的属性值</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaBean</title>
      <link href="2020/06/09/JavaBean/"/>
      <url>2020/06/09/JavaBean/</url>
      
        <content type="html"><![CDATA[<p>JavaBean 是 Java 语言编写类的一种标准规范。符合 JavaBean 的类，要求类必须是具体的和公共的，并且具有无参数的构造方法，提供用来操作成员变量的 set 和 get 方法。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassName</span><span class="token punctuation">&#123;</span>  <span class="token comment">//成员变量</span>  <span class="token comment">//构造方法</span>  <span class="token comment">//无参构造方法【必须】</span>  <span class="token comment">//有参构造方法【建议】</span>  <span class="token comment">//成员方法</span>  <span class="token comment">//getXxx()</span>  <span class="token comment">//setXxx()</span><span class="token punctuation">&#125;</span></code></pre><p>编写符合 JavaBean 规范的类，以学生类为例，标准代码如下：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//成员变量</span>  <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>  <span class="token comment">//构造方法</span>  <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">//成员方法</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> name<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> age<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>测试类，代码如下：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestStudent</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//无参构造使用</span>  <span class="token class-name">Student</span> s<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  s<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"柳岩"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  s<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"‐‐‐"</span><span class="token operator">+</span>s<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//带参构造使用</span>  <span class="token class-name">Student</span> s2<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">"赵丽颖"</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"‐‐‐"</span><span class="token operator">+</span>s2<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Safari 使用 Opus 编码</title>
      <link href="2020/05/25/ProvideCAFForSAfari/"/>
      <url>2020/05/25/ProvideCAFForSAfari/</url>
      
        <content type="html"><![CDATA[<h2 id="Vorbis-与-Opus-编码"><a href="#Vorbis-与-Opus-编码" class="headerlink" title="Vorbis 与 Opus 编码"></a>Vorbis 与 Opus 编码</h2><p>摘自 Wikipedia:</p><h3 id="Vorbis"><a href="#Vorbis" class="headerlink" title="Vorbis"></a>Vorbis</h3><blockquote><p>Vorbis 是一種有損音訊壓縮格式，由 Xiph. Org 基金會所領導並開放原始碼的一個免費的開源軟件項目。該項目為有損音頻壓縮產生音頻編碼格式和軟件參考編碼器╱解碼器（編解碼器）。Vorbis 通常以 Ogg 作為容器格式，所以常合稱為 Ogg Vorbis。  </p></blockquote><p>Vorbis 是 1993 年由克里斯·蒙哥馬利開始的音頻壓縮開發的延續。1998 年 9 月，夫朗和斐協會宣布計劃收取 MP3 音頻格式的專利許可費用，该事件触发了 Vorbis 的密集开发 。Vorbis 項目是 Xiphophorus 公司的 Ogg 項目（也稱為 OggSquish 多媒體項目）的一部分。克里斯·蒙哥馬利開始了這個項目的工作，並得到越來越多的其他開發者的幫助。他們繼續改進源代碼，直到 Vorbis 文件格式在 2000 年 5 月被凍結為 1.0。原來授權為 LGPL，2001 年，Vorbis 許可證被更改為 BSD 許可證，以鼓勵採納，理查德·斯托曼參考軟件的穩定版本（1.0）於 2002 年 7 月 19 日發布 。<br>Xiph. Org 基金會維護一個參考實現編解碼器 libvorbis。還有一些微調的分支，最引人注目的是 aoTuV，提供更好的音頻質量，特別是在低比特率。這些改進會定期地合併回參考代碼庫。<br>目前 Xiph. Org 基金會建議使用延遲更低、音質更好的 Opus 編碼來取代 Vorbis。</p><h3 id="Opus"><a href="#Opus" class="headerlink" title="Opus"></a>Opus</h3><blockquote><p>Opus 是一個有損聲音編碼的格式，由 Xiph. Org 基金會開發，之後由網際網路工程任務組進行標準化，目標是希望用單一格式包含聲音和語音，取代 Speex 和 Vorbis，且適用於網路上低延遲的即時聲音傳輸，標準格式定義於 RFC 6716 文件。Opus 格式是一個開放格式，使用上沒有任何專利或限制。  </p></blockquote><p>Opus 整合了兩種聲音編碼的技術：以語音編碼為導向的 SILK 和低延遲的 CELT。Opus 可以无缝调节高低比特率。在编码器内部它在较低比特率时使用线性预测编码在高比特率时候使用变换编码（在高低比特率交界处也使用两者结合的编码方式）。Opus 具有非常低的演算法延遲（預設為 22.5 ms），非常適合用於低延遲語音通話的編碼，像是網路上的即時聲音串流、即時同步聲音旁白等等，此外 Opus 也可以透過降低編碼位元率，達成更低的演算法延遲，最低可以到 5 ms。在多個聽覺盲測中，Opus 都比 MP3、AAC、HE-AAC 等常見格式，有更低的延遲和更好的聲音壓縮率。</p><h2 id="Vorbis-与-Opus-的浏览器支持情况"><a href="#Vorbis-与-Opus-的浏览器支持情况" class="headerlink" title="Vorbis 与 Opus 的浏览器支持情况"></a>Vorbis 与 Opus 的浏览器支持情况</h2><p><img src="/images/pasted-5.png" alt="Vorbis"></p><p><img src="/images/pasted-6.jpg" alt="Opus"></p><p>音频编码 Opus 与 Vorbis 中，Safari 完全不支持 Vorbis 编码，支持 CAF 封装的 Opus 编码文件。<br>但 CAF(Core Audio Format) 是苹果的专有格式，其他浏览器并不支持。因此，想要在网页中使用 Opus 编码，需要同时准备两份文件，一份 CAF 封装，一份 Ogg 封装（.ogg 或者 .opus）。</p><h2 id="转换-Opus-格式"><a href="#转换-Opus-格式" class="headerlink" title="转换 Opus 格式"></a>转换 Opus 格式</h2><p>用 FFmpeg 可以很方便的转换 Opus 到 CAF：<br> <code>FOR %%a IN (.\*.opus) DO (&quot;ffmpeg&quot; -i &quot;%%a&quot; -c:a copy &quot;%%a.caf&quot;)</code></p><p>保存成批处理可以将当前文件夹下的所有 Opus 文件生成一份 caf 封装的副本。</p><h2 id="使用-Nginx-分流提供不同格式文件"><a href="#使用-Nginx-分流提供不同格式文件" class="headerlink" title="使用 Nginx 分流提供不同格式文件"></a>使用 Nginx 分流提供不同格式文件</h2><p>这样做的好处是不需要修改前端代码，代码中统一使用 Opus 或者 Ogg 格式，但 Nginx 会根据不同的浏览器返回不同文件。<br>利用 Nginx 的内置变量和 URL 重写功能，对请求的 UserAgent 进行判断，符合条件的请求会被重写。<br>因为 Nginx 不支持在一个条件中判断多个表达式和 if 语句的嵌套，只能利用自定义变量实现多条件判断。<br>对于 Safari 浏览器，如果接收的文件不是以 .caf 结尾，则必须正确指定 Content-Type 才能播放。<br>另外，对于这种改写方法，由于请求地址是一样的，必须要在 Cache-Control 中指定为 private，否则 CDN 可能缓存错误的文件，导致浏览器无法播放。</p><pre class="language-nginx" data-language="nginx"><code class="language-nginx"><span class="token keyword">location</span> <span class="token operator">/</span>media<span class="token operator">/</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">root</span>   <span class="token operator">/</span>srv<span class="token operator">/</span>nginx<span class="token operator">/</span>hexo_media<span class="token operator">/</span><span class="token punctuation">;</span>    <span class="token keyword">add_header</span> Cache<span class="token operator">-</span>Control <span class="token string">"private, max-age=31536000"</span><span class="token punctuation">;</span>    <span class="token keyword">types</span> <span class="token punctuation">&#123;</span>        audio<span class="token operator">/</span>x<span class="token operator">-</span>caf  caf<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">set</span> <span class="token variable">$flag</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token variable">$http_user_agent</span> <span class="token operator">!</span><span class="token operator">~</span><span class="token operator">*</span> Chrome <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">set</span> <span class="token variable">$flag</span> <span class="token string">"$&#123;flag&#125;NotChrome"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token variable">$http_user_agent</span> <span class="token operator">~</span><span class="token operator">*</span> Safari <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">set</span> <span class="token variable">$flag</span> <span class="token string">"$&#123;flag&#125;IsSafari"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token variable">$uri</span> <span class="token operator">~</span><span class="token operator">*</span> \<span class="token punctuation">.</span>opus$ <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">set</span> <span class="token variable">$flag</span> <span class="token string">"$&#123;flag&#125;Opus"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token variable">$uri</span> <span class="token operator">~</span><span class="token operator">*</span> \<span class="token punctuation">.</span>ogg$ <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">set</span> <span class="token variable">$flag</span> <span class="token string">"$&#123;flag&#125;Ogg"</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token variable">$flag</span> <span class="token operator">=</span> <span class="token string">"NotChromeIsSafariOpus"</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">rewrite</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">)</span>\<span class="token punctuation">.</span>opus$ $<span class="token number">1.</span>opus<span class="token punctuation">.</span>caf<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token variable">$flag</span> <span class="token operator">=</span> <span class="token string">"NotChromeIsSafariOgg"</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">rewrite</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">)</span>\<span class="token punctuation">.</span>ogg$ $<span class="token number">1.</span>opus<span class="token punctuation">.</span>caf<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Ops </category>
          
          <category> Codec </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> Vorbis </tag>
            
            <tag> Opus </tag>
            
            <tag> ffmpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx 1.19.6 with HTTP/3 编译记录</title>
      <link href="2020/05/09/Nginx-1-18-compile/"/>
      <url>2020/05/09/Nginx-1-18-compile/</url>
      
        <content type="html"><![CDATA[<h2 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h2><p><img src="/images/pasted-1.png" alt="Ubuntu 18.04"></p><p><img src="/images/1598284747746.png" alt="CentOS 8.2"></p><h2 id="安装必要软件包"><a href="#安装必要软件包" class="headerlink" title="安装必要软件包"></a>安装必要软件包</h2><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt</span> <span class="token function">install</span> build-essential cmake golang cargo mmdb-bin libmaxminddb-dev libxml2 libxslt-dev libatomic-ops-dev libunwind-dev libpcre3 libpcre3-dev</code></pre><pre class="language-bash" data-language="bash"><code class="language-bash">dnf <span class="token function">install</span> cmake gcc gcc-c++ golang cargo libmaxminddb-devel libxml2-devel libxslt-devel libunwind-devel pcre-devel libatomic_ops-devel</code></pre><h2 id="拉取-Nginx-和相关模块源码"><a href="#拉取-Nginx-和相关模块源码" class="headerlink" title="拉取 Nginx 和相关模块源码"></a>拉取 Nginx 和相关模块源码</h2><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /home<span class="token function">wget</span> https://nginx.org/download/nginx-1.19.6.tar.gz<span class="token function">wget</span> https://github.com/openresty/lua-nginx-module/archive/v0.10.19.tar.gz<span class="token function">wget</span> https://github.com/openresty/luajit2/archive/v2.1-20201229.tar.gz<span class="token function">wget</span> https://github.com/openresty/lua-resty-core/archive/v0.1.21.tar.gz<span class="token function">wget</span> https://github.com/openresty/lua-resty-lrucache/archive/v0.10.tar.gz<span class="token function">git</span> clone --recursive https://github.com/cloudflare/quiche<span class="token comment"># git clone https://github.com/kn007/patch.git</span><span class="token function">git</span> clone https://github.com/cloudflare/zlib.git<span class="token function">git</span> clone https://github.com/google/ngx_brotli.git<span class="token function">git</span> clone https://github.com/openresty/headers-more-nginx-module.git<span class="token function">git</span> clone https://github.com/vision5/ngx_devel_kit.git<span class="token function">git</span> clone https://github.com/leev/ngx_http_geoip2_module.git<span class="token function">git</span> clone https://github.com/aperezdc/ngx-fancyindex.git<span class="token function">git</span> clone https://github.com/arut/nginx-dav-ext-module.git<span class="token function">git</span> clone https://github.com/yaoweibin/ngx_http_substitutions_filter_module.git<span class="token builtin class-name">cd</span> ngx_brotli<span class="token function">git</span> submodule update --init</code></pre><h2 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h2><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /home<span class="token function">tar</span> -xvf nginx-1.19.6.tar.gz<span class="token function">tar</span> -xvf lua-nginx-module-0.10.19.tar.gz<span class="token function">tar</span> -xvf luajit2-2.1-20201229.tar.gz<span class="token function">tar</span> -xvf lua-resty-core-0.1.21.tar.gz<span class="token function">tar</span> -xvf lua-resty-lrucache-0.10.tar.gz</code></pre><h2 id="编译-LUAJIT2"><a href="#编译-LUAJIT2" class="headerlink" title="编译 LUAJIT2"></a>编译 LUAJIT2</h2><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /home/luajit2-2.1-20201229<span class="token function">make</span> -j4<span class="token function">make</span> <span class="token function">install</span><span class="token builtin class-name">cd</span> /home/lua-resty-lrucache-0.10<span class="token function">make</span> -j4<span class="token function">make</span> <span class="token function">install</span><span class="token builtin class-name">cd</span> /home/lua-resty-core-0.1.21<span class="token function">make</span> -j4<span class="token function">make</span> <span class="token function">install</span><span class="token function">rm</span> -rf /usr/local/share/lua/5.1<span class="token function">ln</span> -s /usr/local/lib/lua /usr/local/share/lua/5.1<span class="token builtin class-name">export</span> <span class="token assign-left variable">LUAJIT_INC</span><span class="token operator">=</span>/usr/local/include/luajit-2.1<span class="token builtin class-name">export</span> <span class="token assign-left variable">LUAJIT_LIB</span><span class="token operator">=</span>/usr/local/lib/</code></pre><h2 id="zlib-要清除之前的编译"><a href="#zlib-要清除之前的编译" class="headerlink" title="zlib 要清除之前的编译"></a>zlib 要清除之前的编译</h2><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /root/zlib<span class="token function">make</span> -f Makefile.in distclean</code></pre><h2 id="编译-Nginx"><a href="#编译-Nginx" class="headerlink" title="编译 Nginx"></a>编译 Nginx</h2><p>先给 Nginx 打支持 HTTP/3 的补丁</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /root/nginx-1.19.6patch -p1 <span class="token operator">&lt;</span> <span class="token punctuation">..</span>/quiche/extras/nginx/nginx-1.16.patch<span class="token comment"># patch -p1 &lt; ../patch/nginx_with_quic.patch</span><span class="token comment"># patch -p1 &lt; ../patch/Enable_BoringSSL_OCSP.patch</span></code></pre><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /root/nginx-1.19.6./configure --add-module<span class="token operator">=</span><span class="token punctuation">..</span>/ngx_brotli --with-openssl<span class="token operator">=</span><span class="token punctuation">..</span>/quiche/deps/boringssl --with-quiche<span class="token operator">=</span><span class="token punctuation">..</span>/quiche --with-http_v2_module --with-http_v3_module --with-http_ssl_module --with-http_gzip_static_module --with-http_realip_module --with-threads --with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module --with-zlib<span class="token operator">=</span><span class="token punctuation">..</span>/zlib --add-module<span class="token operator">=</span><span class="token punctuation">..</span>/ngx_devel_kit --add-module<span class="token operator">=</span><span class="token punctuation">..</span>/headers-more-nginx-module --add-module<span class="token operator">=</span><span class="token punctuation">..</span>/lua-nginx-module-0.10.19 --with-file-aio --add-module<span class="token operator">=</span><span class="token punctuation">..</span>/ngx_http_geoip2_module --add-module<span class="token operator">=</span><span class="token punctuation">..</span>/ngx-fancyindex --add-module<span class="token operator">=</span><span class="token punctuation">..</span>/nginx-dav-ext-module --add-module<span class="token operator">=</span><span class="token punctuation">..</span>/ngx_http_substitutions_filter_module --with-libatomic --with-http_dav_module --with-http_stub_status_module <span class="token function">make</span> -j4<span class="token function">make</span> <span class="token function">install</span></code></pre><h2 id="配置动态链接库"><a href="#配置动态链接库" class="headerlink" title="配置动态链接库"></a>配置动态链接库</h2><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/ld.so.conf.d/libc.conf</code></pre><p>添加以下内容：</p><pre class="language-conf" data-language="conf"><code class="language-conf"># libc default configuration&#x2F;usr&#x2F;local&#x2F;lib</code></pre><p>刷新链接缓存：</p><pre class="language-bash" data-language="bash"><code class="language-bash">ldconfig</code></pre><h2 id="添加-Nginx-到系统服务"><a href="#添加-Nginx-到系统服务" class="headerlink" title="添加 Nginx 到系统服务"></a>添加 Nginx 到系统服务</h2><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /lib/systemd/system/nginx.service</code></pre><p>添加以下内容：</p><pre class="language-ini" data-language="ini"><code class="language-ini"><span class="token comment"># Stop dance for nginx</span><span class="token comment"># =======================</span><span class="token comment">#</span><span class="token comment"># ExecStop sends SIGSTOP (graceful stop) to the nginx process.</span><span class="token comment"># If, after 5s (--retry QUIT/5) nginx is still running, systemd takes control</span><span class="token comment"># and sends SIGTERM (fast shutdown) to the main process.</span><span class="token comment"># After another 5s (TimeoutStopSec=5), and if nginx is alive, systemd sends</span><span class="token comment"># SIGKILL to all the remaining processes in the process group (KillMode=mixed).</span><span class="token comment">#</span><span class="token comment"># nginx signals reference doc:</span><span class="token comment"># http://nginx.org/en/docs/control.html</span><span class="token comment">#</span><span class="token selector">[Unit]</span><span class="token constant">Description</span><span class="token attr-value"><span class="token punctuation">=</span>A high performance web server and a reverse proxy server</span><span class="token constant">Documentation</span><span class="token attr-value"><span class="token punctuation">=</span>man:nginx(8)</span><span class="token constant">After</span><span class="token attr-value"><span class="token punctuation">=</span>network.target</span><span class="token selector">[Service]</span><span class="token constant">Type</span><span class="token attr-value"><span class="token punctuation">=</span>forking</span><span class="token constant">PIDFile</span><span class="token attr-value"><span class="token punctuation">=</span>/run/nginx.pid</span><span class="token constant">ExecStartPre</span><span class="token attr-value"><span class="token punctuation">=</span>/usr/local/nginx/sbin/nginx -t -q -c /etc/nginx/nginx.conf</span><span class="token constant">ExecStart</span><span class="token attr-value"><span class="token punctuation">=</span>/usr/local/nginx/sbin/nginx -c /etc/nginx/nginx.conf</span><span class="token constant">ExecReload</span><span class="token attr-value"><span class="token punctuation">=</span>/usr/local/nginx/sbin/nginx -s reload</span><span class="token constant">ExecStop</span><span class="token attr-value"><span class="token punctuation">=</span>-/sbin/start-stop-daemon --quiet --stop --retry QUIT/5 --pidfile /run/nginx.pid</span><span class="token constant">TimeoutStopSec</span><span class="token attr-value"><span class="token punctuation">=</span>5</span><span class="token constant">KillMode</span><span class="token attr-value"><span class="token punctuation">=</span>mixed</span><span class="token selector">[Install]</span><span class="token constant">WantedBy</span><span class="token attr-value"><span class="token punctuation">=</span>multi-user.target</span></code></pre><p>创建日志文件夹</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> /var/log/nginx</code></pre><p>启用 Nginx 服务</p><pre class="language-bash" data-language="bash"><code class="language-bash">systemctl daemon-reloadsystemctl <span class="token builtin class-name">enable</span> nginx</code></pre><h2 id="启动-Nginx"><a href="#启动-Nginx" class="headerlink" title="启动 Nginx"></a>启动 Nginx</h2><p>Nginx 配置文件在 <code>/etc/nginx</code></p><p>在配置文件中添加 HTTP/3 相关配置</p><pre class="language-nginx" data-language="nginx"><code class="language-nginx"><span class="token keyword">server</span> <span class="token punctuation">&#123;</span>    <span class="token comment"># Enable QUIC and HTTP/3.</span>    <span class="token keyword">listen</span> <span class="token number">443</span> quic reuseport<span class="token punctuation">;</span>    <span class="token comment"># Enable HTTP/2 (optional).</span>    <span class="token keyword">listen</span> <span class="token number">443</span> <span class="token keyword">ssl</span> http2<span class="token punctuation">;</span>    <span class="token keyword">ssl_certificate</span>      cert<span class="token punctuation">.</span>crt<span class="token punctuation">;</span>    <span class="token keyword">ssl_certificate_key</span>  cert<span class="token punctuation">.</span>key<span class="token punctuation">;</span>    <span class="token comment"># Enable all TLS versions (TLSv1.3 is required for QUIC).</span>    <span class="token keyword">ssl_protocols</span> TLSv1 TLSv1<span class="token punctuation">.</span><span class="token number">1</span> TLSv1<span class="token punctuation">.</span><span class="token number">2</span> TLSv1<span class="token punctuation">.</span><span class="token number">3</span><span class="token punctuation">;</span>    <span class="token comment"># Request buffering in not currently supported for HTTP/3.</span>    proxy_request_buffering off<span class="token punctuation">;</span>    <span class="token comment"># Add Alt-Svc header to negotiate HTTP/3.</span>    <span class="token keyword">add_header</span> alt<span class="token operator">-</span>svc <span class="token string">'h3-29=":443"; ma=86400, h3-28=":443"; ma=86400, h3-27=":443"; ma=86400'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>启动 Nginx</p><pre class="language-bash" data-language="bash"><code class="language-bash">systemctl start nginx</code></pre><h2 id="测试-HTTP-3"><a href="#测试-HTTP-3" class="headerlink" title="测试 HTTP/3"></a>测试 HTTP/3</h2><p><img src="/images/1598329086449.png" alt="查看编译参数"></p><p>安装 Firefox Nightly，在 <code>about:config</code> 中打开 <code>network.http.http3.enabled</code> 选项</p><p><img src="/images/pasted-2.png" alt="Firefox nightly"></p><p>安装 Google Chrome Canary，添加启动参数 <code>--enable-quic --quic-version=h3-29</code></p><p><img src="/images/pasted-3.png" alt="Chrome Canary"></p><p><a href="https://http3check.net/?host=azure.konata.tech">HTTP/3 CHECK</a></p><p><img src="/images/pasted-4.png" alt="HTTP/3 CHECK"></p>]]></content>
      
      
      <categories>
          
          <category> Ops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动 IIS inetpub 文件夹</title>
      <link href="2020/05/06/move-inetpub/"/>
      <url>2020/05/06/move-inetpub/</url>
      
        <content type="html"><![CDATA[<h2 id="下载脚本"><a href="#下载脚本" class="headerlink" title="下载脚本"></a>下载脚本</h2><p><a href="https://social.technet.microsoft.com/Forums/de-DE/7df03b2f-44fa-4cd3-b8f4-5c5e573a1295/iis-85-whats-best-way-to-move-inetpub-directory-to-another-drive?forum=winserversetup">Move IIS to another drive</a></p><h2 id="更改-PowerShell-执行脚本策略"><a href="#更改-PowerShell-执行脚本策略" class="headerlink" title="更改 PowerShell 执行脚本策略"></a>更改 PowerShell 执行脚本策略</h2><p>运行 <code>Get-ExecutionPolicy</code> ，查看当前执行策略：</p><ul><li><code>Restricted</code> ——禁止执行脚本（Windows 默认）</li><li><code>RemoteSigned</code> ——可以执行在本机上写的脚本或者远程下载的带签名的脚本（Windows Server 默认）</li><li><code>Unrestricted</code> ——可以执行所有脚本</li></ul><p>允许执行所有脚本：</p><pre class="language-powershell" data-language="powershell"><code class="language-powershell"><span class="token function">Set</span><span class="token operator">-</span>ExecutionPolicy <span class="token operator">-</span>ExecutionPolicy Unrestricted</code></pre><h2 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h2><p>脚本接受两个参数，第一个参数指定目标盘符，第二个参数 <code>-Force</code> 强制覆盖已存在的 inetpub 文件夹。</p><pre class="language-powershell" data-language="powershell"><code class="language-powershell"><span class="token punctuation">.</span>\Move_IIS<span class="token punctuation">.</span>ps1 D:</code></pre><h2 id="附脚本内容"><a href="#附脚本内容" class="headerlink" title="附脚本内容"></a>附脚本内容</h2><pre class="language-powershell" data-language="powershell"><code class="language-powershell"><span class="token comment">#// Get new drive letter from parameters</span><span class="token keyword">PARAM</span> <span class="token punctuation">(</span> <span class="token namespace">[Parameter(Mandatory=$True)]</span> <span class="token namespace">[string]</span><span class="token variable">$NewDrive</span><span class="token punctuation">,</span> <span class="token namespace">[Parameter(Mandatory=$False)]</span> <span class="token namespace">[switch]</span><span class="token variable">$Force</span><span class="token punctuation">)</span><span class="token comment">#// Ensure the parameter is a sinlge character</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$NewDrive</span><span class="token punctuation">.</span>Length <span class="token operator">-ne</span> 1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token variable">$NewDrive</span> = <span class="token variable">$NewDrive</span><span class="token punctuation">.</span>Substring<span class="token punctuation">(</span>0<span class="token punctuation">,</span>1<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">#// Create variables</span><span class="token variable">$OldPath</span> = <span class="token string">"%SystemDrive%\inetpub"</span><span class="token variable">$NewPath</span> = <span class="token variable">$NewDrive</span><span class="token operator">+</span><span class="token string">":\inetpub"</span><span class="token comment">#// Check new drive actually exists</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token function">Test-Path</span> <span class="token variable">$NewDrive</span><span class="token string">":\"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">Write-Host</span> <span class="token string">"ERROR:"</span><span class="token variable">$NewDrive</span><span class="token string">":\ drive does not exist, stopping"</span> <span class="token keyword">Exit</span><span class="token punctuation">&#125;</span><span class="token comment">#// Test if already exists or Force param present</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token variable">$Force</span><span class="token punctuation">)</span> <span class="token operator">-And</span> <span class="token punctuation">(</span><span class="token function">Test-Path</span> <span class="token variable">$NewPath</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">Write-Host</span> <span class="token string">"ERROR: <span class="token variable">$NewPath</span> already exists, halting move"</span> <span class="token keyword">Exit</span><span class="token punctuation">&#125;</span><span class="token comment">#// Check IIS Installed</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>Get<span class="token operator">-</span>WindowsFeature <span class="token operator">-</span>Name Web<span class="token operator">-</span>Server<span class="token punctuation">)</span><span class="token punctuation">.</span>InstallState <span class="token operator">-ne</span> <span class="token string">"Installed"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token function">Write-Host</span> <span class="token string">"ERROR: IIS not installed, stopping"</span> <span class="token keyword">Exit</span><span class="token punctuation">&#125;</span><span class="token comment">#// stop services</span><span class="token function">Write-Host</span> <span class="token string">"INFO: Stopping IIS"</span><span class="token variable">$StopIIS</span> = &amp;iisreset <span class="token operator">/</span>stop<span class="token comment">#// move inetpub directory</span><span class="token function">Write-Host</span> <span class="token string">"INFO: Moving inetpub directoy to <span class="token variable">$NewPath</span>"</span><span class="token variable">$MoveFiles</span> = &amp;Robocopy C:\inetpub <span class="token variable">$NewPath</span> <span class="token operator">*</span><span class="token punctuation">.</span><span class="token operator">*</span> <span class="token operator">/</span><span class="token function">MOVE</span> <span class="token operator">/</span>S <span class="token operator">/</span>E <span class="token operator">/</span>COPYALL <span class="token operator">/</span>R:0 <span class="token operator">/</span>W:0<span class="token comment">#// Add file C:\inetpub\Moved_to_Disk_$NewDrive</span><span class="token function">Write-Host</span> <span class="token string">"INFO: Adding movedto file"</span><span class="token variable">$NewDir</span> = <span class="token function">New-Item</span> <span class="token string">"C:\inetpub"</span> <span class="token operator">-</span><span class="token function">type</span> directory<span class="token variable">$NewFile</span> = <span class="token function">Out-File</span> C:\inetpub\Moved_to_Disk_<span class="token variable">$NewDrive</span><span class="token comment">#// modify reg</span><span class="token function">Write-Host</span> <span class="token string">"INFO: Updating Registry"</span><span class="token variable">$RegUpdate</span> = <span class="token function">New-ItemProperty</span> <span class="token operator">-</span>Path <span class="token string">"HKLM:\SOFTWARE\Microsoft\InetStp"</span> <span class="token operator">-</span>Name <span class="token string">"PathWWWRoot"</span> <span class="token operator">-</span>Value <span class="token variable">$NewPath</span><span class="token string">"\wwwroot"</span> <span class="token operator">-</span>PropertyType ExpandString <span class="token operator">-</span>Force<span class="token variable">$RegUpdate</span> = <span class="token function">New-ItemProperty</span> <span class="token operator">-</span>Path <span class="token string">"HKLM:\System\CurrentControlSet\Services\WAS\Parameters"</span> <span class="token operator">-</span>Name <span class="token string">"ConfigIsolationPath"</span> <span class="token operator">-</span>Value <span class="token variable">$NewPath</span><span class="token string">"\temp\appPools"</span> <span class="token operator">-</span>PropertyType String <span class="token operator">-</span>Force<span class="token variable">$RegUpdate</span> = <span class="token function">New-ItemProperty</span> <span class="token operator">-</span>Path <span class="token string">"HKLM:\SOFTWARE\Wow6432Node\Microsoft\InetStp"</span> <span class="token operator">-</span>Name <span class="token string">"PathWWWRoot"</span> <span class="token operator">-</span>Value <span class="token variable">$NewPath</span><span class="token string">"\wwwroot"</span> <span class="token operator">-</span>PropertyType ExpandString <span class="token operator">-</span>Force<span class="token comment">#// Backup and modify applicationHost.config file</span><span class="token function">Write-Host</span> <span class="token string">"INFO: Backing up config file"</span><span class="token function">copy-item</span> C:\Windows\System32\inetsrv\config\applicationHost<span class="token punctuation">.</span>config C:\Windows\System32\inetsrv\config\applicationHost<span class="token punctuation">.</span>config<span class="token punctuation">.</span>bak<span class="token function">Start-Sleep</span> 5<span class="token comment">#// Replace "%SystemDrive%\inetpub" with $NewDrive":\inetpub"</span><span class="token function">Write-Host</span> <span class="token string">"INFO: Updating config file"</span><span class="token punctuation">(</span><span class="token function">Get-Content</span> C:\Windows\System32\inetsrv\config\applicationHost<span class="token punctuation">.</span>config<span class="token punctuation">)</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"<span class="token variable">$OldPath</span>"</span><span class="token punctuation">,</span><span class="token string">"<span class="token variable">$NewPath</span>"</span><span class="token punctuation">)</span> <span class="token punctuation">|</span> <span class="token function">Set-Content</span> C:\Windows\System32\inetsrv\config\applicationHost<span class="token punctuation">.</span>config<span class="token comment">#// Update IIS Config</span><span class="token function">Write-Host</span> <span class="token string">"INFO: Updating appcmd config"</span><span class="token variable">$UpdateConfig</span> = &amp;C:\Windows\system32\inetsrv\appcmd <span class="token function">set</span> config <span class="token operator">-</span>section:system<span class="token punctuation">.</span>applicationhost<span class="token operator">/</span>configHistory <span class="token operator">-</span>path:<span class="token variable">$NewPath</span>\history<span class="token comment">#// Start services</span><span class="token function">Write-Host</span> <span class="token string">"INFO: Starting IIS"</span><span class="token variable">$StartIIS</span> = &amp;iisreset <span class="token operator">/</span><span class="token function">start</span><span class="token function">Write-Host</span> <span class="token string">"INFO: Completed"</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Ops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IIS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6 Promise 对象</title>
      <link href="2020/05/03/Promise/"/>
      <url>2020/05/03/Promise/</url>
      
        <content type="html"><![CDATA[<h2 id="Promise-的三种状态"><a href="#Promise-的三种状态" class="headerlink" title="Promise 的三种状态"></a>Promise 的三种状态</h2><ul><li>Pending</li><li>Fullfilled</li><li>Rejected</li></ul><p>Promise 的状态一旦从 Pending 变为 Fullfilled 或 Rejected，就不会再发生改变。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="创建-Promise"><a href="#创建-Promise" class="headerlink" title="创建 Promise"></a>创建 Promise</h3><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//...</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token comment">/* 异步操作成功 */</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将结果传出</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将错误传出</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="then-方法"><a href="#then-方法" class="headerlink" title="then 方法"></a>then 方法</h3><p>then 方法可以接受两个回调函数作为参数。第一个回调函数是 Promise 对象的状态变为 Resolved 时调用，第二个回调函数是 Promise 对象的状态变为 Rejected 时调用，第二个函数是可选的。这两个函数都接受 Promise 对象传出的值作为参数。Promise 新建后会立即执行，then 方法指定的回调函数将在当前脚本所有同步任务执行完成后才会执行。</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">timeout</span><span class="token punctuation">(</span><span class="token parameter">ms</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> ms<span class="token punctuation">,</span> <span class="token string">'done'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">timeout</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>使用 Promise 实现 AJAX</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> <span class="token function-variable function">getJSON</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">url</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">var</span> client <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        client<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span>        client<span class="token punctuation">.</span>onreadystatechange <span class="token operator">=</span> handler<span class="token punctuation">;</span>        client<span class="token punctuation">.</span>responseType <span class="token operator">=</span> <span class="token string">"json"</span><span class="token punctuation">;</span>        client<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">"Accept"</span><span class="token punctuation">,</span> <span class="token string">"application/json"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        client<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">function</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>readyState <span class="token operator">!==</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>statusText<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> promise<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">getJSON</span><span class="token punctuation">(</span><span class="token string">"/post.json"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">json</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Contents: '</span> <span class="token operator">+</span> json<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'ERROR'</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>then 方法可以链式调用，前一个回调函数完成之后，会将返回结果作为参数传入下一个回调函数。</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token function">getJSON</span><span class="token punctuation">(</span><span class="token string">"/post/1.json"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>    <span class="token parameter">post</span> <span class="token operator">=></span> <span class="token function">getJSON</span><span class="token punctuation">(</span>post<span class="token punctuation">.</span>commentURL<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>    <span class="token parameter">comments</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Resolved: "</span><span class="token punctuation">,</span> comments<span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token parameter">err</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Rejected: "</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="catch-方法"><a href="#catch-方法" class="headerlink" title="catch 方法"></a>catch 方法</h3><p>catch 方法是 then(null, rejection) 的别名，用于指定发生错误时的回调函数。建议不要在 then 方法中使用 Rejected 参数，推荐总是使用 catch 方法。如果没有 catch 方法指定错误处理的函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。</p><h3 id="all-方法"><a href="#all-方法" class="headerlink" title="all 方法"></a>all 方法</h3><p>all 方法用于将多个 Promise 实例包装成一个新的 Promise 实例。<br> <code>var p = Promise.all([p1, p2, p3]);</code><br>上面的代码中，Promise.all 方法接受一个数组作为参数，p1、p2、p3 都是 Promise 对象的实例；如果不是，会先调用 Promise.resolve 方法，将参数转为 Promise 实例，再继续处理（Promise.all 方法的参数不一定是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例）。<br>p 的状态由 p1、p2、p3 决定，分为两种情况：</p><ol><li>只有 p1、p2、p3 的状态都变成 Fullfilled，p 的状态才会变成 Fullfilled，此时 p1、p2、p3 的返回值组成一个数组，传递给 p 的回调函数。</li><li>只要 p1、p2、p3 中有一个被 Rejected，p 的状态就变成 Rejected，此时第一个被 Rejected 的实例的返回值会传递给 p 的回调函数。</li></ol><blockquote><p>如果作为参数的 Promise 实例自身定义了 catch 方法，那么他被 rejected 时并不会触发 Promise.all() 的 catch 方法。</p></blockquote><h3 id="race-方法"><a href="#race-方法" class="headerlink" title="race 方法"></a>race 方法</h3><p>race 方法同样是将多个 Promise 实例包装成一个新的 Promise 实例。但 p1、p2、p3 中有一个实例率先改变状态，p 的状态就会改变。那个最先改变的 Promise 实例的返回值就传递给 p 的回调函数。</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token comment">//如果 5 秒钟内 fetch 没有返回结果，p 将变为 Rejected，触发 catch 方法</span><span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">[</span>    <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/request'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'request timeout'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">response</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">error</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="resolve-方法"><a href="#resolve-方法" class="headerlink" title="resolve 方法"></a>resolve 方法</h3><p>resolve 方法可以将现有对象转为 Promise 对象。分为四种情况：</p><ul><li><strong>参数是一个 Promise 实例</strong>  </li></ul><p>会直接返回这个实例。</p><ul><li><strong>参数是一个 thenable 对象</strong>  </li></ul><p>指具有 then 方法的对象：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">let</span> thenable <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token function-variable function">then</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre><p>resolve 方法会将这个对象转为 Promise 对象，然后立即执行 thenable 对象的 then 方法。</p><ul><li><strong>参数不是 thenable 对象或不是对象</strong>  </li></ul><p>resolve 方法返回一个新的 Promise 对象，状态为 Resolved。resolve 方法的参数会传给回调函数并立即执行。</p><ul><li><strong>不带有任何参数</strong>  </li></ul><p>直接返回一个 Resolve 状态的 Promise 对象。  </p><pre><code>&gt; 立即 resolve 的 Promise 对象是在本轮“事件循环“（event loop）结束时，而不是再下一轮”事件循环“开始时。</code></pre><pre class="language-js" data-language="js"><code class="language-js"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'three'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'two'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'one'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// one</span><span class="token comment">// two</span><span class="token comment">// three</span></code></pre><pre><code>其中：</code></pre><p><code>console.log(&#39;one&#39;)</code> 立即执行；<br><code>Promise.resolve()</code> 在本轮”事件循环“结束时执行；<br><code>setTimeout(fn, 0)</code> 在下一轮”事件循环“开始时执行。</p><h3 id="reject-方法"><a href="#reject-方法" class="headerlink" title="reject 方法"></a>reject 方法</h3><p>reject 方法也会返回一个新的 Promise 实例，状态为 Rejected，reject 方法的参数会原封不动地作为 reject 的理由变成后续方法的参数，回调函数会立即执行。</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> thenable <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'ERROR'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>thenable<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">e</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e <span class="token operator">===</span> thenable<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">// true</span><span class="token comment">// Promise.reject 方法的参数是一个 thenable 对象，执行以后，后面 catch 方法的参数不是 reject 抛出的”ERROR“字符串，而是 thenable 对象。</span></code></pre><h3 id="finally-方法"><a href="#finally-方法" class="headerlink" title="finally 方法"></a>finally 方法</h3><p>finally 方法用于指定 Promise 对象最后状态如何都会执行的操作，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。</p><h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>让同步函数同步执行，异步函数异步执行，有两种方法。<br>第一种写法，使用 <code>async</code> 函数：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'now'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'next'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// now</span><span class="token comment">// next</span></code></pre><p>上面的代码中，第二行是一个立即执行的匿名函数，会立即执行里面的 <code>async</code> 函数，因此如果 <code>f</code> 是同步的，就会得到同步的结果；如果 <code>f</code> 是异步的，就可以用 <code>then</code> 指定下一步，需要注意， <code>async() =&gt; f()</code> 会吃掉 <code>f()</code> 抛出的错误，捕获错误需要使用 <code>promise.catch</code> 方法。写法如下：</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span></code></pre><p>第二种写法，使用 <code>new Promise()</code> 。</p><pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'now'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span>    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>        <span class="token parameter">resolve</span> <span class="token operator">=></span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'next'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// now</span><span class="token comment">// next</span></code></pre><p>上面的代码也是用立即执行的匿名函数来执行 <code>new Promise()</code> 的。这种情况下，同步函数也是同步执行的。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Webhook 自动从 GitHub 更新博客</title>
      <link href="2020/04/29/AutoUpdateBlog/"/>
      <url>2020/04/29/AutoUpdateBlog/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-Webhook"><a href="#什么是-Webhook" class="headerlink" title="什么是 Webhook"></a>什么是 Webhook</h2><p>Webhook 就像一个回调函数，允许当设定的 GitHub 事件被触发时，发送特定的请求到指定的 URL。利用这一点，我们可以在将本地博客提交至 GitHub 时，自动发送通知到博客服务器，执行 git pull 操作来更新服务器上的文件。</p><h2 id="使用-webhook-工具当作监听程序"><a href="#使用-webhook-工具当作监听程序" class="headerlink" title="使用 webhook 工具当作监听程序"></a>使用 webhook 工具当作监听程序</h2><p>有一个叫 <a href="https://github.com/adnanh/webhook">webhook</a> 工具可以帮我们执行监听并执行脚本的工作。官方文档上有比较详细的安装与配置教程。<br>我的配置文件：</p><pre class="language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>  <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"hexo-webhook"</span><span class="token punctuation">,</span>  <span class="token property">"execute-command"</span><span class="token operator">:</span> <span class="token string">"/home/hexo-redeploy-webhook.sh"</span><span class="token punctuation">,</span>  <span class="token property">"command-working-directory"</span><span class="token operator">:</span> <span class="token string">"/home"</span><span class="token punctuation">,</span>  <span class="token property">"trigger-rule"</span><span class="token operator">:</span>  <span class="token punctuation">&#123;</span>    <span class="token property">"and"</span><span class="token operator">:</span>    <span class="token punctuation">[</span>      <span class="token punctuation">&#123;</span>        <span class="token property">"match"</span><span class="token operator">:</span>        <span class="token punctuation">&#123;</span>          <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"payload-hash-sha1"</span><span class="token punctuation">,</span>          <span class="token property">"secret"</span><span class="token operator">:</span> <span class="token string">"secret"</span><span class="token punctuation">,</span>          <span class="token property">"parameter"</span><span class="token operator">:</span>          <span class="token punctuation">&#123;</span>            <span class="token property">"source"</span><span class="token operator">:</span> <span class="token string">"header"</span><span class="token punctuation">,</span>            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"X-Hub-Signature"</span>          <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">]</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="打开-Github-的-Webhook-功能"><a href="#打开-Github-的-Webhook-功能" class="headerlink" title="打开 Github 的 Webhook 功能"></a>打开 Github 的 Webhook 功能</h2><p>在 GitHub 上相应仓库的 Settings 中找到 Webhook 功能，添加一个钩子， <code>Payload URL</code> 填入服务器监听地址， <code>Content type</code> 选择 <code>application/x-www-form-urlencoded</code> ， <code>Secret</code> 填入上面配置文件中的 <code>secret</code> ，钩子触发中选择 push 事件，勾选 Active，这样 GitHub 端就配置完成了。</p><h2 id="编写自动更新脚本"><a href="#编写自动更新脚本" class="headerlink" title="编写自动更新脚本"></a>编写自动更新脚本</h2><p>因为服务器的 webhook 触发之后执行的是一个命令，还需要一个 shell 脚本来对博客部署目录进行更新。<br>脚本如下，因为国内网络到 GitHub 的连通性奇差，所以加入了拉取失败重试的机制。  </p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#! /bin/bash</span><span class="token builtin class-name">cd</span> /srv/nginx/hexo_root<span class="token assign-left variable">retry</span><span class="token operator">=</span><span class="token number">0</span><span class="token keyword">while</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$retry</span>"</span> -lt <span class="token number">5</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token keyword">do</span>    <span class="token function">git</span> reset --hard HEAD    <span class="token function">git</span> pull    <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$?</span> -eq <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>        <span class="token builtin class-name">echo</span> <span class="token string">"Hexo git pull SUCCESS."</span>        <span class="token builtin class-name">break</span>    <span class="token keyword">fi</span>    <span class="token assign-left variable">retry</span><span class="token operator">=</span> <span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $<span class="token punctuation">&#123;</span>retry<span class="token punctuation">&#125;</span> + <span class="token number">1</span><span class="token variable">`</span></span>    <span class="token builtin class-name">echo</span> <span class="token string">"Hexo git pull FAIL. Retrying <span class="token variable">$retry</span> time(s)."</span><span class="token keyword">done</span></code></pre><blockquote><p><strong>一个坑</strong><br>git 如果要设置代理的话，一定要使用 <code>git config --system https.proxy socks5://127.0.0.1:1080</code> 设置，不要使用 <code>--global</code> 参数设置  </p></blockquote><p>之后每当博客更新执行 <code>hexo deploy</code> 的时候，服务器端就会自动更新页面了，免去了 SSH 进去手动更新的麻烦。</p>]]></content>
      
      
      <categories>
          
          <category> Ops </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AV1 编码测试</title>
      <link href="2020/04/28/Misaka-Dances/"/>
      <url>2020/04/28/Misaka-Dances/</url>
      
        <content type="html"><![CDATA[<p>使用 Video2X 生成的 1440P Misaka Dances 作为源<br>分辨率 1920*1440<br>比特率 1000 kbps<br>2pass 模式</p><h3 id="AV1-8bit"><a href="#AV1-8bit" class="headerlink" title="AV1 8bit"></a>AV1 8bit</h3><p>解码压力不高，可以流畅播放。</p><pre class="language-bash" data-language="bash"><code class="language-bash">.<span class="token punctuation">\</span>aomenc.exe --webm -w <span class="token number">1920</span> -h <span class="token number">1440</span> --fps<span class="token operator">=</span><span class="token number">30</span>/1 --cpu-used<span class="token operator">=</span><span class="token number">4</span> --bit-depth<span class="token operator">=</span><span class="token number">8</span> --color-primaries<span class="token operator">=</span>bt709 --end-usage<span class="token operator">=</span>cq --target-bitrate<span class="token operator">=</span><span class="token number">1000</span> --passes<span class="token operator">=</span><span class="token number">2</span> --pass<span class="token operator">=</span><span class="token number">2</span> --fpf<span class="token operator">=</span>8b.log -o 8b.webm y4m.y4m</code></pre><p><video controls width="100%"><source src="/media/AV1_8bit_HEAAC.mp4" type="video/webm"><br></video></p><hr><h3 id="AV1-10bit"><a href="#AV1-10bit" class="headerlink" title="AV1 10bit"></a>AV1 10bit</h3><p>1230V3 严重卡顿，8750H 卡顿，A12X 轻微卡顿，画质相比 8bit 提升极小</p><pre class="language-bash" data-language="bash"><code class="language-bash">.<span class="token punctuation">\</span>aomenc.exe --webm -w <span class="token number">1920</span> -h <span class="token number">1440</span> --fps<span class="token operator">=</span><span class="token number">30</span>/1 --cpu-used<span class="token operator">=</span><span class="token number">4</span> --bit-depth<span class="token operator">=</span><span class="token number">10</span> --color-primaries<span class="token operator">=</span>bt709 --end-usage<span class="token operator">=</span>cq --target-bitrate<span class="token operator">=</span><span class="token number">1000</span> --passes<span class="token operator">=</span><span class="token number">2</span> --pass<span class="token operator">=</span><span class="token number">2</span> --fpf<span class="token operator">=</span>10b.log -o 10b.webm y4m.y4m</code></pre><p><video controls width="100%"><source src="/media/AV1_10bit_HEAAC.mp4" type="video/webm"><br></video></p><hr><h3 id="AV1-12bit"><a href="#AV1-12bit" class="headerlink" title="AV1 12bit"></a>AV1 12bit</h3><p>解码压力更大并且有马赛克，画质相比 10bit 提升极小</p><pre class="language-bash" data-language="bash"><code class="language-bash">.<span class="token punctuation">\</span>aomenc.exe --webm -w <span class="token number">1920</span> -h <span class="token number">1440</span> --fps<span class="token operator">=</span><span class="token number">30</span>/1 --cpu-used<span class="token operator">=</span><span class="token number">1</span> --bit-depth<span class="token operator">=</span><span class="token number">12</span> --color-primaries<span class="token operator">=</span>bt709 --end-usage<span class="token operator">=</span>cq --target-bitrate<span class="token operator">=</span><span class="token number">1000</span> --passes<span class="token operator">=</span><span class="token number">2</span> --pass<span class="token operator">=</span><span class="token number">2</span> --fpf<span class="token operator">=</span>12b.log -o 12b.webm y4m.y4m</code></pre><p><video controls width="100%"><source src="/media/AV1_12bit_HEAAC.mp4" type="video/webm"><br></video></p>]]></content>
      
      
      <categories>
          
          <category> Codec </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AV1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VapourSynth 输出无损视频</title>
      <link href="2020/04/27/codec/"/>
      <url>2020/04/27/codec/</url>
      
        <content type="html"><![CDATA[<h3 id="VapourSynth-输出-YUV4MPEG"><a href="#VapourSynth-输出-YUV4MPEG" class="headerlink" title="VapourSynth 输出 YUV4MPEG"></a>VapourSynth 输出 YUV4MPEG</h3><p> <code>vspipe -y -p script.vpy out.y4m</code></p><h3 id="VapourSynth-输出-HuffYUV"><a href="#VapourSynth-输出-HuffYUV" class="headerlink" title="VapourSynth 输出 HuffYUV"></a>VapourSynth 输出 HuffYUV</h3><p> <code>vspipe -y -p script.vpy - | ffmpeg -i pipe: -r 24 -c:v huffyuv out.avi</code></p>]]></content>
      
      
      <categories>
          
          <category> Codec </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AV1 </tag>
            
            <tag> ffmpeg </tag>
            
            <tag> VapourSynth </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>To Do List</title>
      <link href="2020/04/04/To-Do/"/>
      <url>2020/04/04/To-Do/</url>
      
        <content type="html"><![CDATA[<h3 id="Blog"><a href="#Blog" class="headerlink" title="Blog"></a>Blog</h3><ul><li><input disabled="" type="checkbox"> 多写博客！</li><li><input checked="" disabled="" type="checkbox"> 为 docsify 适配 dark mode </li><li><input checked="" disabled="" type="checkbox"> 为 Live2D 添加 moc3 模型支持</li><li><input checked="" disabled="" type="checkbox"> 添加新的 Live2D 角色</li><li><input checked="" disabled="" type="checkbox"> 重构 waifu-tips, 抛弃 jquery</li></ul><h3 id="ClassRoom"><a href="#ClassRoom" class="headerlink" title="ClassRoom"></a>ClassRoom</h3><ul><li><input disabled="" type="checkbox"> Go 控制开关机</li><li><input disabled="" type="checkbox"> 角色权限管理</li><li><input disabled="" type="checkbox"> 扫码提交工单</li></ul>]]></content>
      
      
      <categories>
          
          <category> Miscellaneous </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TODO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="2020/03/16/dp/"/>
      <url>2020/03/16/dp/</url>
      
        <content type="html"><![CDATA[<h2 id="神奇口袋问题"><a href="#神奇口袋问题" class="headerlink" title="神奇口袋问题"></a>神奇口袋问题</h2><p>有一个神奇的口袋总的容积是 40，用这个口袋可以变出一些物品，这些物品的总体积必须是 40。  </p><h3 id="DP（动态规划）思路"><a href="#DP（动态规划）思路" class="headerlink" title="DP（动态规划）思路"></a>DP（动态规划）思路</h3><p>k 种物品凑成体积 w 的方法：k-1 种物品凑成体积 w 的方法数加上 k-1 种物品凑成 w-a[k] 体积+k 物品 a[k] 这一种方法<br> <code>Ways[w][k] = Ways[w][k] + Ways[w - a[k]][k - 1];</code></p><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">int</span> N<span class="token punctuation">;</span><span class="token keyword">int</span> Ways<span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//Ways[i][j] 表示从前 j 种物品里凑出体积 i 的方法数</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> cin <span class="token operator">>></span> N<span class="token punctuation">;</span> <span class="token function">memset</span><span class="token punctuation">(</span>Ways<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Ways<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//数组初始化值为 0</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"请输入当前第"</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">"个商品的体积："</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  cin <span class="token operator">>></span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//输入第 i 个商品的体积</span>  Ways<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//边界条件 任意 i 个物品凑体积 0 的方法都是一种：选 0 个物品</span> <span class="token punctuation">&#125;</span> Ways<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//边界条件 0 个物品凑 0 体积方法只有一种：选 0 个物品</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> w <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> w <span class="token operator">&lt;=</span> <span class="token number">40</span><span class="token punctuation">;</span> <span class="token operator">++</span>w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>   Ways<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> Ways<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//令 k 种物品里凑出体积 w 的方法数，暂由前 k-1 个物品凑成。</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>w <span class="token operator">-</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span>         <span class="token comment">//如果第 k 种物品体积小于 w</span>    <span class="token comment">//则 k 种物品凑成体积 w 的方法：k-1 种物品凑成 w + k-1 种物品凑成 w-a[k] 体积+k 物品 a[k] 这一种方法</span>    Ways<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> Ways<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> Ways<span class="token punctuation">[</span>w <span class="token operator">-</span> a<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span> cout <span class="token operator">&lt;&lt;</span> Ways<span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0-1 背包问题"></a>0-1 背包问题</h2><p>DP（动态规划）求解过程可以这样理解：对于前 i 件物品，背包容量为 j 时，所取得的最大价值（此时称为状态 3）只依赖于前两个状态。</p><p>状态 1：前 i-1 件物品，背包容量为 j。在该状态下，只要不选第 i 个物品，就可以转换到状态 3。</p><p>状态 2：前 i-1 件物品，背包容量为 j-w[i]。在该状态下，选完前 i-1 个商品后，背包还剩 w[i] 的容量，加上第 i 个物品，也可以转换到状态 3。</p><p>这里要求最大价值，所以只要从状态 1 和状态 2 中选择最大价值较大的一个即可。</p><p>`</p><pre><code class="c">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 3500;const int maxm = 13000;int n, m;int w[maxn], d[maxn];//w: 体积  d: 价值////方法一： 二维数组表示int dp[maxn][maxm]; //表示取 maxn 种物品，使它们总体积不超过 maxm 的最优取法取得的价值总和int main() &#123;    cout &lt;&lt; &quot;物品个数 n:&quot;;    cin &gt;&gt; n;    cout &lt;&lt; &quot;背包的总容量体积：&quot;;    cin &gt;&gt; m;    for (int i = 1; i &lt;= n; i++) &#123;        cout &lt;&lt; &quot;请输入物品&quot; &lt;&lt; i &lt;&lt; &quot;体积，单价：&quot;;        cin &gt;&gt; w[i] &gt;&gt; d[i];    &#125;    memset(dp, 0, sizeof(dp));//数组初始化值为 0    for (int i = 1; i &lt;= n; i++) &#123;        for (int j = 1; j &lt;= m; j++) &#123;            if (w[i] &lt;= j)                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + d[i]);            else dp[i][j] = dp[i - 1][j];        &#125;    &#125;    cout &lt;&lt; &quot;最大价值：&quot; &lt;&lt; dp[n][m] &lt;&lt; endl;    return 0;&#125;////方法二： 一维滚动数组int dp[maxm];int main()&#123;    cout &lt;&lt; &quot;物品个数 n:&quot;;    cin &gt;&gt; n;    cout &lt;&lt; &quot;背包的总容量体积：&quot;;    cin &gt;&gt; m;    for (int i = 1; i &lt;= n; i++)    &#123;        cout &lt;&lt; &quot;请输入物品&quot; &lt;&lt; i &lt;&lt; &quot;体积，单价：&quot;;        cin &gt;&gt; w[i] &gt;&gt; d[i];    &#125;    memset(dp, 0, sizeof(dp)); //数组初始化 0    for (int i = 1; i &lt;= n; i++) &#123;        for (int j = m; j &gt;= w[i]; j--)        &#123;            dp[j] = max(dp[j], dp[j - w[i]] + d[i]);        &#125;    &#125;    cout &lt;&lt; &quot;最大价值：&quot; &lt;&lt; dp[m] &lt;&lt; endl;    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSP 生命周期</title>
      <link href="2020/03/13/Life-cycle-of-JSP/"/>
      <url>2020/03/13/Life-cycle-of-JSP/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/pasted-0.png" alt=""></p><ol><li>将 JSP 页面文件翻译为 servlet 代码；</li><li>编译 servlet 代码为 class 文件；</li><li>将 servlet 载入容器并实例化类；</li><li>调用 jspInit() 方法初始化，在 servlet 实例化后只执行一次；</li><li>使用_jspService() 方法处理请求，这个方法不能重写；</li><li>当 JSP 从容器中移除时调用 jspDestroy() 方法。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UpdateLog</title>
      <link href="2019/08/06/UpdateLog/"/>
      <url>2019/08/06/UpdateLog/</url>
      
        <content type="html"><![CDATA[<ul><li><p>2019.07.25 框架搭建完成</p></li><li><p>2019.08.02 主题修改完成</p></li><li><p>2019.08.06 崩坏学园 2 LIVE2D 上线 <del>那么崩坏 3 的看板娘什么时候能放上 Web 呢</del></p></li><li><p>2019.08.07 部署 Hexo Admin</p></li><li><p>2019.08.10</p><ul><li>部署 HTTPS</li><li>支持 HSTS</li></ul></li><li><p>2019.08.15 更新 favicon</p></li><li><p>2020.02.25 迁移至阿里云</p></li><li><p>2020.03.01</p><ul><li>更新 nginx 1.17.8</li><li>支持 HTTP/3 h3-25 h3-26 h3-27</li><li>支持 TLS1.3</li><li>停用 TLS1.1 TLS1.2 协议  </li></ul><p>nginx 编译参数：</p></li></ul><pre class="language-bash" data-language="bash"><code class="language-bash">--add-module<span class="token operator">=</span><span class="token punctuation">..</span>/ngx_brotli --with-openssl<span class="token operator">=</span><span class="token punctuation">..</span>/quiche/deps/boringssl --with-quiche<span class="token operator">=</span><span class="token punctuation">..</span>/quiche --with-http_v2_module --with-http_v3_module --with-http_ssl_module --with-http_gzip_static_module --with-http_v2_hpack_enc --with-http_realip_module --with-threads --with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module --with-zlib<span class="token operator">=</span><span class="token punctuation">..</span>/zlib-cf --add-module<span class="token operator">=</span><span class="token punctuation">..</span>/ngx_devel_kit --add-module<span class="token operator">=</span><span class="token punctuation">..</span>/headers-more-nginx-module --add-module<span class="token operator">=</span><span class="token punctuation">..</span>/lua-nginx-module-0.10.16rc4 --with-file-aio --add-module<span class="token operator">=</span><span class="token punctuation">..</span>/ngx_http_geoip2_module --add-module<span class="token operator">=</span><span class="token punctuation">..</span>/ngx-fancyindex --add-module<span class="token operator">=</span><span class="token punctuation">..</span>/nginx-dav-ext-module --add-module<span class="token operator">=</span><span class="token punctuation">..</span>/ngx_http_substitutions_filter_module --with-libatomic --with-http_dav_module --with-http_stub_status_module</code></pre><ul><li>2020.03.05<ul><li>优化 加载速度</li><li>Live2D 音频替换为 opus</li><li>通过 webp server 替换所有图片为 webp</li><li>非首屏图片懒加载</li></ul></li><li>2020.03.12 新增 服务器 webhook 自动部署</li><li>2020.03.13  <ul><li>修复 懒加载导致的首页图片错位</li><li>更新 全局配色</li></ul></li><li>2020.03.14<ul><li>部署 zabbix grafana</li></ul></li><li>2020.03.15<ul><li>申请提交 HSTS preload list</li></ul></li><li>2020.03.24<ul><li>移除主页轮播图相关代码</li></ul></li><li>2020.05.08<ul><li>更换 DNS 解析服务至 DNSPod</li><li><del>为网站增加 Cloudflare CDN</del></li></ul></li><li>2020.05.12<ul><li><del>鉴于 Cloudflare 在国内是减速 CDN 再次更换为百度云加速</del></li><li>修复 Live2D 关闭后刷新页面会再次出现的问题</li></ul></li><li>2020.05.13<ul><li>添加显示看板娘按钮</li></ul></li><li>2020.05.24<ul><li>背景音乐增加到 15 首，Safari 使用 CAF 封装 Opus 编码，其他浏览器使用 OGG 封装 Vorbis 编码</li></ul></li><li>2020.07.26<ul><li>将大部分库替换为 jsDeliver 的 CDN 地址</li></ul></li><li>2020.07.27<ul><li>根据 <a href="https://developers.google.com/speed/pagespeed/insights/">PageSpeed Insights</a> 又做了部分性能优化，1M 带宽真是太难了</li></ul></li><li>2020.08.01<ul><li>图片懒加载使用 <a href="https://css-tricks.com/aspect-ratio-boxes/">Aspect Ratio Boxes</a> 方案</li></ul></li><li>2020.08.04<ul><li>去除 <code>favicon-16x16.png</code> ，使 FireFox 默认加载 32x32 的 favicon</li><li>去除 <code>favicon.png</code></li></ul></li><li>2020.08.07<ul><li>基于 docsify 的简洁版博客<del>笔记本</del>上线</li></ul></li><li>2020.08.10<ul><li>为 docsify 适配深色模式，支持自动切换和手动<del>拉绳</del>切换</li></ul></li><li>2020.08.11<ul><li>抛弃 Aplayer，使用自己写的逻辑播放 BGM</li><li>点线背景在横向分辨率小于 1040px 的设备上将不会加载</li></ul></li><li>2020.08.12<ul><li>BGM 支持跨页面不间断播放</li><li>BGM 开始播放时淡入音量至设定值</li></ul></li><li>2020.08.13<ul><li>重写 matery.js, 剔除 jQuery 依赖</li><li>重写 waifu-tips.js, 剔除 jQuery 依赖</li><li>增加 2 首 BGM</li><li>标签、分类、归档页面图片懒加载修复</li><li>取消移动端的卡片 hover 效果</li><li>移除 AOS 库及相关标签属性</li><li>移除 ScrollProgress 库</li><li>Live2D 现在只在逻辑像素宽度大于 1040px 时显示</li></ul></li><li>2020.08.14<ul><li>为 .mtn 加上了 brotli 压缩</li><li>修复文章内容页面底部的错位</li></ul></li><li>2020.08.19<ul><li>替换看板娘为自己写的脚本 <a href="https://github.com/Konata09/Live2dOnWeb/">Live2dOnWeb</a></li><li>支持 Cubism 3, Cubism 4 模型</li><li>增加 Live2D 模型到 23 个</li></ul></li><li>2020.08.26<ul><li>VPS 升级到 2M 带宽</li><li>更新 nginx 到 1.19.2</li></ul></li><li>2020.09.02<ul><li>增加 umami 分析</li></ul></li><li>2020.11.24<ul><li>增加派蒙看板</li><li>自动播放进入动作</li></ul></li><li>2020.12.5<ul><li>增加可莉看板</li></ul></li><li>2020.12.6<ul><li>庆祝 Big Sur 及 iOS/iPadOS 14 支持 WebP 图片，看板娘贴图增加 WebP 格式，在支持的浏览器上可获得 🚀 3x-5x 加载速度提升！</li><li>cwebp 1.10 参数 <code>-q 100 -m 6</code></li></ul></li><li>2020.12.23<ul><li>修复了 Docsify 博客在 Safari 下无法加载的问题</li></ul></li><li>2021.01.30<ul><li>Bug fix</li><li>增加看板</li></ul></li><li>2021.01.31<ul><li>更新 Nginx 到 1.19.6</li><li>升级 Hexo 到 5.3.0</li><li>优化加载速度 打包 js</li></ul></li><li>2021.02.01<ul><li>FireFox 和 Chrome 稳定版已开启 AVIF 图片支持，首页图片和文章 banner 图增加 AVIF 格式，根据浏览器支持情况自动返回 AVIF WebP jpg 格式</li><li>avifenc 0.8.4 参数 <code>-s 0 -y 420 --min 26 --max 30</code></li><li>优化加载速度 打包 css</li></ul></li><li>2021.02.02<ul><li>FontAwesome update and minified</li><li>优化了标签、分类及关于页面 tag 的显示效果</li><li>修复了标签与分类页面的 tag 上可能不显示文章数量的 bug</li><li>优化了主页在不同设备下的显示效果</li></ul></li><li>2021.02.03<ul><li>优化了音量调整逻辑</li><li>修复了代码块花括号显示错误的 bug</li><li>优化了搜索界面的显示效果</li></ul></li><li>2021.02.14<ul><li>优化了 macOS 下的字体显示效果</li><li>修复了部分图标不显示的问题</li><li>优化了归档时间轴的显示效果</li></ul></li><li>2021.02.17<ul><li>看板娘资源文件迁移至腾讯云</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Miscellaneous </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UpdateLog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2019/06/18/hello-world/"/>
      <url>2019/06/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
